# 第 7 章 链接

链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载到存储器并执行。

- 链接可以执行于
    - 编译时(compile time)
    - 加载时(load time)
    - 运行时(run time)

> 链接器使得**分离编译**（separate compilation）成为可能，这样可以将一个程序分割成多个文件，每个文件可以独立编译。之后修改一个文件，只需重新编译这个文件，而不必重新编译所有文件。

## 7.1 编译器驱动程序

大多数编译系统提供**编译器驱动程序**，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。

```c
// main.c
int sum(int *a, int n);

int array[2] = {1,2};

int main(){
  int val = sum(array, 2);
  return val;
}

// sum.c
int sum(int *a, int n) {
  int i, s = 0;
  for (i = 0; i < n; i++) {
    s += a[i];
  }
  return s;
}
```

![20240505221432](https://cdn.jsdelivr.net/gh/Corner430/Picture/images/20240505221432.png)

## 7.2 静态链接

静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

在构造可执行文件的过程中，链接器必须要完成两个任务：
1. **符号解析**（symbol resolution）
    目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。符号解析的目的是将每个符号**引用**正好和一个符号**定义**关联起来。
2. **重定位**（relocation）
    编译器和汇编器生成从地址 0 开始的代码和数据节（section）。链接器通过把每个符号定义与一个内存位置关联起来，从而**重定位**这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

## 7.3 目标文件

目标文件有三种形式：

- **可重定位目标文件**。包含二进制代码和数据，其形式可以在编译时和其他可重定位目标文件合并起来，创建一个可执行目标文件
- **可执行目标文件**。包含二进制代码和数据，其形式可以被直接复制到内存并执行
- **共享目标文件**。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到内存并链接。

编译器和汇编器生成可重定位目标文件（包括共享目标文件），链接器生成可执行目标文件。

## 7.4 可重定位目标文件

可重定位目标文件由多个不同的节组成，每一节都是一个连续的字节序列。指令、初始化了的全局变量、未初始化的变量分别位于不同的节。

![20240506093458](https://cdn.jsdelivr.net/gh/Corner430/Picture/images/20240506093458.png)

![20240505222654](https://cdn.jsdelivr.net/gh/Corner430/Picture/images/20240505222654.png)

- **ELF头**（ELF header）。以一个 16 字节的序列开始，描述了生成该文件的系统的字长和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。

> 夹在 ELF 头和节头部表之间的都是节

- `.text`: 已编译程序的机器代码
- `.rodata`: **只读数据**，比如 `printf` 语句中的格式串和开关语句的跳转表
- `.data`: **已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中**，既不在 `.data` 也不在 `.bss` 中
- `.bss`: **未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量**。不需要占用实际的磁盘空间
- `.symtab`: 符号表，存放在程序中定义和引用的函数和全局变量的信息。
- `.rel.text`: `.text` 节中位置的列表
- `.rel.data`: 被模块引用或定义的而所有全局变量的重定位信息。
- `.debug`: 调试符号表

> 相对于`.data`, 可以将 `.bss` 看成是 “更好地节省空间（Better Save Space）” 的缩写

> 每一个进程的用户空间是私有的，但是内核空间是共享的。进程之间的通信方式之一匿名管道通信就是用的这个特性

**示例**
```cpp
#include <iostream>

using namespace std;

int gdata1 = 10; // .data
int gdata2 = 0;  // .bss
int gdata3;      // .bss

static int gdata4 = 11; // .data
static int gdata5 = 0;  // .bss
static int gdata6;      // .bss

int main() {    // .text
  int a = 12;   // 这三个局部变量产生的是 MOV 指令，在 .text 段，运行时，12 被加载到栈上
  int b = 0;
  int c;

  static int e = 13; // .data
  static int f = 0;  // .bss
  static int g;      // .bss
  return 0;     // .text
}
```

> 此时 `c` 一定不为 0，因为它是栈上的无效值，`g` 一定是 0，因为它是 `.bss` 段的变量

## 7.5 符号和符号表

**每个重定位的目标模块 m 都有一个符号表，包含 m 所定义和引用的符号的信息**。在链接器的上下文中，有三种不同的符号：

- 由模块 m 定义并能被其他模块引用的**全局符号**。全局链接器符号对应于非静态的 C 函数和全局变量。

- 由其他模块定义并被模块 m 所引用的**全局符号**。这些符号称为**外部符号**，对应于在其他模块中定义的非静态 C 函数和全局变量。

- 只被模块 m 定义和引用的**局部符号**。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，**但是不能被其他模块引用**。

> 本地链接器符号和本地程序变量是不同的

```c
int f() {
  static int x = 0;
  return x;
}

int g() {
  static int x = 0;
  return x;
}
```

此时，编译器向汇编器输出两个不同名字的局部链接器符号。

> C 程序员使用 static 属性隐藏模块内部的变量和函数声明，如同 C++ 中的 public 和 private 声明一样. 在 C 中，源文件扮演模块的角色。任何带有 static 属性声明的全局变量或者函数都是模块私有的。类似地，任何不带 static 属性声明的全局变量和函数都是公共的，可以被其他模块访问。

## 7.6 符号解析

**链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。**

> 对全局符号的引用解析会非常棘手与麻烦

### 7.6.1 链接器如何解析多处定义的全局符号

**链接器的输入是一组可重定位目标模块**

在编译时，编译器向汇编器输出每个全局符号，或者是强（stong），或者是弱（week），而汇编器把这些信息隐含地编码在可重定位目标文件的符号表里。**函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。**

根据强弱符号的定义，Linux 使用以下规则来处理多重定义的符号名：
1. 不允许有多个同名的强符号
2. 如果有一个强符号和多个弱符号同名，则选择强符号
3. 如果有多个弱符号同名，则从中随机选择一个

**代码示例参见《深入理解计算机系统》P. 471 ~ 474**

### 7.6.2 与静态库链接

所有编译系统都提供了一种机制，将所有相关的目标模块打包成一个单独的文件，称为**静态库**（static library），它也可以作为链接器的输入。

编译链接示例：`gcc main.c /usr/lib/libm.a /usr/lib/libc.a`

在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。

![20240506131802](https://cdn.jsdelivr.net/gh/Corner430/Picture/images/20240506131802.png)

### 7.6.3 链接库如何使用静态库来解析引用


## 7.7 重定位

一旦链接器完成符号解析这一步，就把代码中每一个符号的引用和确定的一个符号定义结合起来。链接器就知道它的输入目标模块中的代码节和数据节的确定大小。后面就是重定位的步骤了，

重定位由两个部分组成：

1. **重定位节和符号定义**
2. **重定位节中的符号引用**，链接器修改代码节和数据节中的每一个符号引用，使得他们指向正确的地址

### 7.7.1 重定位条目

无论何时汇编器遇到对最终位置未知的目标引用，他就会生成一个重定位表目（relocation entry），告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。

有两种最基本的重定位类型：

- R_386_PC32 ： 重定位一个使用32位PC相关的地址引用
- R_386_32 ： 重定位一个使用32位绝对地址的引用

## 7.8 可执行目标文件

![20240506132410](https://cdn.jsdelivr.net/gh/Corner430/Picture/images/20240506132410.png)

## 7.9 加载可执行目标文件

![20240506132537](https://cdn.jsdelivr.net/gh/Corner430/Picture/images/20240506132537.png)