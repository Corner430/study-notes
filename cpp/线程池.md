[线程池一版](https://github.com/Corner430/study-notes/blob/main/cpp/线程池/线程池一版)

[线程池二版](https://github.com/Corner430/study-notes/blob/main/cpp/线程池/线程池二版)

[ThreadPool](https://github.com/Corner430/study-notes/blob/main/cpp/线程池/ThreadPool/ThreadPool.h)

- [项目介绍](#项目介绍)
- [知识背景](#知识背景)
- [并发和并行](#并发和并行)
- [多线程的优势](#多线程的优势)
- [线程池](#线程池)
- [线程池模式](#线程池模式)
- [线程同步](#线程同步)
- [项目设计](#项目设计)
- [线程携带返回值](#线程携带返回值)
  - [方法一](#方法一)
  - [方法二](#方法二)
  - [方法三](#方法三)

## 项目介绍

作为五大池之一(内存池、连接池、线程池、进程池、协程池)，线程池的应用非常广泛。不管是客户端程序，还是后台服务程序，线程池都是提高业务处理能力的必备模块。虽然有很多开源的线程池实现，且各自接口略有不同，但其核心实现原理基本相同。

## 知识背景

- 熟练掌握基于 C++ 11 标准的面向对象编程，包括组合和继承、继承多态、STL 容器、智能指针、函数对象、绑定器、可变参模板编程等。
- 熟悉 C++11 多线程编程，涵盖`thread`、`mutex`、`atomic`、`condition_variable`、`unique_lock`等内容。
- 了解 C++17 和 C++20 标准的内容，C++17 的`any`类型和 C++20 的信号量`semaphore`在项目中通过代码实现。
- 熟悉多线程理论，包括多线程基本知识、线程互斥、线程同步、原子操作、CAS 等。

## 并发和并行

- **并发 (Concurrent)**
  - 在单核 CPU 上，多个线程占用不同的 CPU 时间片，物理上仍是串行执行的，但由于每个线程占用的 CPU 时间片非常短（例如 10ms），看起来就像是多个线程同时执行一样，这样的场景称作并发。
- **并行 (Parallel)**
  - 在多核或多 CPU 上，多个线程真正同时执行，这样的场景称作并行。

## 多线程的优势

多线程程序不一定总是最优选择，需要根据具体的应用场景来判断：

- **IO 密集型**
  - 无论是单核、多核 CPU，还是多 CPU，都适合多线程程序。
- **CPU 密集型**
  - **单核 CPU**：多线程存在上下文切换，是额外的开销，线程越多上下文切换所花费的时间也越多，不如一个线程一直进行计算。
  - **多核或多 CPU**：多个线程可以并行执行，提升 CPU 利用率。

## 线程池

- **线程的消耗**

  - 创建和销毁大量线程是非常“重”的操作，线程栈本身占用大量内存，线程的上下文切换耗时且占用资源，大量线程同时唤醒可能导致系统负载锯齿状波动或瞬时负载过大导致宕机。

- **线程池的优势**
  - 线程池在服务进程启动之初就预先创建好线程池中的线程，当业务流量到来时直接从线程池中获取空闲线程执行任务，任务完成后将线程归还到线程池继续提供服务，避免了实时创建和销毁线程的开销，提高系统实时性能和业务处理能力。

## 线程池模式

- **Fixed 模式线程池**

  - 线程池中的线程个数是固定的，一般在创建 `ThreadPool` 时根据当前机器的 CPU 核心数量指定。

- **Cached 模式线程池**
  - 线程池中的线程个数是动态可增长的，根据任务数量动态增加线程，但设置了线程数量阈值。任务处理完成后，如果动态增长的线程在 60 秒内没有处理其它任务，则关闭线程，保持池中最初数量的线程。

## 线程同步

- **线程互斥**

  - 互斥锁 `mutex`
  - 原子类型 `atomic`

- **线程通信**
  - 条件变量 `condition_variable`
  - 信号量 `semaphore`

## 项目设计

![20240619093515](https://cdn.jsdelivr.net/gh/Corner430/Picture/images/20240619093515.png)

- **项目输出**

  - 高并发网络服务器
  - Master-Slave 线程模型
  - 耗时任务处理

- **项目名称**

  - **基于可变参模板实现的线程池**

- **项目描述**

  1. 基于可变参模板编程和引用折叠原理，实现线程池`submitTask`接口，支持任意任务函数和任意参数传递。
  2. 使用`future`类型定制`submitTask`提交任务的返回值。
  3. 使用`map`和`queue`容器管理线程对象和任务。
  4. 基于条件变量`condition_variable`和互斥锁`mutex`实现任务提交线程和任务执行线程间的通信机制。
  5. 支持 `fixed` 和 `cached` 模式的线程池定制。

- **项目问题**

  1. 在`ThreadPool`的资源回收阶段，等待所有线程退出时，发生死锁问题导致进程无法退出。
  2. 在线程池在 Windows 平台运行良好，但在 Linux 平台运行时发生死锁，运行结果有差异。

- **分析定位问题**
  - 使用 gdb 附加到正在运行的进程，通过`info threads`、`thread tid`、`bt`等命令查看各线程的调用堆栈信息，结合项目代码定位发生死锁的代码片段，分析死锁问题发生的原因，并最终提供解决方案。

## 线程携带返回值

线程的返回值是个麻烦事，因为不太确定返回值的类型。解决方案有：

1. 通过 `pthread_exit` 退出线程，线程的返回值是 `void*` 类型。之后通过 `pthread_join` 获取线程的返回值。
2. 使用 `packaged_task` 包装线程函数，通过 `get_future` 获取 `future` 对象，通过 `future` 对象获取线程的返回值。
3. 使用 `async` 函数启动异步任务，通过 `future` 对象获取异步任务的返回值。

> C++ 之所以可以通过 `future` 接住所有类型的返回值，是因为 C++11 标准库中引入了 `std::result_of` 类模板，它可以获取函数对象的返回值类型。

```cpp
#include <iostream>
#include <thread>

int add(int a, int b) {
  std::cout << "call add()" << std::endl;
  return a + b;
}

int main() {
  std::thread(add, 10, 20).join(); // 拿不到返回值
  return 0;
}
```

### 方法一

```cpp
#include <functional>
#include <future>
#include <iostream>
#include <thread>

void *f(void *x) {
  std::cout << "f() called " << std::this_thread::get_id() << std::endl;
  *(int *)(x) += 1;
  pthread_exit(x);
}

int main() {
  pthread_t t_store;
  int x = 0;
  pthread_create(&t_store, NULL, f, (void *)&x);

  void *res = 0;
  pthread_join(t_store, &res);

  std::cout << "res = " << *(int *)res << std::endl;

  return 0;
}
```

### 方法二

```cpp
#include <future>
#include <iostream>
#include <thread>

int add(int a, int b) {
  // std::this_thread::sleep_for(std::chrono::seconds(10));
  return a + b;
}

int main() {
  std::packaged_task<int(int, int)> task(add);
  std::future<int> res = task.get_future();
  std::thread(std::move(task), 2, 10).join();
  std::cout << res.get() << std::endl;

  return 0;
}
```

### 方法三

```cpp
#include <future>
#include <iostream>
#include <mutex>
#include <numeric>
#include <string>
#include <thread>
#include <vector>

std::mutex m;

void foo(int i, const std::string &str) {
  std::lock_guard<std::mutex> lk(m);
  std::cout << str << ' ' << i << std::endl;
}

void bar(const std::string &str) {
  std::lock_guard<std::mutex> lk(m);
  std::cout << str << std::endl;
}

int add(int a, int b) {
  std::lock_guard<std::mutex> lk(m);
  std::cout << "add() called" << std::endl;
  return a + b;
}

template <typename RandomIt> int parallel_sum(RandomIt beg, RandomIt end) {
  auto len = end - beg;
  if (len < 1000) {
    return std::accumulate(beg, end, 0);
  }
  RandomIt mid = beg + len / 2;
  auto handle =
      std::async(std::launch::async, parallel_sum<RandomIt>, mid, end);
  int sum = parallel_sum(beg, mid);
  return sum + handle.get();
}

int main() {
  std::vector<int> v(10000, 1);
  std::cout << parallel_sum(v.begin(), v.end()) << std::endl;

  // 以默认策略启动异步任务，可能同时打印 "Hello 42" 或 延迟执行
  auto a1 = std::async(foo, 42, "Hello");

  // 以 deferred 策略调用 bar("world!")
  // 调用 a2.get() 或 a2.wait() 时打印 "world!"
  auto a2 = std::async(std::launch::deferred, bar, "world!");

  // 以 async 策略调用 add(10, 20)
  // 同时打印 "add() called"
  auto a3 = std::async(std::launch::async, add, 10, 20);

  a2.wait();                          // 打印 "world!"
  std::cout << a3.get() << std::endl; // 30

  return 0;
} // 若 a1 在此点未完成，则 a1 的析构函数在此打印 "Hello 42"
```
