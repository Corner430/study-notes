- [1 数组](#1-数组)
  - [704. 二分查找](#704-二分查找)
  - [35. 搜索插入位置](#35-搜索插入位置)
  - [34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)
  - [69. x 的平方根](#69-x-的平方根)
  - [367. 有效的完全平方数](#367-有效的完全平方数)
  - [27. 移除元素](#27-移除元素)
  - [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项)
  - [283. 移动零](#283-移动零)
  - [844. 比较含退格的字符串](#844-比较含退格的字符串)
  - [977. 有序数组的平方](#977-有序数组的平方)
  - [209. 长度最小的子数组](#209-长度最小的子数组)
  - [904. 水果成篮](#904-水果成篮)
  - [76. 最小覆盖子串](#76-最小覆盖子串)
  - [59. 螺旋矩阵 II](#59-螺旋矩阵-ii)
  - [54. 螺旋矩阵](#54-螺旋矩阵)
  - [剑指Offer 29. 顺时针打印矩阵](#剑指offer-29-顺时针打印矩阵)
  - [167. 两数之和 II - 输入有序数组](#167-两数之和-ii---输入有序数组)
  - [344. 反转字符串](#344-反转字符串)
  - [5. 最长回文子串](#5-最长回文子串)
- [2 链表](#2-链表)
  - [83. 删除排序链表中的重复元素](#83-删除排序链表中的重复元素)
  - [203.移除链表元素](#203移除链表元素)
  - [707. 设计链表](#707-设计链表)
  - [206.反转链表](#206反转链表)
  - [92. 反转链表 II](#92-反转链表-ii)
  - [25. K 个一组翻转链表](#25-k-个一组翻转链表)
  - [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
  - [19.删除链表的倒数第N个节点](#19删除链表的倒数第n个节点)
  - [面试题 02.07. 链表相交](#面试题-0207-链表相交)
  - [141. 环形链表](#141-环形链表)
  - [142.环形链表II](#142环形链表ii)
  - [21. 合并两个有序链表](#21-合并两个有序链表)
  - [23. 合并 K 个升序链表](#23-合并-k-个升序链表)
  - [86. 分隔链表](#86-分隔链表)
  - [876. 链表的中间结点](#876-链表的中间结点)
  - [234. 回文链表](#234-回文链表)
- [3 哈希表](#3-哈希表)
  - [242.有效的字母异位词](#242有效的字母异位词)
  - [383. 赎金信](#383-赎金信)
  - [49. 字母异位词分组](#49-字母异位词分组)
  - [438. 找到字符串中所有字母异位词](#438-找到字符串中所有字母异位词)
  - [349. 两个数组的交集](#349-两个数组的交集)
  - [350. 两个数组的交集 II](#350-两个数组的交集-ii)
  - [202. 快乐数](#202-快乐数)
  - [1. 两数之和](#1-两数之和)
  - [454. 四数相加II](#454-四数相加ii)
  - [15. 三数之和](#15-三数之和)
  - [18. 四数之和](#18-四数之和)
- [4 字符串](#4-字符串)
  - [344. 反转字符串](#344-反转字符串-1)
  - [541. 反转字符串II](#541-反转字符串ii)
  - [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试)
  - [151. 翻转字符串里的单词](#151-翻转字符串里的单词)
  - [55. 右旋字符串（第八期模拟笔试）](#55-右旋字符串第八期模拟笔试)
  - [28. 找出字符串中第一个匹配项的下标](#28-找出字符串中第一个匹配项的下标)
    - [KMP](#kmp)
  - [459.重复的子字符串](#459重复的子字符串)
- [5 双指针](#5-双指针)
  - [27. 移除元素](#27-移除元素-1)
  - [344. ](#344-)
- [1 数组](#1-数组-1)
  - [704. 二分查找](#704-二分查找-1)
  - [35. 搜索插入位置](#35-搜索插入位置-1)
  - [34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置-1)
  - [69. x 的平方根](#69-x-的平方根-1)
  - [367. 有效的完全平方数](#367-有效的完全平方数-1)
  - [27. 移除元素](#27-移除元素-2)
  - [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项-1)
  - [283. 移动零](#283-移动零-1)
  - [844. 比较含退格的字符串](#844-比较含退格的字符串-1)
  - [977. 有序数组的平方](#977-有序数组的平方-1)
  - [209. 长度最小的子数组](#209-长度最小的子数组-1)
  - [904. 水果成篮](#904-水果成篮-1)
  - [76. 最小覆盖子串](#76-最小覆盖子串-1)
  - [59. 螺旋矩阵 II](#59-螺旋矩阵-ii-1)
  - [54. 螺旋矩阵](#54-螺旋矩阵-1)
  - [剑指Offer 29. 顺时针打印矩阵](#剑指offer-29-顺时针打印矩阵-1)
  - [167. 两数之和 II - 输入有序数组](#167-两数之和-ii---输入有序数组-1)
  - [344. 反转字符串](#344-反转字符串-2)
  - [5. 最长回文子串](#5-最长回文子串-1)
- [2 链表](#2-链表-1)
  - [83. 删除排序链表中的重复元素](#83-删除排序链表中的重复元素-1)
  - [203.移除链表元素](#203移除链表元素-1)
  - [707. 设计链表](#707-设计链表-1)
  - [206.反转链表](#206反转链表-1)
  - [92. 反转链表 II](#92-反转链表-ii-1)
  - [25. K 个一组翻转链表](#25-k-个一组翻转链表-1)
  - [24. 两两交换链表中的节点](#24-两两交换链表中的节点-1)
  - [19.删除链表的倒数第N个节点](#19删除链表的倒数第n个节点-1)
  - [面试题 02.07. 链表相交](#面试题-0207-链表相交-1)
  - [141. 环形链表](#141-环形链表-1)
  - [142.环形链表II](#142环形链表ii-1)
  - [21. 合并两个有序链表](#21-合并两个有序链表-1)
  - [23. 合并 K 个升序链表](#23-合并-k-个升序链表-1)
  - [86. 分隔链表](#86-分隔链表-1)
  - [876. 链表的中间结点](#876-链表的中间结点-1)
  - [234. 回文链表](#234-回文链表-1)
- [3 哈希表](#3-哈希表-1)
  - [242.有效的字母异位词](#242有效的字母异位词-1)
  - [383. 赎金信](#383-赎金信-1)
  - [49. 字母异位词分组](#49-字母异位词分组-1)
  - [438. 找到字符串中所有字母异位词](#438-找到字符串中所有字母异位词-1)
  - [349. 两个数组的交集](#349-两个数组的交集-1)
  - [350. 两个数组的交集 II](#350-两个数组的交集-ii-1)
  - [202. 快乐数](#202-快乐数-1)
  - [1. 两数之和](#1-两数之和-1)
  - [454. 四数相加II](#454-四数相加ii-1)
  - [15. 三数之和](#15-三数之和-1)
  - [18. 四数之和](#18-四数之和-1)
- [4 字符串](#4-字符串-1)
  - [344. 反转字符串](#344-反转字符串-3)
  - [541. 反转字符串II](#541-反转字符串ii-1)
  - [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试-1)
  - [151. 翻转字符串里的单词](#151-翻转字符串里的单词-1)
  - [55. 右旋字符串（第八期模拟笔试）](#55-右旋字符串第八期模拟笔试-1)
  - [28. 找出字符串中第一个匹配项的下标](#28-找出字符串中第一个匹配项的下标-1)
    - [KMP](#kmp-1)
  - [459.重复的子字符串](#459重复的子字符串-1)
- [5 双指针](#5-双指针-1)
  - [27. 移除元素](#27-移除元素-3)
  - [344. 反转字符串](#344-反转字符串-4)
  - [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试-2)
  - [151. 翻转字符串里的单词](#151-翻转字符串里的单词-2)
  - [206.反转链表](#206反转链表-2)
  - [19.删除链表的倒数第N个节点](#19删除链表的倒数第n个节点-2)
  - [面试题 02.07. 链表相交](#面试题-0207-链表相交-2)
  - [142.环形链表II](#142环形链表ii-2)
  - [15. 三数之和](#15-三数之和-2)
  - [18. 四数之和](#18-四数之和-2)
- [6 栈与队列](#6-栈与队列)
  - [232. 用栈实现队列](#232-用栈实现队列)
  - [225. 用队列实现栈](#225-用队列实现栈)
  - [20. 有效的括号](#20-有效的括号)
  - [1047. 删除字符串中的所有相邻重复项](#1047-删除字符串中的所有相邻重复项)
  - [150. 逆波兰表达式求值](#150-逆波兰表达式求值)
  - [239. 滑动窗口最大值](#239-滑动窗口最大值)
  - [347.前 K 个高频元素](#347前-k-个高频元素)
- [7 二叉树](#7-二叉树)
  - [144. 二叉树的前序遍历](#144-二叉树的前序遍历)
  - [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
  - [145. 二叉树的后序遍历](#145-二叉树的后序遍历)
  - [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
  - [107. 二叉树的层序遍历 II](#107-二叉树的层序遍历-ii)
  - [199. 二叉树的右视图](#199-二叉树的右视图)
  - [637. 二叉树的层平均值](#637-二叉树的层平均值)
  - [429. N叉树的层序遍历](#429-n叉树的层序遍历)
  - [515. 在每个树行中找最大值](#515-在每个树行中找最大值)
  - [116. 填充每个节点的下一个右侧节点指针](#116-填充每个节点的下一个右侧节点指针)
  - [117. 填充每个节点的下一个右侧节点指针 II](#117-填充每个节点的下一个右侧节点指针-ii)
  - [104. 二叉树的最大深度](#104-二叉树的最大深度)
  - [111. 二叉树的最小深度](#111-二叉树的最小深度)
  - [226. 翻转二叉树](#226-翻转二叉树)
  - [1553. 吃掉 N 个橘子的最少天数](#1553-吃掉-n-个橘子的最少天数)


## 1 数组

### 704. 二分查找

[704. 二分查找](https://leetcode.cn/problems/binary-search/description/)

***python***
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1  # []
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

***cpp***
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // []
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return -1;
    }
};
```

***js***
```js
var search = function (nums, target) {
    let l = 0, r = nums.length - 1; // []
    while (l <= r) {
        let mid = (r + l) >> 1;
        if (nums[mid] === target) return mid;
        else if (nums[mid] < target)
            l = mid + 1;
        else r = mid - 1;
    }
    return -1;
};
```

### 35. 搜索插入位置

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

***python***
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid - 1
            else :
                left = mid + 1
        return left
```

***cpp***
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // []
        while(left <= right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] > target)
                right = mid - 1;
            else 
                left = mid + 1;
        }
        return left;
    }
};
```

***js***
```js
var searchInsert = function (nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] === target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1;
        else right = mid - 1;
    }
    return left;
};
```

### 34. 在排序数组中查找元素的第一个和最后一个位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

***python***
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1  # []

        def getLeftBound(nums, target):
            nonlocal left, right
            while left <= right:
                mid = left + (right - left) // 2
                if nums[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left < len(nums) and nums[left] == target:
                return left
            return -1

        def getRightBound(nums, target):
            nonlocal left, right
            right = len(nums) - 1
            while left <= right:
                mid = left + (right - left) // 2
                if nums[mid] <= target:
                    left = mid + 1
                else:
                    right = mid - 1
            return right

        leftBound = getLeftBound(nums, target)
        if leftBound == -1:
            return [-1, -1]
        return [leftBound, getRightBound(nums, target)]
```

***cpp***
```cpp
class Solution {
public:
    int left = 0, right;
    int findLeftBound(const vector<int>& nums, const int& target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target)
                right = mid - 1;
            else
                left = mid + 1;
        }
        if (left < nums.size() && nums[left] == target)
            return left;
        return -1;
    }

    int findRightBound(const vector<int>& nums, const int& target) {
        right = nums.size() - 1; // []
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        right = nums.size() - 1; // []
        int leftBound = findLeftBound(nums, target);
        if (leftBound == -1)
            return {-1, -1};
        return {leftBound, findRightBound(nums, target)};
    }
};
```

***js***
```js
var searchLeftBound = function (nums, target) {
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] >= target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    if (left < nums.length && nums[left] === target)
        return left;
    return -1;
};

var searchRightBound = function (nums, target) {
    right = nums.length - 1;
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] <= target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return right;
};

var searchRange = function (nums, target) {
    left = 0;
    right = nums.length - 1;
    let leftBound = searchLeftBound(nums, target);
    if (leftBound === -1) return [-1, -1];
    return [leftBound, searchRightBound(nums, target)];
};
```


### 69. x 的平方根

[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/description/)

***python***
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return x
        left, right = 1, x
        while left <= right:
            mid = left + (right - left) // 2
            if x // mid == mid:
                return mid
            elif x // mid > mid:
                left = mid + 1
            else :
                right = mid - 1
        return right
```

***cpp***
```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0)
            return 0;
        int left = 1, right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (x / mid == mid) // 防止数值溢出
                return mid;
            else if (x / mid > mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }
};
```

***js***
```js
var mySqrt = function (x) {
    if (x === 0) return x;
    let left = 1, right = x;
    while (left <= right) {
        let mid = left + ((right - left) >> 1);
        if (mid === Math.floor(x / mid))
            return mid;
        else if (mid < Math.floor(x / mid))
            left = mid + 1;
        else
            right = mid - 1;
    }
    return right;
};
```

### 367. 有效的完全平方数

[367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/description/)

***python***
```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 1, num
        while left <= right:
            mid = left + (right - left) // 2
            if mid * mid == num:
                return True
            elif mid * mid < num:
                left = mid + 1
            else:
                right = mid - 1
        return False
```

***cpp***
```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 1, right = num;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if ((long)mid * mid == num)
                return true;
            else if ((long)mid * mid < num)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return false;
    }
};
```

***js***
```js
var isPerfectSquare = function (num) {
    let left = 1, right = num;
    while (left <= right) {
        let mid = left + ((right - left) >> 1);
        if (mid * mid == num)
            return true;
        else if (mid * mid < num)
            left = mid + 1;
        else right = mid - 1;
    }
    return false;
};
```

### 27. 移除元素

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/description/)

***python***
```python
class Solution(object):
    def removeElement(self, nums, val):
        left, right  = 0, len(nums) - 1
        while left <= right:
            while left <= right and nums[left] != val:
                left += 1
            while left <= right and nums[right] == val:
                right -= 1
            if left <= right:
                nums[left] = nums[right]
                left += 1
                right -= 1
        return left
```

***cpp***
```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size() - 1; // []
        while (left <= right) {
            while (left <= right && nums[left] != val)
                left++;
            while (left <= right && nums[right] == val)
                right--;
            if (left <= right)
                nums[left++] = nums[right--];
        }
        return left;
    }
};
```

***js***
```js
var removeElement = function(nums, val) {
    let slow = 0, fast = 0;
    for(; fast < nums.length; fast++)
        if (nums[fast] != val)
            nums[slow++] = nums[fast];
    return slow;
};
```

### 26. 删除排序数组中的重复项

[26. 删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

***python***

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 0
        while fast < len(nums):
            if fast < len(nums) - 1 and nums[fast] == nums[fast + 1]:
                fast += 1
                continue
            else:
                nums[slow] = nums[fast]
                slow += 1
                fast += 1
        return slow
```

***cpp***

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 0, fast = 0;
        while (fast < nums.size()) {
            if (fast < nums.size() - 1 && nums[fast] == nums[fast + 1]){
                fast++;
                continue;
            }
            else
                nums[slow++] = nums[fast];
            fast++;
        }
        return slow;
    }
};
```

***js***
```js
var removeDuplicates = function(nums) {
    let slow = 1, fast = 0;
    while (fast < nums.length){
        if (fast > 0 && nums[fast] != nums[fast - 1])
            nums[slow++] = nums[fast];
        fast++;
    }
    return slow;
};
```

### 283. 移动零

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/description/)

***python***

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow, fast = 0, 0
        while fast < len(nums):
            if nums[fast]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        while slow < len(nums):
            nums[slow] = 0
            slow += 1
```

***cpp***

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0, fast = 0;
        for(; fast < nums.size(); fast++)
            if(nums[fast])
                nums[slow++] = nums[fast];

        while(slow < nums.size())
            nums[slow++] = 0;
    }
};
```

***js***
```js
var moveZeroes = function (nums) {
    let slow = 0, fast = 0;
    for (; fast < nums.length; fast++)
        if (nums[fast] != 0)
            nums[slow++] = nums[fast];

    while (slow < nums.length)
        nums[slow++] = 0;
};
```

### 844. 比较含退格的字符串

[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/description/)

***python***

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def modify(S):
            stack = []
            for char in S:
                if char != '#':
                    stack.append(char)
                elif stack:
                    stack.pop()
            return ''.join(stack)

        return modify(s) == modify(t)


# ----------------------------
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        return self.modifyString(s) == self.modifyString(t)
    
    def modifyString(self, s: str) -> str:
        slow, fast = 0, 0
        s_list = list(s)
        while fast < len(s_list):
            if s_list[fast] != '#':
                s_list[slow] = s_list[fast]
                slow += 1
            elif slow > 0:
                slow -= 1

            fast += 1
        return ''.join(s_list[:slow])
```

***cpp***

```cpp
class Solution
{
public:
    bool backspaceCompare(string s, string t)
    {
        modifyString(s);
        modifyString(t);
        return s == t;
    }

private:
    void modifyString(string &s)
    {
        int slow = 0, fast = 0;
        for (; fast < s.length(); ++fast)
            if (s[fast] == '#' && slow > 0)
                --slow;
            else if (s[fast] != '#')
                s[slow++] = s[fast];
        s.resize(slow);
    }
};
```

***js***
```js
var backspaceCompare = function (s, t) {
    modify = function (s) {
        let slow = 0, sArr = s.split('');
        for (let fast = 0; fast < sArr.length; fast++) {
            if (sArr[fast] != '#')
                sArr[slow++] = sArr[fast];
            else if (slow > 0)
                slow--;
        }
        sArr.length = slow;
        return sArr.join('');
    }
    s = modify(s);
    t = modify(t);
    return s == t;
};
```

### 977. 有序数组的平方

[977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/description/)

***python***

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        res = [0] * len(nums)
        nums = [num * num for num in nums]
        i, j, k = 0, len(nums) - 1, len(nums) - 1
        while k >= 0:
            if nums[i] >= nums[j]:
                res[k] = nums[i]
                i += 1
            else:
                res[k] = nums[j]
                j -= 1
            k -= 1
        return res
```

***cpp***

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for (int& num : nums)
            num = num * num;

        vector<int> res(nums.size());
        for (int i = 0, j = nums.size() - 1, k = j; k >= 0; --k)
            nums[i] >= nums[j] ? res[k] = nums[i++] : res[k] = nums[j--];

        return res;
    }
};
```

***js***

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function (nums) {
    // 将 nums 数组中的每个元素取平方，并生成一个新的数组
    nums = nums.map(num => num * num)
    let res = new Array(nums.length);
    let i = 0, j = nums.length - 1, k = nums.length - 1;
    while (k >= 0) {
        if (nums[i] >= nums[j]) {
            res[k] = nums[i];
            i++;
        } else {
            res[k] = nums[j];
            j--;
        }
        k--;
    }
    return res;
};
```

### 209. 长度最小的子数组

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/)

***python***

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left, right = 0, 0  # [)
        sum = 0
        res = len(nums) + 1
        while right < len(nums):
            while right < len(nums) and sum < target:
                sum += nums[right]
                right += 1
            while sum >= target:
                res = min(res, right - left)
                sum -= nums[left]
                left += 1
        return 0 if res == len(nums) + 1 else res
```

***cpp***

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT32_MAX;
        int sum = 0;
        for (size_t i = 0, j = 0; i < nums.size(); ++i) {
            sum += nums[i];
            while (sum >= target) {
                int subLength = i - j + 1;
                res = res < subLength ? res : subLength;
                sum -= nums[j++];
            }
        }
        return res == INT32_MAX ? 0 : res;
    }
};
```

***js***

```js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
    let left = 0, right = 0;    // [)
    let sum = 0;
    let res = nums.length + 1;
    while (right < nums.length) {
        sum += nums[right];
        right++;
        while (sum >= target) {
            res = Math.min(res, right - left);  // 注意是Math.min()
            sum -= nums[left++];
        }
    }
    return res === nums.length + 1 ? 0 : res;
};
```

### 904. 水果成篮

[904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/description/)

***python***

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        fruit_map = {}
        left, right = 0, 0
        temp_res, res = 0, 0
        for fruit in fruits:
            if fruit in fruit_map:
                fruit_map[fruit] += 1
            else:
                fruit_map[fruit] = 1
            
            if len(fruit_map) <= 2:
                temp_res += 1
                res = max(res, temp_res)
            else:
                while len(fruit_map) > 2:
                    fruit_map[fruits[left]] -= 1
                    if fruit_map[fruits[left]] == 0:
                        del fruit_map[fruits[left]]
                    left += 1
                temp_res = right - left + 1
            right += 1
        return res
```

***cpp***

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> umap;
        int res = 0, temp_res = 0;
        int left = 0, right = 0;
        while (right < fruits.size()) {
            ++umap[fruits[right]]; // 加入元素
            right++;

            if (umap.size() <= 2) { // 收获结果
                temp_res += 1;
                res = max(res, temp_res);
            } else {    // 收缩窗口
                while (umap.size() > 2) {
                    --umap[fruits[left]];
                    if (umap[fruits[left]] == 0)
                        umap.erase(fruits[left]);
                    ++left;
                }
                temp_res = right - left;
            }
        }
        return res;
    }
};
```

***js***

```js
/**
 * @param {number[]} fruits
 * @return {number}
 */
var totalFruit = function (fruits) {
    const fruitMap = new Map();
    let res = 0, tempRes = 0;
    let slow = 0, fast = 0;
    for (const fruit of fruits) {
        fruitMap.set(fruit, (fruitMap.get(fruit) || 0) + 1);

        if (fruitMap.size <= 2) {
            tempRes += 1;
            res = Math.max(res, tempRes);
        } else {
            while (fruitMap.size > 2) {
                fruitMap.set(fruits[slow], fruitMap.get(fruits[slow]) - 1);
                if (fruitMap.get(fruits[slow]) === 0) {
                    fruitMap.delete(fruits[slow]);
                }
                slow += 1;
            }
            tempRes = fast - slow + 1;
        }
        fast += 1;
    }
    return res;
};
```

### 76. 最小覆盖子串

[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/description/)

***python***

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = {}
        for c in t:
            if c in need:
                need[c] += 1
            else:
                need[c] = 1
        left, right, start_index = 0, 0, 0
        length = 100001
        invalid = len(need)

        while right < len(s):
            # 扩大窗口
            if s[right] in need:
                need[s[right]] -= 1
                if need[s[right]] == 0:
                    invalid -= 1
            right += 1

            while invalid == 0:
                # 缩小窗口
                if s[left] in need:
                    need[s[left]] += 1
                    if need[s[left]] > 0:
                        invalid += 1
                        if right - left < length: # 收获结果
                            start_index = left
                            length = right - left
                left += 1
        return "" if length == 100001 else s[start_index:start_index + length]
        
```

***cpp***

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> umap;
        for (char c : t)
            umap[c]++;
        int left = 0, right = 0; // [)
        int invalid = umap.size();
        int start_index = 0, length = 100001;
        while (right < s.size()) {
            // 扩大窗口
            auto it = umap.find(s[right++]);
            if (it != umap.end()) {
                --it->second;
                if (it->second == 0)
                    invalid--;
            }

            // 收缩窗口
            while (invalid == 0) {
                auto it = umap.find(s[left]);
                if (it != umap.end()) {
                    ++it->second;
                    if (it->second > 0) {
                        invalid++;
                        if (right - left < length) { // 收获结果
                            start_index = left;
                            length = right - left;
                        }
                    }
                }
                ++left;
            }
        }
        return length == 100001 ? "" : s.substr(start_index, length);
    }
};
```

***js***

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
    let umap = new Map();
    for (let c of t) {
        umap.set(c, (umap.get(c) || 0) + 1);
    }
    let left = 0, right = 0;
    let invalid = umap.size;
    let start_index = 0, length = 100001;

    while (right < s.length) {
        // 扩大窗口
        let char = s[right++];
        if (umap.has(char)) {
            umap.set(char, umap.get(char) - 1);
            if (umap.get(char) === 0) {
                invalid--;
            }
        }

        // 收缩窗口
        while (invalid === 0) {
            let charLeft = s[left];
            if (umap.has(charLeft)) {
                umap.set(charLeft, umap.get(charLeft) + 1);
                if (umap.get(charLeft) > 0) {
                    invalid++;
                    if (right - left < length) { // 收获结果
                        start_index = left;
                        length = right - left;
                    }
                }
            }
            left++;
        }
    }
    return length === 100001 ? "" : s.substr(start_index, length);
};
```

### 59. 螺旋矩阵 II

[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/description/)

***python***

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0] * n for _ in range(n)] # 二维数组
        left_bound, right_bound = 0, n - 1
        up_bound, down_bound = 0, n - 1
        count = 1

        while count <= n * n:
            # 上边
            for j in range(left_bound, right_bound + 1):
                res[up_bound][j] = count
                count += 1
            up_bound += 1

            # 右边
            for i in range(up_bound, down_bound + 1):
                res[i][right_bound] = count
                count += 1
            right_bound -= 1

            # 下边
            for j in range(right_bound, left_bound - 1, - 1):
                res[down_bound][j] = count
                count += 1
            down_bound -= 1

            # 左边
            for i in range(down_bound, up_bound - 1, -1):
                res[i][left_bound] = count
                count += 1
            left_bound += 1

        return res
```

***cpp***

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n));
        int leftBound = 0, rightBound = n - 1;
        int upBound = 0, downBound = n - 1;
        int count = 1;
        while (count <= n * n) {
            // 上边
            for (int j = leftBound; j <= rightBound; ++j)
                res[upBound][j] = count++;
            upBound++;

            // 右边
            for (int i = upBound; i <= downBound; ++i)
                res[i][rightBound] = count++;
            rightBound--;

            // 下边
            for (int j = rightBound; j >= leftBound; --j)
                res[downBound][j] = count++;
            downBound--;

            // 左边
            for (int i = downBound; i >= upBound; --i)
                res[i][leftBound] = count++;
            leftBound++;
        }
        return res;
    }
};
```

***js***

```js
/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function (n) {
    let res = new Array(n).fill().map(() => new Array(n).fill(0));
    let leftBound = 0, rightBound = n - 1;
    let upBound = 0, downBound = n - 1;
    let count = 1;

    while (count <= n * n) {
        // 上边
        for (let j = leftBound; j <= rightBound; j++)
            res[upBound][j] = count++;
        upBound++;

        // 右边
        for (let i = upBound; i <= downBound; i++)
            res[i][rightBound] = count++;
        rightBound--;

        // 下边
        for (let j = rightBound; j >= leftBound; j--)
            res[downBound][j] = count++;
        downBound--;

        // 左边
        for (let i = downBound; i >= upBound; i--)
            res[i][leftBound] = count++;
        leftBound++;
    }
    return res;
};
```

### 54. 螺旋矩阵

[54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/description/)

***python***

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        m, n = len(matrix), len(matrix[0])
        up_bound, down_bound = 0, m - 1
        left_bound, right_bound = 0, n - 1

        while up_bound <= down_bound and left_bound <= right_bound:
            # 上边
            for j in range(left_bound, right_bound + 1):
                res.append(matrix[up_bound][j])
            up_bound += 1
            if up_bound > down_bound:
                break
            
            # 右边
            for i in range(up_bound, down_bound + 1):
                res.append(matrix[i][right_bound])
            right_bound -= 1
            if left_bound > right_bound:
                break
            
            # 下边
            for j in range(right_bound, left_bound - 1, -1):
                res.append(matrix[down_bound][j])
            down_bound -= 1

            # 左边
            for i in range(down_bound, up_bound - 1, -1):
                res.append(matrix[i][left_bound])
            left_bound += 1
        return res
            
```

***cpp***

```cpp
class Solution {
  public:
  vector<int> spiralOrder(vector<vector<int>>& matrix) {
    vector<int> res;
    int m = matrix.size(), n = matrix[0].size();  // 行 列
    int up_bound = 0, down_bound = m - 1;
    int left_bound = 0, right_bound = n - 1;
    while (up_bound <= down_bound && left_bound <= right_bound)
    {
      // 上
      for (int j = left_bound; j <= right_bound; j++)
        res.push_back(matrix[up_bound][j]);
      up_bound++;
      if (up_bound > down_bound) break;

      // 右
      for (int i = up_bound; i <= down_bound; i++)
        res.push_back(matrix[i][right_bound]);
      right_bound--;
      if (left_bound > right_bound) break;

      // 下
      for (int j = right_bound; j >= left_bound; j--)
        res.push_back(matrix[down_bound][j]);
      down_bound--;

      // 左
      for (int i = down_bound; i >= up_bound; i--)
        res.push_back(matrix[i][left_bound]);
      left_bound++;
    }
    return res;
  }
};
```

***js***

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function (matrix) {
    let res = [];
    let m = matrix.length, n = matrix[0].length;
    let upBound = 0, downBound = m - 1;
    let leftBound = 0, rightBound = n - 1;

    while (upBound <= downBound && leftBound <= rightBound) {
        // 上
        for (let j = leftBound; j <= rightBound; j++) {
            res.push(matrix[upBound][j]);
        }
        upBound++;
        if (upBound > downBound) break;

        // 右
        for (let i = upBound; i <= downBound; i++) {
            res.push(matrix[i][rightBound]);
        }
        rightBound--;
        if (leftBound > rightBound) break;

        // 下
        for (let j = rightBound; j >= leftBound; j--) {
            res.push(matrix[downBound][j]);
        }
        downBound--;

        // 左
        for (let i = downBound; i >= upBound; i--) {
            res.push(matrix[i][leftBound]);
        }
        leftBound++;
    }
    return res;
};
```

### 剑指Offer 29. 顺时针打印矩阵

[剑指Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/)

同 [54. 螺旋矩阵](#54-螺旋矩阵)

### 167. 两数之和 II - 输入有序数组

[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/)

***python***

```python
# 左右指针
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers) - 1
        while left < right:
            sum = numbers[left] + numbers[right]
            if sum == target:
                return [left + 1, right + 1]
            elif sum < target:
                left += 1
            else:
                right -= 1
        return [-1, -1]

# 哈希
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        umap = {}
        for i, num in enumerate(numbers):
            if target - num in umap:
                return [umap[target - num] + 1, i + 1]
            umap[num] = i
```

***cpp***

```cpp
// 左右指针
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(target == sum) return vector<int> {left+1,right+1};
            else if(target < sum) right--;
            else left++;
        }
        return vector<int> {-1,-1};
    }
};

// 哈希
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        unordered_map<int, int> umap;
        for (int i = 0 ; i < numbers.size(); i++){
            auto it = umap.find(target - numbers[i]);
            if(it != umap.end()) return vector<int> {it->second + 1, i + 1};
            umap[numbers[i]] = i;
        }
        return vector<int> {-1, -1};
    }
};
```

***js***

```js
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
// 左右指针
var twoSum = function (numbers, target) {
    let left = 0, right = numbers.length - 1;
    while (left < right) {
        let sum = numbers[left] + numbers[right];
        if (target === sum) {
            return [left + 1, right + 1];
        } else if (target < sum) {
            right--;
        } else {
            left++;
        }
    }
    return [-1, -1];
};

// 哈希
var twoSum = function (numbers, target) {
    let umap = new Map();
    for (let i = 0; i < numbers.length; i++) {
        if (umap.has(target - numbers[i])) {
            return [umap.get(target - numbers[i]) + 1, i + 1];
        }
        umap.set(numbers[i], i);
    }
};
```

### 344. 反转字符串

[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/description/)

***python***

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

***cpp***

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int i = 0, j = s.size() - 1;
        while (i < j)
            swap(s[i++], s[j--]);
    }
};
```

***js***

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function (s) {
    let i = 0, j = s.length - 1;
    while (i < j) {
        [s[i], s[j]] = [s[j], s[i]];
        i++;
        j--;
    }
};
```

### 5. 最长回文子串

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/description/)

***python***

```python
class Solution:
    def extend(self, s: str, i: int, j: int) -> int:
        res = 0
        while i >= 0 and j < len(s) and s[i] == s[j]:
            if i != j:
                res += 2
            else:
                res += 1
            i -= 1
            j += 1
        return res

    def longestPalindrome(self, s: str) -> str:
        length = 1
        start_index = 0
        for i in range(len(s)):
            length1 = self.extend(s, i, i)
            length2 = self.extend(s, i, i + 1)
            length = max(length, length1, length2)
            if length == length1:
                start_index = i - (length1 - 1) // 2
            elif length == length2:
                start_index = i - length2 // 2 + 1
        return s[start_index : start_index + length]
```

***cpp***

```cpp
class Solution {
private:
  int extend(string &s, int i, int j) {
    int res = 0;
    while (i >= 0 && j < s.size() && s[i] == s[j]) {
      if (i != j)
        res += 2;
      else
        res++;
      i--;
      j++;
    }
    return res;
  }

public:
  string longestPalindrome(string s) {
    int length = 1;
    int startIndex = 0;
    for (int i = 0; i < s.size(); i++) {
      int length1 = extend(s, i, i);
      int length2 = extend(s, i, i + 1);
      length = max({length, length1, length2});
      if (length == length1)
        startIndex = i - (length1 - 1) / 2;
      else if (length == length2)
        startIndex = i - length2 / 2 + 1;
    }
    return s.substr(startIndex, length);
  }
};
```

***js***

```js
/**
 * @param {string} s
 * @return {string}
 */

var extend = function (s, i, j) {
    let res = 0;
    while (i >= 0 && j < s.length && s[i] === s[j]) {
        if (i !== j) {
            res += 2;
        } else {
            res += 1;
        }
        i--;
        j++;
    }
    return res;
}

var longestPalindrome = function (s) {
    let length = 1;
    let startIndex = 0;
    for (let i = 0; i < s.length; i++) {
        let length1 = extend(s, i, i);
        let length2 = extend(s, i, i + 1);
        let lengthTemp = Math.max(length, length1, length2);
        if (lengthTemp === length1) {
            startIndex = i - Math.floor((length1 - 1) / 2);
        } else if (lengthTemp === length2) {
            startIndex = i - Math.floor(length2 / 2) + 1;
        }
        length = lengthTemp;
    }
    return s.substring(startIndex, startIndex + length);
};
```

----------------------------

## 2 链表

### 83. 删除排序链表中的重复元素

[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)

***python***

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        p = head
        while p.next:
            if p.next.val == p.val:
                p.next = p.next.next
            else:
                p = p.next
        return head
```

***cpp***

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head)
            return head;
        ListNode* p = head;
        while (p->next) {
            if (p->next->val == p->val) {
                ListNode* del = p->next;
                p->next = del->next;
                delete del;
            }else
                p = p->next;
        }
        return head;
    }
};
```

***js***

```js
var deleteDuplicates = function (head) {
     if (!head || !head.next) 
        return head;

    let p = head;
    while (p.next) {
        if (p.next.val === p.val) {
            p.next = p.next.next;
        } else {
            p = p.next;
        }
    }
    return head;
};
```


### 203.移除链表元素

[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

***python***
```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummyHead = ListNode(0, head);
        p = dummyHead;
        while p.next:
            if p.next.val == val:
                p.next = p.next.next
            else:
                p = p.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next) {
            if (p->next->val == val) {
                ListNode* temp = p->next;
                p->next = temp->next;
                delete temp;
            } else
                p = p->next;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
var removeElements = function (head, val) {
    const dummyHead = new ListNode(0, head);
    let p = dummyHead;
    while (p.next) {
        if (p.next.val === val) {
            const temp = p.next;
            p.next = temp.next;
            temp.next = null; // Optional: Helps in garbage collection
        } else {
            p = p.next;
        }
    }
    return dummyHead.next;
};
```

### 707. 设计链表

[707. 设计链表](https://leetcode.cn/problems/design-linked-list/description/)

***python***
```python
class ListNode:
    def __init__(self, val = 0,next = None):
        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):
        self.head = None
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        p = self.head
        for _ in range(index):
            p = p.next
        return p.val

    def addAtHead(self, val: int) -> None:
        self.head = ListNode(val, self.head)
        self.size += 1

    def addAtTail(self, val: int) -> None:
        p = self.head
        while p.next:
            p = p.next
        p.next = ListNode(val)
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        p = self.head
        for _ in range(index - 1):
            p = p.next
        p.next = ListNode(val, p.next)
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        p = self.head
        for _ in range(index - 1):
            p = p.next
        p.next = p.next.next
        self.size -= 1



# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

***cpp***
```cpp
class MyLinkedList {
private:
    // 定义链表
    struct ListNode {
        int val;
        ListNode* next;
        ListNode() : val(0), next(nullptr) {}
        ListNode(int x) : val(x), next(nullptr) {}
        ListNode(int x, ListNode* next) : val(x), next(next) {}
    };

    ListNode* _dummyHead;
    int _size;

public:
    MyLinkedList() {
        _dummyHead = new ListNode();
        _size = 0;
    }

    int get(int index) {
        if (index < 0 || index >= _size)
            return -1;
        ListNode* p = _dummyHead->next;
        while (index--)
            p = p->next;
        return p->val;
    }

    void addAtHead(int val) {
        ListNode* p = new ListNode(val, _dummyHead->next);
        _dummyHead->next = p;
        ++_size;
    }

    void addAtTail(int val) {
        ListNode* p = _dummyHead;
        while (p->next)
            p = p->next;
        p->next = new ListNode(val);
        ++_size;
    }

    void addAtIndex(int index, int val) {
        ListNode* p = _dummyHead;
        if (index < 0 || index > _size)
            return;
        while (index--)
            p = p->next;
        ListNode* temp = new ListNode(val, p->next);
        p->next = temp;
        ++_size;
    }

    void deleteAtIndex(int index) {
        if (index < 0 || index >= _size)
            return;
        ListNode* p = _dummyHead;
        while (index--)
            p = p->next;
        ListNode* temp = p->next;
        p->next = p->next->next;
        delete temp;
        --_size;
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

***js***
```js
var ListNode = function (val = 0, next = null) {
    this.val = val;
    this.next = next;
};

var MyLinkedList = function () {
    this._dummyHead = new ListNode();
    this._size = 0;
};

/** 
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.get = function (index) {
    if (index < 0 || index >= this._size)
        return -1;
    let p = this._dummyHead.next;
    while (index--)
        p = p.next;
    return p.val;
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function (val) {
    const p = new ListNode(val, this._dummyHead.next);
    this._dummyHead.next = p;
    this._size++;
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function (val) {
    let p = this._dummyHead;
    while (p.next)
        p = p.next;
    p.next = new ListNode(val);
    this._size++;
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function (index, val) {
    if (index < 0 || index > this._size)
        return;
    let p = this._dummyHead;
    while (index--)
        p = p.next;
    const temp = new ListNode(val, p.next);
    p.next = temp;
    this._size++;
};

/** 
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function (index) {
    if (index < 0 || index >= this._size)
        return;
    let p = this._dummyHead;
    while (index--)
        p = p.next;
    p.next = p.next.next;
    this._size--;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * var obj = new MyLinkedList()
 * var param_1 = obj.get(index)
 * obj.addAtHead(val)
 * obj.addAtTail(val)
 * obj.addAtIndex(index,val)
 * obj.deleteAtIndex(index)
 */
```

### 206.反转链表

[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

***python***
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# 逐个节点反转
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre, cur = None, head
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre

# 递归
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head
        
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```

***cpp***
```cpp
// 逐个翻转每个节点的指向
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr;
        ListNode *cur = head;
        while (cur)
        {
            ListNode *temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};

// 递归
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr || head->next == nullptr) return head;
        ListNode *last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};
```

***js***
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
// 逐个节点反转
var reverseList = function (head) {
    let pre = null;
    let cur = head;
    while (cur) {
        const temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
};

// 递归
var reverseList = function (head) {
    if (head === null || head.next === null)
        return head;

    const last = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return last;
};
```

### 92. 反转链表 II

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

***python***
```python
# 迭代法
class Solution:
    def reverseBetween(
        self, head: Optional[ListNode], left: int, right: int
    ) -> Optional[ListNode]:
        if left == right:
            return head
        dummyHead = ListNode(0, head)
        p = dummyHead
        for _ in range(left - 1):
            p = p.next
        # 此时 p 指向 left 的前驱
        pre, cur = p.next, p.next.next
        for _ in range(right - left):
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        p.next.next = cur
        p.next = pre
        return dummyHead.next

# 递归
class Solution:
    backup = None  # right 的后继

    def reverse(self, q, count, right):
        if count == right:
            self.backup = q.next
            return q
        count += 1
        last = self.reverse(q.next, count, right)
        q.next.next = q  # 调转指向
        q.next = self.backup  # 指向 right 的后继
        return last

    def reverseBetween(
        self, head: Optional[ListNode], left: int, right: int
    ) -> Optional[ListNode]:
        if left == right:
            return head
        dummyHead = ListNode(0, head)
        p = dummyHead
        for _ in range(1, left):
            p = p.next
        # 此时 p 指向 left 的前驱
        p.next = self.reverse(p.next, left, right)
        return dummyHead.next
```

***cpp***
```cpp
// 迭代法
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if (left == right)
            return head;

        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        int count = left - 1;
        while (count--) // p 指向 left 的前驱
            p = p->next;
        ListNode* pre = p->next;
        ListNode* cur = pre->next;
        count = right - left;
        while (count--) {
            ListNode* count = cur->next;
            cur->next = pre;
            pre = cur;
            cur = count;
        }
        p->next->next = cur;
        p->next = pre;
        return dummyHead->next;
    }
};

// 递归
class Solution {
public:
    ListNode* backup = nullptr;     // right 的后继
    ListNode* reverse(ListNode* q, int& count, const int& right) {
        if (count == right) {
            backup = q->next;
            return q;
        }
        ++count;
        ListNode* last = reverse(q->next, count, right);
        q->next->next = q;      // 调转指向
        q->next = backup;       // 指向 right 的后继
        return last;
    }

    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if (left == right)
            return head;
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        for (int count = 1; count < left; count++)
            p = p->next;
        // 此时 p 指向 left 的前驱
        p->next = reverse(p->next, left, right);
        return dummyHead->next;
    }
};
```

***js***
```js

```

### 25. K 个一组翻转链表

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)

***python***
```python
class Solution:
    def reverse(self, head: ListNode, tail: ListNode):  # [)
        pre, cur = None, head
        while cur != tail:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre

    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        p = q = head
        for _ in range(k):
            if q == None:
                return head
            q = q.next
        # 此时 q 指向下一组的头节点
        last = self.reverse(p, q)
        p.next = self.reverseKGroup(q, k)
        return last
```

***cpp***
```cpp
class Solution {
private:
  ListNode* reverse(ListNode* a, ListNode* b) { // [)
    ListNode* pre = nullptr;
    ListNode *cur = a, *next = a;
    while (cur != b) {
      next = cur->next;
      cur->next = pre;
      pre = cur;
      cur = next;
    }
    return pre;
  }

public:
  ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr) return head;
    ListNode *a, *b;
    a = b = head;
    for (int i = 0; i < k; i++) {
      if (b == nullptr) return head;
      b = b->next;
    }

    // 此时 b 指向下一组的头节点
    ListNode* newHead = reverse(a, b);
    a->next = reverseKGroup(b, k);
    return newHead;
  }
};
```

***js***
```js
```

### 24. 两两交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

***python***
```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(0, head)
        p = dummyHead
        while p.next and p.next.next:
            temp = p.next
            p.next = temp.next
            temp.next = temp.next.next
            p.next.next = temp
            p = temp
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next && p->next->next) {
            ListNode* temp = p->next;
            p->next = temp->next;
            temp->next = temp->next->next;
            p->next->next = temp;
            p = temp;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 19.删除链表的倒数第N个节点

[19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

***python***
```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummyHead = ListNode(0, head)
        slow, fast = dummyHead, head
        for _ in range(n):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
  ListNode *removeNthFromEnd(ListNode *head, int n) {
    ListNode *dummyHead = new ListNode(0, head);
    ListNode *fast = dummyHead;
    ListNode *slow = dummyHead;
    while (n-- >= 0) // 走 n + 1 步
      fast = fast->next;

    while (fast) {
      fast = fast->next;
      slow = slow->next;
    }

    ListNode *del = slow->next;
    slow->next = del->next;
    delete del;
    return dummyHead->next;
  }
};
```

***js***
```js
```

### 面试题 02.07. 链表相交

[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

***python***
```python
# 方法一：提前记载各自长度
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p = headA
        countA = countB = 0
        while p:
            p = p.next
            countA += 1

        p = headB
        while p:
            p = p.next
            countB += 1

        if countA == 0 or countB == 0:
            return None
        p, q = headA, headB

        if countA < countB:
            p, q = q, p
        # 此时 p 指向长链表
        for _ in range(abs(countA - countB)):
            p = p.next
        while p != q:
            p = p.next
            q = q.next

        return p

# 优雅解法，尾连接
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p, q = headA, headB
        while p != q:
            if p == None:
                p = headB
            else:
                p = p.next

            if q == None:
                q = headA
            else:
                q = q.next

        return q
```

***cpp***
```cpp
// 方法一：提前记载各自长度
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode* p = headA;
        int countA = 0, countB = 0;
        while (p) {
            p = p->next;
            ++countA;
        }
        p = headB;
        while (p) {
            p = p->next;
            ++countB;
        }
        if (countA == 0 || countB == 0)
            return nullptr;
        p = headA;
        ListNode* q = headB;
        if (countA < countB)
            swap(q, p);
        // 此时 p 指向长链表
        int temp = abs(countA - countB);
        while (temp--)
            p = p->next;
        while (p != q) {
            p = p->next;
            q = q->next;
        }
        return q;
    }
};

// 巧妙，尾连接
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode *p = headA, *q = headB;
        while (p != q) {
            if (p == nullptr) p = headB;
            else p = p->next;

            if (q == nullptr) q = headA;
            else q = q->next;
        }
        return q;
    }
};
```

***js***
```js
```

### 141. 环形链表

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)

***python***
```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

***cpp***
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        while (fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) return true;
        }
        return false;
    }
};
```

***js***
```js
```

### 142.环形链表II

[142.环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

***python***
```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

            if fast == slow:
                p, q = fast, head
                while p != q:
                    p = p.next
                    q = q.next
                return q
        return None
```

***cpp***
```cpp
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode *fast = head, *slow = head;

        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;

            if (fast == slow) {
                ListNode* p = fast;
                ListNode* q = head;
                while (q != p) {
                    q = q->next;
                    p = p->next;
                }
                return q;
            }
        }
        return nullptr;
    }
};
```

***js***
```js
```

### 21. 合并两个有序链表

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

***python***
```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(0, list1)
        p, q = dummyHead, list2
        while p.next and q:
            if q.val <= p.next.val:
                cur = q
                q = q.next
                cur.next = p.next
                p.next = cur
            p = p.next

        if q:
            p.next = q
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummyHead = new ListNode(0, list1);
        ListNode *p = dummyHead, *q = list2;
        while (p->next && q) {
            if (q->val <= p->next->val) {
                ListNode* cur = q;
                q = q->next;
                cur->next = p->next;
                p->next = cur;
            }
            p = p->next;
        }
        if (q)
            p->next = q;
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 23. 合并 K 个升序链表

[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

***python***
```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        p = dummyHead = ListNode(0)
        heap = []
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(heap, (lists[i].val, i))
                lists[i] = lists[i].next

        while heap:
            val, idx = heapq.heappop(heap)
            p.next = ListNode(val)
            p = p.next
            if lists[idx]:
                heapq.heappush(heap, (lists[idx].val, idx))
                lists[idx] = lists[idx].next

        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    struct compare { // 小顶堆
        bool operator()(const ListNode* const& l, const ListNode* const& r) {
            return l->val > r->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty())
            return nullptr;
        ListNode* dummyHead = new ListNode(0);
        ListNode* p = dummyHead;

        priority_queue<ListNode*, vector<ListNode*>, compare> pq;
        for (auto head : lists) // 将 k 个头结点入队
            if (head)
                pq.push(head);

        while (!pq.empty()) {
            ListNode* cur = pq.top();
            pq.pop();
            if (cur->next)
                pq.push(cur->next);
            p->next = cur;
            p = p->next;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 86. 分隔链表

[86. 分隔链表](https://leetcode.cn/problems/partition-list/description/)

***python***
```python
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        p = dummyHead = ListNode(0, head)
        while p.next and p.next.val < x:
            p = p.next

        q = p.next
        while q and q.next:
            if q.next.val < x:
                cur = q.next
                q.next = cur.next
                cur.next = p.next
                p.next = cur
                p = cur
            else:
                q = q.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next && p->next->val < x)
            p = p->next;

        ListNode* q = p->next; // 此时 q 指向右半节点的头，p 指向左半节点的头
        while (q && q->next)
            if (q->next->val < x) {
                ListNode* cur = q->next;
                q->next = cur->next;
                cur->next = p->next;
                p->next = cur;
                p = cur;
            } else
                q = q->next;

        return dummyHead->next;
    }
};
```

***js***
```js
```

### 876. 链表的中间结点

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)

***python***
```python
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
```

***cpp***
```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *fast = head, *slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

***js***
```js
```

### 234. 回文链表
[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/)

***python***
```python
# 借用空间
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        p = head
        arr = []
        while p:
            arr.append(p.val)
            p = p.next
        left, right = 0, len(arr) - 1
        while left <= right:
            if arr[left] != arr[right]:
                return False
            left += 1
            right -= 1
        return True

# 递归 (dfs)
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        self.p = head
        def dfs(head: Optional[ListNode]) -> bool:
            if head is None:
                return True

            if not dfs(head.next):
                return False

            if self.p.val != head.val:
                return False

            self.p = self.p.next
            return True

        return dfs(head)

# 双指针 + 反转链表
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        if fast:
            slow = slow.next

        # 翻转后半部分链表
        pre, cur = None, slow
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp

        while pre:
            if pre.val != head.val:
                return False
            pre = pre.next
            head = head.next
        return True
```

***cpp***
```cpp
// 借用空间
class Solution {
  public:
  bool isPalindrome(ListNode *head) {
    vector<int> vec;
    ListNode *p = head;
    while (p) {
      vec.push_back(p->val);
      p = p->next;
    }
    int left = 0, right = vec.size() - 1;
    while (left < right)
      if (vec[left++] != vec[right--]) return false;
    return true;
  }
};

// 递归 （dfs）
class Solution {
private:
    ListNode* p, *headback;
    bool dfs(ListNode* head) {
        if (head == nullptr || (p != headback && p == head))   // 剪枝，到中间就返回
            return true;

        bool res1 = dfs(head->next);
        bool res2 = head->val == p->val;
        p = p->next;
        return res1 && res2;
    }

public:
    bool isPalindrome(ListNode* head) {
        headback = p = head;
        return dfs(head);
    }
};

// 双指针 + 反转链表
class Solution {
public:
  bool isPalindrome(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
    }
    if (fast) slow = slow->next;

    // 翻转后半部分链表
    ListNode *pre = nullptr, *cur = slow, *nex = slow;
    while (cur) {
      nex = cur->next;
      cur->next = pre;
      pre = cur;
      cur = nex;
    }
    while (pre) {
      if (pre->val != head->val) return false;
      pre = pre->next;
      head = head->next;
    }
    return true;
  }
};
```

***js***
```js
```

------------------------------

## 3 哈希表

### 242.有效的字母异位词

[242.有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/)

***python***
```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        arr = [0] * 26
        for c in s:
            arr[ord(c) - ord('a')] += 1     # ord() 用来获取字符的 ASCII 码

        for c in t:
            arr[ord(c) - ord('a')] -= 1

        for num in arr:
            if num:
                return False

        return True
```

***cpp***
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size())
            return false;
        int a[26] = {0};
        for (char ch : s)
            ++a[ch - 'a'];
        for (char ch : t)
            --a[ch - 'a'];
        
        for (int i = 0; i < 26; ++i)
            if (a[i])
                return false;
        
        return true;
    }
};
```

### 383. 赎金信

[383. 赎金信](https://leetcode.cn/problems/ransom-note/description/)

***python***
```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        arr = [0] * 26
        for c in magazine:
            arr[ord(c) - ord("a")] += 1

        for c in ransomNote:
            arr[ord(c) - ord("a")] -= 1

        for num in arr:
            if num < 0:
                return False

        return True
```


***cpp***
```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        for (char ch : magazine)
            ++record[ch - 'a'];
        
        for (char ch : ransomNote)
            --record[ch - 'a'];
        
        for (int i = 0; i < 26; ++i)
            if (record[i] < 0)
                return false;
        
        return true;
    }
};
```

### 49. 字母异位词分组

[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)

***python***
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        umap = {}
        for string in strs:
            sorted_str = "".join(sorted(string))    # 排序后的字符串作为 key
            if sorted_str not in umap:
                umap[sorted_str] = []
            umap[sorted_str].append(string)

        return list(umap.values())  # 返回字典的值, 并转换为列表
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> umap;
        for (const string& str : strs) {
            string temp = str;
            sort(temp.begin(), temp.end());
            umap[temp].emplace_back(str);
        }
        vector<vector<string>> res;
        for (auto it = umap.begin(); it != umap.end(); ++it)
            res.push_back(it->second);
        return res;
    }
};
```

### 438. 找到字符串中所有字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

***python***
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        umap = {}
        res = []
        for c in p:
            if c not in umap:
                umap[c] = 0
            umap[c] += 1

        invalid = len(umap)
        left = right = 0  # [)
        while right < len(s):
            c = s[right]  # 扩大窗口
            right += 1
            if c in umap:
                umap[c] -= 1
                if umap[c] == 0:
                    invalid -= 1

            if right - left == len(p):
                if invalid == 0:
                    res.append(left)  # 收结果
                d = s[left]
                left += 1  # 收缩窗口
                if d in umap:
                    if umap[d] == 0:
                        invalid += 1
                    umap[d] += 1

        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        if (s.size() < p.size())
            return res;
        unordered_map<char, int> umap;
        for (const char& c : p)
            ++umap[c];
        int invalid = umap.size();
        int left = 0, right = 0; // [)
        while (right < s.size()) {
            char c = s[right++]; // 扩大窗口
            if (umap.find(c) != umap.end()) {
                --umap[c];
                if (umap[c] == 0)
                    --invalid;
            }

            if (right - left == p.size()) {
                if (invalid == 0)
                    res.emplace_back(left); // 收结果
                char d = s[left++];         // 缩小窗口
                if (umap.find(d) != umap.end()) {
                    if (umap[d] == 0)
                        ++invalid;
                    ++umap[d];
                }
            }
        }
        return res;
    }
};
```

### 349. 两个数组的交集

[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

***python***
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        my_set = set(nums1)
        res = []

        for num in nums2:
            if num in my_set:
                res.append(num)
                my_set.remove(num)

        return res
```

***cpp***
```cpp
class Solution{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2){
        unordered_set<int> mySet;
        vector<int> res;

        for (int num1 : nums1)
            mySet.insert(num1);
        for (int num2 : nums2)
            if (mySet.find(num2) != mySet.end()){
                res.emplace_back(num2);
                mySet.erase(num2);
            }

        return res;
    }
};
```

### 350. 两个数组的交集 II

[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/)

***python***
```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        umap = {}
        res = []
        for num in nums1:
            if num not in umap:
                umap[num] = 0
            umap[num] += 1

        for num in nums2:
            if num in umap and umap[num]:
                res.append(num)
                umap[num] -= 1

        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> umap;
        vector<int> res;
        for (int num : nums1)
            ++umap[num];

        for (int num : nums2) {
            auto it = umap.find(num);
            if (it != umap.end() && it->second) {
                res.push_back(num);
                --(it->second);
            }
        }
        return res;
    }
};
```

### 202. 快乐数

[202. 快乐数](https://leetcode.cn/problems/happy-number/description/)

***python***
```python
class Solution:
    def isHappy(self, n: int) -> bool:
        num_set = set()
        while n != 1:
            num_set.add(n)
            sum_of_digits = 0
            while n:
                sum_of_digits += (n % 10) * (n % 10)
                n //= 10
            if sum_of_digits in num_set:
                return False
            n = sum_of_digits
        return True
```

***cpp***
```cpp
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> uset;
        while (n != 1) {
            uset.insert(n);
            int sum = 0;
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            if (uset.count(sum))
                return false;
            n = sum;
        }
        return true;
    }
};
```

### 1. 两数之和

[1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

***python***
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        umap = {}
        for idx, num in enumerate(nums):
            if target - num in umap:
                return [umap[target - num], idx]
            umap[num] = idx
```

***cpp***
```cpp
class Solution {
public:
  vector<int> twoSum(vector<int> &nums, int target) {
    unordered_map<int, int> umap;
    for (int i = 0; i < nums.size(); i++) {
      auto it = umap.find(target - nums[i]);
      if (it != umap.end())
        return {it->second, i};
      umap.insert({nums[i], i});
    }
    return {-1, -1};
  }
};
```

### 454. 四数相加II

[454. 四数相加II](https://leetcode.cn/problems/4sum-ii/description/)

***python***
```python
class Solution:
    def fourSumCount(
        self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]
    ) -> int:
        umap = {}
        res = 0
        for n1 in nums1:
            for n2 in nums2:
                temp = n1 + n2
                if temp not in umap:
                    umap[temp] = 0
                umap[temp] += 1

        for n3 in nums3:
            for n4 in nums4:
                temp = -n3 -n4
                if temp in umap:
                    res += umap[temp]

        return res
```

***cpp***
```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,
                     vector<int>& nums4) {
        unordered_map<int, int> umap;
        int res = 0;
        for (int num1 : nums1)
            for (int num2 : nums2)
                ++umap[num1 + num2];

        for (int num3 : nums3)
            for (int num4 : nums4) {
                auto it = umap.find(-num3 - num4);
                if (it != umap.end())
                    res += it->second;
            }

        return res;
    }
};
```

### 15. 三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/description/)

***python***
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        i = 0
        while i < len(nums):
            if nums[i] > 0:
                break
            left, right = i + 1, len(nums) - 1
            while left < right:
                if nums[i] + nums[left] == -nums[right]:
                    res.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif nums[i] + nums[left] < -nums[right]:
                    left += 1
                else:
                    right -= 1
            while i < len(nums) - 1 and nums[i] == nums[i + 1]:
                i += 1
            i += 1
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] > 0)
                break;
            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                if (nums[i] + nums[left] == -nums[right]) {
                    res.push_back(
                        vector<int>{nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1])
                        ++left;
                    while (left < right && nums[right] == nums[right - 1])
                        --right;
                    ++left;
                    --right;
                } else if (nums[i] + nums[left] < -nums[right])
                    ++left;
                else
                    --right;
            }
            while (i < nums.size() - 1 && nums[i] == nums[i + 1])
                ++i;
        }
        return res;
    }
};
```

### 18. 四数之和

[18. 四数之和](https://leetcode.cn/problems/4sum/description/)

***python***
```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        res = []
        nums.sort()
        i, j = 0, 1
        while i < len(nums):
            sum = nums[i]
            if sum > 0 and sum > target:    # 剪枝
                return res
            j = i + 1
            while j < len(nums):
                sum = nums[i] + nums[j]
                if sum > 0 and sum > target:    # 剪枝
                    break
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[i] + nums[j] == target - nums[left] - nums[right]:
                        res.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        left += 1
                        right -= 1
                    elif nums[i] + nums[j] < target - nums[left] - nums[right]:
                        left += 1
                    else:
                        right -= 1
                while j < len(nums) - 1 and nums[j] == nums[j + 1]:
                    j += 1
                j += 1
            while i < len(nums) - 1 and nums[i] == nums[i + 1]:
                i += 1
            i += 1
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < (int)nums.size() - 3; i++) {
            int sum = nums[i];
            if (sum > 0 && sum > target) // 剪枝
                return res;
            if (i > 0 && nums[i] == nums[i - 1])
                continue;

            for (int j = i + 1; j < (int)nums.size() - 2; ++j) {
                sum = nums[i] + nums[j];
                if (sum > 0 && sum > target) // 剪枝
                    break;
                if (j > i + 1 && nums[j] == nums[j - 1])
                    continue;

                int left = j + 1;
                int right = nums.size() - 1;
                while (left < right) {
                    if ((long)nums[i] + nums[j] <
                        (long)target - nums[left] - nums[right])
                        ++left;
                    else if ((long)nums[i] + nums[j] >
                             (long)target - nums[left] - nums[right])
                        --right;
                    else {
                        res.emplace_back(vector<int>{nums[i], nums[j],
                                                     nums[left], nums[right]});
                        ++left;
                        --right;
                        while (left < right && nums[left] == nums[left - 1])
                            ++left;
                        while (left < right && nums[right] == nums[right + 1])
                            --right;
                    }
                }
            }
        }
        return res;
    }
};
```


----------------------------------------

## 4 字符串

### 344. 反转字符串

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)

***python***
```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

***cpp***
```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0, right = s.size() - 1;
        while (left < right)
            swap(s[left++], s[right--]);
    }
};
```

### 541. 反转字符串II

[541. 反转字符串II](https://leetcode.cn/problems/reverse-string-ii/description/)

***python***
```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        def reverseString(s: str, left, right) -> str:
            s_list = list(s)
            while left < right:
                s_list[left], s_list[right] = s_list[right], s_list[left]
                left += 1
                right -= 1
            return "".join(s_list)

        left, right = 0, k  # [)
        for _ in range(len(s) // (2 * k)):
            s = reverseString(s, left, right - 1)
            left += 2 * k
            right += 2 * k

        if right >= len(s):
            s = reverseString(s, left, len(s) - 1)
        else:
            s = reverseString(s, left, right - 1)
        return s
```

***cpp***
```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        int count = s.size() / (2 * k);
        int left, right;
        for (left = 0, right = k; count; --count) {
            reverse(s.begin() + left, s.begin() + right);
            left += (2 * k);
            right = left + k;
        }
        right > s.size() ? reverse(s.begin() + left, s.end())
                         : reverse(s.begin() + left, s.begin() + right);
        return s;
    }
};
```

### 替换数字（第八期模拟笔试）

[替换数字（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1064)

***python***
```python
s = input()

res = ""
for ch in s:
    if ch.isdigit():
        res += "number"
    else:
        res += ch

print(res)
```

***cpp***
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
  string s;
  cin >> s;

  string res;
  for (auto ch : s) {
    if (isdigit(ch))
      res += "number";
    else
      res.push_back(ch);
  }
  cout << res;
  return 0;
}
```

### 151. 翻转字符串里的单词

[151. 翻转字符串里的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

***python***
```python
s = input()

res = ""
for ch in s:
    if ch.isdigit():
        res += "number"
    else:
        res += ch

print(res)
```

***cpp***
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
  string s;
  cin >> s;

  string res;
  for (auto ch : s) {
    if (isdigit(ch))
      res += "number";
    else
      res.push_back(ch);
  }
  cout << res;
  return 0;
}
```

### 55. 右旋字符串（第八期模拟笔试）

[55. 右旋字符串（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1065)

***python***
```python
def rotate_string(s, k):
    k %= len(s)  # Ensure k is within the bounds of the string length
    s = s[::-1]  # Reverse the entire string
    s = s[:k][::-1] + s[k:][::-1]  # Reverse the first k characters and the remaining characters separately
    return s

# Input
k = int(input())
s = input()

# Output the rotated string
print(rotate_string(s, k))

```

***cpp***
```cpp
#include <algorithm>
#include <iostream>
#include <string>

using namespace std;

int main() {
  int k;
  string s;
  cin >> k >> s;
  k %= s.size();
  reverse(s.begin(), s.end());
  reverse(s.begin(), s.begin() + k);
  reverse(s.begin() + k, s.end());
  cout << s << endl;
  return 0;
}
```

### 28. 找出字符串中第一个匹配项的下标

#### KMP

`search(char pat[], char txt[])` 函数用于在字符串 `txt` 中查找字符串 `pat`，假设 `txt.size() > pat.size()`

KMP 算法对 `pat[]` 进行预处理，得到 `next[]` 数组，`next[i]` 表示 `pat[0..i]` 的**最长真前缀后缀匹配长度**，所谓**真**是指不允许包含整个字符串的前缀

**预处理（求 `next[]` 数组）算法**
- 计算 `next[]` 中的值。为此，跟踪前一个索引的最长前缀后缀值得长度（使用 `len` 变量）
- `next[0]` 和 `len` 都初始化为 `0`
- 如果 `pat[len]` 和 `pat[i]` 匹配，将 `len` 加 `1`，并将增加后的值赋给 `lps[i]`
- 如果 `pat[i]` 和 `pat[len]` 不匹配并且 `len` 不为 `0`，我们将 `len` 更新为 `lps[len-1]`


**KMP 算法的实现**

使用 `next[]` 中的值来决定下一个要匹配的字符，不匹配那些我们知道无论如何都会匹配的字符

- `txt[i]` 和 `pat[j]` 做匹配
- 如果**匹配**，`i` 和 `j` 都加 `1`
- 如果 `j = pat.size()`，说明找到了匹配项，重置 `j = next[j - 1]` 继续匹配
- 如果**不匹配**，`j = next[j - 1]`

```cpp
class KMP {
public:
  vector<int> KMPSearch(string txt, string pat) {
    vector<int> res;
    vector<int> next = getNext(pat);
    int i = 0, j = 0;
    while (txt.size() - i >= pat.size() - j) {
      if (pat[j] == txt[i]) {
        ++i;
        ++j;
      }
      if (j == pat.size()) {
        res.push_back(i - j);
        j = next[j - 1];
      } else if (i < txt.size() && pat[j] != txt[i]) {
        if (j)
          j = next[j - 1];
        else
          ++i;
      }
    }
    return res;
  }

private:
  vector<int> getNext(const string &pat) {
    vector<int> next(pat.size());
    next[0] = 0;
    int len = 0, i = 1;

    while (i < pat.size())
      if (pat[i] == pat[len])
        next[i++] = ++len;
      else if (len) // if (pat[i] != pat[len] && len != 0)
        len = next[len - 1];
      else // if (pat[i] != pat[len] && len == 0)
        next[i++] = 0;
    return next;
  }
};
```

-----------------------------------


[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

***python***
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def getNext(pat: str):
            next = [0] * len(pat)
            length, i = 0, 1
            while i < len(pat):
                if pat[i] == pat[length]:
                    length += 1
                    next[i] = length
                    i += 1
                else:
                    if length:
                        length = next[length - 1]
                    else:
                        next[i] = 0
                        i += 1
            return next

        next = getNext(needle)
        i, j = 0, 0
        while i < len(haystack):
            if haystack[i] == needle[j]:
                i += 1
                j += 1
            if j == len(needle):
                return i - j
            elif i < len(haystack) and haystack[i] != needle[j]:
                if j:
                    j = next[j - 1]
                else:
                    i += 1
        return -1
```

***cpp***
```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        vector<int> next(needle.size());
        getNext(needle, next);
        int i = 0, j = 0;
        while (haystack.size() - i >= needle.size() - j) {
            if (haystack[i] == needle[j]) {
                ++i;
                ++j;
            }
            if (needle.size() == j)
                return i - j;
            else if (i < haystack.size() && haystack[i] != needle[j]) {
                if (j)
                    j = next[j - 1];
                else
                    ++i;
            }
        }
        return -1;
    }

private:
    void getNext(const string& pat, vector<int>& next) {
        next[0] = 0;
        int len = 0, i = 1;
        while (i < pat.size())
            if (pat[i] == pat[len])
                next[i++] = ++len;
            else if (len)
                len = next[len - 1];
            else
                next[i++] = len;
    }
};
```

### 459.重复的子字符串

[459.重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)

`s` repeated => `s` in `s + s`
`s` no in `s + s` => `s` not repeated

***python***
```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        return (s + s).find(s, 1) != len(s)
```

***cpp***
```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s + s).find(s, 1) != s.size();
    }
};
```

## 5 双指针

### [27. 移除元素](#27-移除元素)
### [344. ]()


## 1 数组

### 704. 二分查找

[704. 二分查找](https://leetcode.cn/problems/binary-search/description/)

***python***
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1  # []
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

***cpp***
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // []
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return -1;
    }
};
```

***js***
```js
var search = function (nums, target) {
    let l = 0, r = nums.length - 1; // []
    while (l <= r) {
        let mid = (r + l) >> 1;
        if (nums[mid] === target) return mid;
        else if (nums[mid] < target)
            l = mid + 1;
        else r = mid - 1;
    }
    return -1;
};
```

### 35. 搜索插入位置

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

***python***
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid - 1
            else :
                left = mid + 1
        return left
```

***cpp***
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // []
        while(left <= right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] > target)
                right = mid - 1;
            else 
                left = mid + 1;
        }
        return left;
    }
};
```

***js***
```js
var searchInsert = function (nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] === target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1;
        else right = mid - 1;
    }
    return left;
};
```

### 34. 在排序数组中查找元素的第一个和最后一个位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

***python***
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1  # []

        def getLeftBound(nums, target):
            nonlocal left, right
            while left <= right:
                mid = left + (right - left) // 2
                if nums[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left < len(nums) and nums[left] == target:
                return left
            return -1

        def getRightBound(nums, target):
            nonlocal left, right
            right = len(nums) - 1
            while left <= right:
                mid = left + (right - left) // 2
                if nums[mid] <= target:
                    left = mid + 1
                else:
                    right = mid - 1
            return right

        leftBound = getLeftBound(nums, target)
        if leftBound == -1:
            return [-1, -1]
        return [leftBound, getRightBound(nums, target)]
```

***cpp***
```cpp
class Solution {
public:
    int left = 0, right;
    int findLeftBound(const vector<int>& nums, const int& target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target)
                right = mid - 1;
            else
                left = mid + 1;
        }
        if (left < nums.size() && nums[left] == target)
            return left;
        return -1;
    }

    int findRightBound(const vector<int>& nums, const int& target) {
        right = nums.size() - 1; // []
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        right = nums.size() - 1; // []
        int leftBound = findLeftBound(nums, target);
        if (leftBound == -1)
            return {-1, -1};
        return {leftBound, findRightBound(nums, target)};
    }
};
```

***js***
```js
var searchLeftBound = function (nums, target) {
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] >= target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    if (left < nums.length && nums[left] === target)
        return left;
    return -1;
};

var searchRightBound = function (nums, target) {
    right = nums.length - 1;
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] <= target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return right;
};

var searchRange = function (nums, target) {
    left = 0;
    right = nums.length - 1;
    let leftBound = searchLeftBound(nums, target);
    if (leftBound === -1) return [-1, -1];
    return [leftBound, searchRightBound(nums, target)];
};
```


### 69. x 的平方根

[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/description/)

***python***
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return x
        left, right = 1, x
        while left <= right:
            mid = left + (right - left) // 2
            if x // mid == mid:
                return mid
            elif x // mid > mid:
                left = mid + 1
            else :
                right = mid - 1
        return right
```

***cpp***
```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0)
            return 0;
        int left = 1, right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (x / mid == mid) // 防止数值溢出
                return mid;
            else if (x / mid > mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }
};
```

***js***
```js
var mySqrt = function (x) {
    if (x === 0) return x;
    let left = 1, right = x;
    while (left <= right) {
        let mid = left + ((right - left) >> 1);
        if (mid === Math.floor(x / mid))
            return mid;
        else if (mid < Math.floor(x / mid))
            left = mid + 1;
        else
            right = mid - 1;
    }
    return right;
};
```

### 367. 有效的完全平方数

[367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/description/)

***python***
```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 1, num
        while left <= right:
            mid = left + (right - left) // 2
            if mid * mid == num:
                return True
            elif mid * mid < num:
                left = mid + 1
            else:
                right = mid - 1
        return False
```

***cpp***
```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 1, right = num;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if ((long)mid * mid == num)
                return true;
            else if ((long)mid * mid < num)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return false;
    }
};
```

***js***
```js
var isPerfectSquare = function (num) {
    let left = 1, right = num;
    while (left <= right) {
        let mid = left + ((right - left) >> 1);
        if (mid * mid == num)
            return true;
        else if (mid * mid < num)
            left = mid + 1;
        else right = mid - 1;
    }
    return false;
};
```

### 27. 移除元素

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/description/)

***python***
```python
class Solution(object):
    def removeElement(self, nums, val):
        left, right  = 0, len(nums) - 1
        while left <= right:
            while left <= right and nums[left] != val:
                left += 1
            while left <= right and nums[right] == val:
                right -= 1
            if left <= right:
                nums[left] = nums[right]
                left += 1
                right -= 1
        return left
```

***cpp***
```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size() - 1; // []
        while (left <= right) {
            while (left <= right && nums[left] != val)
                left++;
            while (left <= right && nums[right] == val)
                right--;
            if (left <= right)
                nums[left++] = nums[right--];
        }
        return left;
    }
};
```

***js***
```js
var removeElement = function(nums, val) {
    let slow = 0, fast = 0;
    for(; fast < nums.length; fast++)
        if (nums[fast] != val)
            nums[slow++] = nums[fast];
    return slow;
};
```

### 26. 删除排序数组中的重复项

[26. 删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

***python***

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 0
        while fast < len(nums):
            if fast < len(nums) - 1 and nums[fast] == nums[fast + 1]:
                fast += 1
                continue
            else:
                nums[slow] = nums[fast]
                slow += 1
                fast += 1
        return slow
```

***cpp***

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 0, fast = 0;
        while (fast < nums.size()) {
            if (fast < nums.size() - 1 && nums[fast] == nums[fast + 1]){
                fast++;
                continue;
            }
            else
                nums[slow++] = nums[fast];
            fast++;
        }
        return slow;
    }
};
```

***js***
```js
var removeDuplicates = function(nums) {
    let slow = 1, fast = 0;
    while (fast < nums.length){
        if (fast > 0 && nums[fast] != nums[fast - 1])
            nums[slow++] = nums[fast];
        fast++;
    }
    return slow;
};
```

### 283. 移动零

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/description/)

***python***

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow, fast = 0, 0
        while fast < len(nums):
            if nums[fast]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        while slow < len(nums):
            nums[slow] = 0
            slow += 1
```

***cpp***

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0, fast = 0;
        for(; fast < nums.size(); fast++)
            if(nums[fast])
                nums[slow++] = nums[fast];

        while(slow < nums.size())
            nums[slow++] = 0;
    }
};
```

***js***
```js
var moveZeroes = function (nums) {
    let slow = 0, fast = 0;
    for (; fast < nums.length; fast++)
        if (nums[fast] != 0)
            nums[slow++] = nums[fast];

    while (slow < nums.length)
        nums[slow++] = 0;
};
```

### 844. 比较含退格的字符串

[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/description/)

***python***

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def modify(S):
            stack = []
            for char in S:
                if char != '#':
                    stack.append(char)
                elif stack:
                    stack.pop()
            return ''.join(stack)

        return modify(s) == modify(t)


# ----------------------------
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        return self.modifyString(s) == self.modifyString(t)
    
    def modifyString(self, s: str) -> str:
        slow, fast = 0, 0
        s_list = list(s)
        while fast < len(s_list):
            if s_list[fast] != '#':
                s_list[slow] = s_list[fast]
                slow += 1
            elif slow > 0:
                slow -= 1

            fast += 1
        return ''.join(s_list[:slow])
```

***cpp***

```cpp
class Solution
{
public:
    bool backspaceCompare(string s, string t)
    {
        modifyString(s);
        modifyString(t);
        return s == t;
    }

private:
    void modifyString(string &s)
    {
        int slow = 0, fast = 0;
        for (; fast < s.length(); ++fast)
            if (s[fast] == '#' && slow > 0)
                --slow;
            else if (s[fast] != '#')
                s[slow++] = s[fast];
        s.resize(slow);
    }
};
```

***js***
```js
var backspaceCompare = function (s, t) {
    modify = function (s) {
        let slow = 0, sArr = s.split('');
        for (let fast = 0; fast < sArr.length; fast++) {
            if (sArr[fast] != '#')
                sArr[slow++] = sArr[fast];
            else if (slow > 0)
                slow--;
        }
        sArr.length = slow;
        return sArr.join('');
    }
    s = modify(s);
    t = modify(t);
    return s == t;
};
```

### 977. 有序数组的平方

[977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/description/)

***python***

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        res = [0] * len(nums)
        nums = [num * num for num in nums]
        i, j, k = 0, len(nums) - 1, len(nums) - 1
        while k >= 0:
            if nums[i] >= nums[j]:
                res[k] = nums[i]
                i += 1
            else:
                res[k] = nums[j]
                j -= 1
            k -= 1
        return res
```

***cpp***

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for (int& num : nums)
            num = num * num;

        vector<int> res(nums.size());
        for (int i = 0, j = nums.size() - 1, k = j; k >= 0; --k)
            nums[i] >= nums[j] ? res[k] = nums[i++] : res[k] = nums[j--];

        return res;
    }
};
```

***js***

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function (nums) {
    // 将 nums 数组中的每个元素取平方，并生成一个新的数组
    nums = nums.map(num => num * num)
    let res = new Array(nums.length);
    let i = 0, j = nums.length - 1, k = nums.length - 1;
    while (k >= 0) {
        if (nums[i] >= nums[j]) {
            res[k] = nums[i];
            i++;
        } else {
            res[k] = nums[j];
            j--;
        }
        k--;
    }
    return res;
};
```

### 209. 长度最小的子数组

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/)

***python***

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left, right = 0, 0  # [)
        sum = 0
        res = len(nums) + 1
        while right < len(nums):
            while right < len(nums) and sum < target:
                sum += nums[right]
                right += 1
            while sum >= target:
                res = min(res, right - left)
                sum -= nums[left]
                left += 1
        return 0 if res == len(nums) + 1 else res
```

***cpp***

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT32_MAX;
        int sum = 0;
        for (size_t i = 0, j = 0; i < nums.size(); ++i) {
            sum += nums[i];
            while (sum >= target) {
                int subLength = i - j + 1;
                res = res < subLength ? res : subLength;
                sum -= nums[j++];
            }
        }
        return res == INT32_MAX ? 0 : res;
    }
};
```

***js***

```js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
    let left = 0, right = 0;    // [)
    let sum = 0;
    let res = nums.length + 1;
    while (right < nums.length) {
        sum += nums[right];
        right++;
        while (sum >= target) {
            res = Math.min(res, right - left);  // 注意是Math.min()
            sum -= nums[left++];
        }
    }
    return res === nums.length + 1 ? 0 : res;
};
```

### 904. 水果成篮

[904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/description/)

***python***

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        fruit_map = {}
        left, right = 0, 0
        temp_res, res = 0, 0
        for fruit in fruits:
            if fruit in fruit_map:
                fruit_map[fruit] += 1
            else:
                fruit_map[fruit] = 1
            
            if len(fruit_map) <= 2:
                temp_res += 1
                res = max(res, temp_res)
            else:
                while len(fruit_map) > 2:
                    fruit_map[fruits[left]] -= 1
                    if fruit_map[fruits[left]] == 0:
                        del fruit_map[fruits[left]]
                    left += 1
                temp_res = right - left + 1
            right += 1
        return res
```

***cpp***

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> umap;
        int res = 0, temp_res = 0;
        int left = 0, right = 0;
        while (right < fruits.size()) {
            ++umap[fruits[right]]; // 加入元素
            right++;

            if (umap.size() <= 2) { // 收获结果
                temp_res += 1;
                res = max(res, temp_res);
            } else {    // 收缩窗口
                while (umap.size() > 2) {
                    --umap[fruits[left]];
                    if (umap[fruits[left]] == 0)
                        umap.erase(fruits[left]);
                    ++left;
                }
                temp_res = right - left;
            }
        }
        return res;
    }
};
```

***js***

```js
/**
 * @param {number[]} fruits
 * @return {number}
 */
var totalFruit = function (fruits) {
    const fruitMap = new Map();
    let res = 0, tempRes = 0;
    let slow = 0, fast = 0;
    for (const fruit of fruits) {
        fruitMap.set(fruit, (fruitMap.get(fruit) || 0) + 1);

        if (fruitMap.size <= 2) {
            tempRes += 1;
            res = Math.max(res, tempRes);
        } else {
            while (fruitMap.size > 2) {
                fruitMap.set(fruits[slow], fruitMap.get(fruits[slow]) - 1);
                if (fruitMap.get(fruits[slow]) === 0) {
                    fruitMap.delete(fruits[slow]);
                }
                slow += 1;
            }
            tempRes = fast - slow + 1;
        }
        fast += 1;
    }
    return res;
};
```

### 76. 最小覆盖子串

[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/description/)

***python***

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = {}
        for c in t:
            if c in need:
                need[c] += 1
            else:
                need[c] = 1
        left, right, start_index = 0, 0, 0
        length = 100001
        invalid = len(need)

        while right < len(s):
            # 扩大窗口
            if s[right] in need:
                need[s[right]] -= 1
                if need[s[right]] == 0:
                    invalid -= 1
            right += 1

            while invalid == 0:
                # 缩小窗口
                if s[left] in need:
                    need[s[left]] += 1
                    if need[s[left]] > 0:
                        invalid += 1
                        if right - left < length: # 收获结果
                            start_index = left
                            length = right - left
                left += 1
        return "" if length == 100001 else s[start_index:start_index + length]
        
```

***cpp***

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> umap;
        for (char c : t)
            umap[c]++;
        int left = 0, right = 0; // [)
        int invalid = umap.size();
        int start_index = 0, length = 100001;
        while (right < s.size()) {
            // 扩大窗口
            auto it = umap.find(s[right++]);
            if (it != umap.end()) {
                --it->second;
                if (it->second == 0)
                    invalid--;
            }

            // 收缩窗口
            while (invalid == 0) {
                auto it = umap.find(s[left]);
                if (it != umap.end()) {
                    ++it->second;
                    if (it->second > 0) {
                        invalid++;
                        if (right - left < length) { // 收获结果
                            start_index = left;
                            length = right - left;
                        }
                    }
                }
                ++left;
            }
        }
        return length == 100001 ? "" : s.substr(start_index, length);
    }
};
```

***js***

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
    let umap = new Map();
    for (let c of t) {
        umap.set(c, (umap.get(c) || 0) + 1);
    }
    let left = 0, right = 0;
    let invalid = umap.size;
    let start_index = 0, length = 100001;

    while (right < s.length) {
        // 扩大窗口
        let char = s[right++];
        if (umap.has(char)) {
            umap.set(char, umap.get(char) - 1);
            if (umap.get(char) === 0) {
                invalid--;
            }
        }

        // 收缩窗口
        while (invalid === 0) {
            let charLeft = s[left];
            if (umap.has(charLeft)) {
                umap.set(charLeft, umap.get(charLeft) + 1);
                if (umap.get(charLeft) > 0) {
                    invalid++;
                    if (right - left < length) { // 收获结果
                        start_index = left;
                        length = right - left;
                    }
                }
            }
            left++;
        }
    }
    return length === 100001 ? "" : s.substr(start_index, length);
};
```

### 59. 螺旋矩阵 II

[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/description/)

***python***

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0] * n for _ in range(n)] # 二维数组
        left_bound, right_bound = 0, n - 1
        up_bound, down_bound = 0, n - 1
        count = 1

        while count <= n * n:
            # 上边
            for j in range(left_bound, right_bound + 1):
                res[up_bound][j] = count
                count += 1
            up_bound += 1

            # 右边
            for i in range(up_bound, down_bound + 1):
                res[i][right_bound] = count
                count += 1
            right_bound -= 1

            # 下边
            for j in range(right_bound, left_bound - 1, - 1):
                res[down_bound][j] = count
                count += 1
            down_bound -= 1

            # 左边
            for i in range(down_bound, up_bound - 1, -1):
                res[i][left_bound] = count
                count += 1
            left_bound += 1

        return res
```

***cpp***

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n));
        int leftBound = 0, rightBound = n - 1;
        int upBound = 0, downBound = n - 1;
        int count = 1;
        while (count <= n * n) {
            // 上边
            for (int j = leftBound; j <= rightBound; ++j)
                res[upBound][j] = count++;
            upBound++;

            // 右边
            for (int i = upBound; i <= downBound; ++i)
                res[i][rightBound] = count++;
            rightBound--;

            // 下边
            for (int j = rightBound; j >= leftBound; --j)
                res[downBound][j] = count++;
            downBound--;

            // 左边
            for (int i = downBound; i >= upBound; --i)
                res[i][leftBound] = count++;
            leftBound++;
        }
        return res;
    }
};
```

***js***

```js
/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function (n) {
    let res = new Array(n).fill().map(() => new Array(n).fill(0));
    let leftBound = 0, rightBound = n - 1;
    let upBound = 0, downBound = n - 1;
    let count = 1;

    while (count <= n * n) {
        // 上边
        for (let j = leftBound; j <= rightBound; j++)
            res[upBound][j] = count++;
        upBound++;

        // 右边
        for (let i = upBound; i <= downBound; i++)
            res[i][rightBound] = count++;
        rightBound--;

        // 下边
        for (let j = rightBound; j >= leftBound; j--)
            res[downBound][j] = count++;
        downBound--;

        // 左边
        for (let i = downBound; i >= upBound; i--)
            res[i][leftBound] = count++;
        leftBound++;
    }
    return res;
};
```

### 54. 螺旋矩阵

[54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/description/)

***python***

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        m, n = len(matrix), len(matrix[0])
        up_bound, down_bound = 0, m - 1
        left_bound, right_bound = 0, n - 1

        while up_bound <= down_bound and left_bound <= right_bound:
            # 上边
            for j in range(left_bound, right_bound + 1):
                res.append(matrix[up_bound][j])
            up_bound += 1
            if up_bound > down_bound:
                break
            
            # 右边
            for i in range(up_bound, down_bound + 1):
                res.append(matrix[i][right_bound])
            right_bound -= 1
            if left_bound > right_bound:
                break
            
            # 下边
            for j in range(right_bound, left_bound - 1, -1):
                res.append(matrix[down_bound][j])
            down_bound -= 1

            # 左边
            for i in range(down_bound, up_bound - 1, -1):
                res.append(matrix[i][left_bound])
            left_bound += 1
        return res
            
```

***cpp***

```cpp
class Solution {
  public:
  vector<int> spiralOrder(vector<vector<int>>& matrix) {
    vector<int> res;
    int m = matrix.size(), n = matrix[0].size();  // 行 列
    int up_bound = 0, down_bound = m - 1;
    int left_bound = 0, right_bound = n - 1;
    while (up_bound <= down_bound && left_bound <= right_bound)
    {
      // 上
      for (int j = left_bound; j <= right_bound; j++)
        res.push_back(matrix[up_bound][j]);
      up_bound++;
      if (up_bound > down_bound) break;

      // 右
      for (int i = up_bound; i <= down_bound; i++)
        res.push_back(matrix[i][right_bound]);
      right_bound--;
      if (left_bound > right_bound) break;

      // 下
      for (int j = right_bound; j >= left_bound; j--)
        res.push_back(matrix[down_bound][j]);
      down_bound--;

      // 左
      for (int i = down_bound; i >= up_bound; i--)
        res.push_back(matrix[i][left_bound]);
      left_bound++;
    }
    return res;
  }
};
```

***js***

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function (matrix) {
    let res = [];
    let m = matrix.length, n = matrix[0].length;
    let upBound = 0, downBound = m - 1;
    let leftBound = 0, rightBound = n - 1;

    while (upBound <= downBound && leftBound <= rightBound) {
        // 上
        for (let j = leftBound; j <= rightBound; j++) {
            res.push(matrix[upBound][j]);
        }
        upBound++;
        if (upBound > downBound) break;

        // 右
        for (let i = upBound; i <= downBound; i++) {
            res.push(matrix[i][rightBound]);
        }
        rightBound--;
        if (leftBound > rightBound) break;

        // 下
        for (let j = rightBound; j >= leftBound; j--) {
            res.push(matrix[downBound][j]);
        }
        downBound--;

        // 左
        for (let i = downBound; i >= upBound; i--) {
            res.push(matrix[i][leftBound]);
        }
        leftBound++;
    }
    return res;
};
```

### 剑指Offer 29. 顺时针打印矩阵

[剑指Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/)

同 [54. 螺旋矩阵](#54-螺旋矩阵)

### 167. 两数之和 II - 输入有序数组

[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/)

***python***

```python
# 左右指针
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers) - 1
        while left < right:
            sum = numbers[left] + numbers[right]
            if sum == target:
                return [left + 1, right + 1]
            elif sum < target:
                left += 1
            else:
                right -= 1
        return [-1, -1]

# 哈希
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        umap = {}
        for i, num in enumerate(numbers):
            if target - num in umap:
                return [umap[target - num] + 1, i + 1]
            umap[num] = i
```

***cpp***

```cpp
// 左右指针
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(target == sum) return vector<int> {left+1,right+1};
            else if(target < sum) right--;
            else left++;
        }
        return vector<int> {-1,-1};
    }
};

// 哈希
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        unordered_map<int, int> umap;
        for (int i = 0 ; i < numbers.size(); i++){
            auto it = umap.find(target - numbers[i]);
            if(it != umap.end()) return vector<int> {it->second + 1, i + 1};
            umap[numbers[i]] = i;
        }
        return vector<int> {-1, -1};
    }
};
```

***js***

```js
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
// 左右指针
var twoSum = function (numbers, target) {
    let left = 0, right = numbers.length - 1;
    while (left < right) {
        let sum = numbers[left] + numbers[right];
        if (target === sum) {
            return [left + 1, right + 1];
        } else if (target < sum) {
            right--;
        } else {
            left++;
        }
    }
    return [-1, -1];
};

// 哈希
var twoSum = function (numbers, target) {
    let umap = new Map();
    for (let i = 0; i < numbers.length; i++) {
        if (umap.has(target - numbers[i])) {
            return [umap.get(target - numbers[i]) + 1, i + 1];
        }
        umap.set(numbers[i], i);
    }
};
```

### 344. 反转字符串

[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/description/)

***python***

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

***cpp***

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int i = 0, j = s.size() - 1;
        while (i < j)
            swap(s[i++], s[j--]);
    }
};
```

***js***

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function (s) {
    let i = 0, j = s.length - 1;
    while (i < j) {
        [s[i], s[j]] = [s[j], s[i]];
        i++;
        j--;
    }
};
```

### 5. 最长回文子串

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/description/)

***python***

```python
class Solution:
    def extend(self, s: str, i: int, j: int) -> int:
        res = 0
        while i >= 0 and j < len(s) and s[i] == s[j]:
            if i != j:
                res += 2
            else:
                res += 1
            i -= 1
            j += 1
        return res

    def longestPalindrome(self, s: str) -> str:
        length = 1
        start_index = 0
        for i in range(len(s)):
            length1 = self.extend(s, i, i)
            length2 = self.extend(s, i, i + 1)
            length = max(length, length1, length2)
            if length == length1:
                start_index = i - (length1 - 1) // 2
            elif length == length2:
                start_index = i - length2 // 2 + 1
        return s[start_index : start_index + length]
```

***cpp***

```cpp
class Solution {
private:
  int extend(string &s, int i, int j) {
    int res = 0;
    while (i >= 0 && j < s.size() && s[i] == s[j]) {
      if (i != j)
        res += 2;
      else
        res++;
      i--;
      j++;
    }
    return res;
  }

public:
  string longestPalindrome(string s) {
    int length = 1;
    int startIndex = 0;
    for (int i = 0; i < s.size(); i++) {
      int length1 = extend(s, i, i);
      int length2 = extend(s, i, i + 1);
      length = max({length, length1, length2});
      if (length == length1)
        startIndex = i - (length1 - 1) / 2;
      else if (length == length2)
        startIndex = i - length2 / 2 + 1;
    }
    return s.substr(startIndex, length);
  }
};
```

***js***

```js
/**
 * @param {string} s
 * @return {string}
 */

var extend = function (s, i, j) {
    let res = 0;
    while (i >= 0 && j < s.length && s[i] === s[j]) {
        if (i !== j) {
            res += 2;
        } else {
            res += 1;
        }
        i--;
        j++;
    }
    return res;
}

var longestPalindrome = function (s) {
    let length = 1;
    let startIndex = 0;
    for (let i = 0; i < s.length; i++) {
        let length1 = extend(s, i, i);
        let length2 = extend(s, i, i + 1);
        let lengthTemp = Math.max(length, length1, length2);
        if (lengthTemp === length1) {
            startIndex = i - Math.floor((length1 - 1) / 2);
        } else if (lengthTemp === length2) {
            startIndex = i - Math.floor(length2 / 2) + 1;
        }
        length = lengthTemp;
    }
    return s.substring(startIndex, startIndex + length);
};
```

----------------------------

## 2 链表

### 83. 删除排序链表中的重复元素

[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)

***python***

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        p = head
        while p.next:
            if p.next.val == p.val:
                p.next = p.next.next
            else:
                p = p.next
        return head
```

***cpp***

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head)
            return head;
        ListNode* p = head;
        while (p->next) {
            if (p->next->val == p->val) {
                ListNode* del = p->next;
                p->next = del->next;
                delete del;
            }else
                p = p->next;
        }
        return head;
    }
};
```

***js***

```js
var deleteDuplicates = function (head) {
     if (!head || !head.next) 
        return head;

    let p = head;
    while (p.next) {
        if (p.next.val === p.val) {
            p.next = p.next.next;
        } else {
            p = p.next;
        }
    }
    return head;
};
```


### 203.移除链表元素

[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

***python***
```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummyHead = ListNode(0, head);
        p = dummyHead;
        while p.next:
            if p.next.val == val:
                p.next = p.next.next
            else:
                p = p.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next) {
            if (p->next->val == val) {
                ListNode* temp = p->next;
                p->next = temp->next;
                delete temp;
            } else
                p = p->next;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
var removeElements = function (head, val) {
    const dummyHead = new ListNode(0, head);
    let p = dummyHead;
    while (p.next) {
        if (p.next.val === val) {
            const temp = p.next;
            p.next = temp.next;
            temp.next = null; // Optional: Helps in garbage collection
        } else {
            p = p.next;
        }
    }
    return dummyHead.next;
};
```

### 707. 设计链表

[707. 设计链表](https://leetcode.cn/problems/design-linked-list/description/)

***python***
```python
class ListNode:
    def __init__(self, val = 0,next = None):
        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):
        self.head = None
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        p = self.head
        for _ in range(index):
            p = p.next
        return p.val

    def addAtHead(self, val: int) -> None:
        self.head = ListNode(val, self.head)
        self.size += 1

    def addAtTail(self, val: int) -> None:
        p = self.head
        while p.next:
            p = p.next
        p.next = ListNode(val)
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        p = self.head
        for _ in range(index - 1):
            p = p.next
        p.next = ListNode(val, p.next)
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        p = self.head
        for _ in range(index - 1):
            p = p.next
        p.next = p.next.next
        self.size -= 1



# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

***cpp***
```cpp
class MyLinkedList {
private:
    // 定义链表
    struct ListNode {
        int val;
        ListNode* next;
        ListNode() : val(0), next(nullptr) {}
        ListNode(int x) : val(x), next(nullptr) {}
        ListNode(int x, ListNode* next) : val(x), next(next) {}
    };

    ListNode* _dummyHead;
    int _size;

public:
    MyLinkedList() {
        _dummyHead = new ListNode();
        _size = 0;
    }

    int get(int index) {
        if (index < 0 || index >= _size)
            return -1;
        ListNode* p = _dummyHead->next;
        while (index--)
            p = p->next;
        return p->val;
    }

    void addAtHead(int val) {
        ListNode* p = new ListNode(val, _dummyHead->next);
        _dummyHead->next = p;
        ++_size;
    }

    void addAtTail(int val) {
        ListNode* p = _dummyHead;
        while (p->next)
            p = p->next;
        p->next = new ListNode(val);
        ++_size;
    }

    void addAtIndex(int index, int val) {
        ListNode* p = _dummyHead;
        if (index < 0 || index > _size)
            return;
        while (index--)
            p = p->next;
        ListNode* temp = new ListNode(val, p->next);
        p->next = temp;
        ++_size;
    }

    void deleteAtIndex(int index) {
        if (index < 0 || index >= _size)
            return;
        ListNode* p = _dummyHead;
        while (index--)
            p = p->next;
        ListNode* temp = p->next;
        p->next = p->next->next;
        delete temp;
        --_size;
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

***js***
```js
var ListNode = function (val = 0, next = null) {
    this.val = val;
    this.next = next;
};

var MyLinkedList = function () {
    this._dummyHead = new ListNode();
    this._size = 0;
};

/** 
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.get = function (index) {
    if (index < 0 || index >= this._size)
        return -1;
    let p = this._dummyHead.next;
    while (index--)
        p = p.next;
    return p.val;
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function (val) {
    const p = new ListNode(val, this._dummyHead.next);
    this._dummyHead.next = p;
    this._size++;
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function (val) {
    let p = this._dummyHead;
    while (p.next)
        p = p.next;
    p.next = new ListNode(val);
    this._size++;
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function (index, val) {
    if (index < 0 || index > this._size)
        return;
    let p = this._dummyHead;
    while (index--)
        p = p.next;
    const temp = new ListNode(val, p.next);
    p.next = temp;
    this._size++;
};

/** 
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function (index) {
    if (index < 0 || index >= this._size)
        return;
    let p = this._dummyHead;
    while (index--)
        p = p.next;
    p.next = p.next.next;
    this._size--;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * var obj = new MyLinkedList()
 * var param_1 = obj.get(index)
 * obj.addAtHead(val)
 * obj.addAtTail(val)
 * obj.addAtIndex(index,val)
 * obj.deleteAtIndex(index)
 */
```

### 206.反转链表

[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

***python***
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# 逐个节点反转
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre, cur = None, head
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre

# 递归
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head
        
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```

***cpp***
```cpp
// 逐个翻转每个节点的指向
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr;
        ListNode *cur = head;
        while (cur)
        {
            ListNode *temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};

// 递归
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr || head->next == nullptr) return head;
        ListNode *last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};
```

***js***
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
// 逐个节点反转
var reverseList = function (head) {
    let pre = null;
    let cur = head;
    while (cur) {
        const temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
};

// 递归
var reverseList = function (head) {
    if (head === null || head.next === null)
        return head;

    const last = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return last;
};
```

### 92. 反转链表 II

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

***python***
```python
# 迭代法
class Solution:
    def reverseBetween(
        self, head: Optional[ListNode], left: int, right: int
    ) -> Optional[ListNode]:
        if left == right:
            return head
        dummyHead = ListNode(0, head)
        p = dummyHead
        for _ in range(left - 1):
            p = p.next
        # 此时 p 指向 left 的前驱
        pre, cur = p.next, p.next.next
        for _ in range(right - left):
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        p.next.next = cur
        p.next = pre
        return dummyHead.next

# 递归
class Solution:
    backup = None  # right 的后继

    def reverse(self, q, count, right):
        if count == right:
            self.backup = q.next
            return q
        count += 1
        last = self.reverse(q.next, count, right)
        q.next.next = q  # 调转指向
        q.next = self.backup  # 指向 right 的后继
        return last

    def reverseBetween(
        self, head: Optional[ListNode], left: int, right: int
    ) -> Optional[ListNode]:
        if left == right:
            return head
        dummyHead = ListNode(0, head)
        p = dummyHead
        for _ in range(1, left):
            p = p.next
        # 此时 p 指向 left 的前驱
        p.next = self.reverse(p.next, left, right)
        return dummyHead.next
```

***cpp***
```cpp
// 迭代法
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if (left == right)
            return head;

        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        int count = left - 1;
        while (count--) // p 指向 left 的前驱
            p = p->next;
        ListNode* pre = p->next;
        ListNode* cur = pre->next;
        count = right - left;
        while (count--) {
            ListNode* count = cur->next;
            cur->next = pre;
            pre = cur;
            cur = count;
        }
        p->next->next = cur;
        p->next = pre;
        return dummyHead->next;
    }
};

// 递归
class Solution {
public:
    ListNode* backup = nullptr;     // right 的后继
    ListNode* reverse(ListNode* q, int& count, const int& right) {
        if (count == right) {
            backup = q->next;
            return q;
        }
        ++count;
        ListNode* last = reverse(q->next, count, right);
        q->next->next = q;      // 调转指向
        q->next = backup;       // 指向 right 的后继
        return last;
    }

    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if (left == right)
            return head;
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        for (int count = 1; count < left; count++)
            p = p->next;
        // 此时 p 指向 left 的前驱
        p->next = reverse(p->next, left, right);
        return dummyHead->next;
    }
};
```

***js***
```js

```

### 25. K 个一组翻转链表

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)

***python***
```python
class Solution:
    def reverse(self, head: ListNode, tail: ListNode):  # [)
        pre, cur = None, head
        while cur != tail:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre

    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        p = q = head
        for _ in range(k):
            if q == None:
                return head
            q = q.next
        # 此时 q 指向下一组的头节点
        last = self.reverse(p, q)
        p.next = self.reverseKGroup(q, k)
        return last
```

***cpp***
```cpp
class Solution {
private:
  ListNode* reverse(ListNode* a, ListNode* b) { // [)
    ListNode* pre = nullptr;
    ListNode *cur = a, *next = a;
    while (cur != b) {
      next = cur->next;
      cur->next = pre;
      pre = cur;
      cur = next;
    }
    return pre;
  }

public:
  ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr) return head;
    ListNode *a, *b;
    a = b = head;
    for (int i = 0; i < k; i++) {
      if (b == nullptr) return head;
      b = b->next;
    }

    // 此时 b 指向下一组的头节点
    ListNode* newHead = reverse(a, b);
    a->next = reverseKGroup(b, k);
    return newHead;
  }
};
```

***js***
```js
```

### 24. 两两交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

***python***
```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(0, head)
        p = dummyHead
        while p.next and p.next.next:
            temp = p.next
            p.next = temp.next
            temp.next = temp.next.next
            p.next.next = temp
            p = temp
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next && p->next->next) {
            ListNode* temp = p->next;
            p->next = temp->next;
            temp->next = temp->next->next;
            p->next->next = temp;
            p = temp;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 19.删除链表的倒数第N个节点

[19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

***python***
```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummyHead = ListNode(0, head)
        slow, fast = dummyHead, head
        for _ in range(n):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
  ListNode *removeNthFromEnd(ListNode *head, int n) {
    ListNode *dummyHead = new ListNode(0, head);
    ListNode *fast = dummyHead;
    ListNode *slow = dummyHead;
    while (n-- >= 0) // 走 n + 1 步
      fast = fast->next;

    while (fast) {
      fast = fast->next;
      slow = slow->next;
    }

    ListNode *del = slow->next;
    slow->next = del->next;
    delete del;
    return dummyHead->next;
  }
};
```

***js***
```js
```

### 面试题 02.07. 链表相交

[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

***python***
```python
# 方法一：提前记载各自长度
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p = headA
        countA = countB = 0
        while p:
            p = p.next
            countA += 1

        p = headB
        while p:
            p = p.next
            countB += 1

        if countA == 0 or countB == 0:
            return None
        p, q = headA, headB

        if countA < countB:
            p, q = q, p
        # 此时 p 指向长链表
        for _ in range(abs(countA - countB)):
            p = p.next
        while p != q:
            p = p.next
            q = q.next

        return p

# 优雅解法，尾连接
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p, q = headA, headB
        while p != q:
            if p == None:
                p = headB
            else:
                p = p.next

            if q == None:
                q = headA
            else:
                q = q.next

        return q
```

***cpp***
```cpp
// 方法一：提前记载各自长度
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode* p = headA;
        int countA = 0, countB = 0;
        while (p) {
            p = p->next;
            ++countA;
        }
        p = headB;
        while (p) {
            p = p->next;
            ++countB;
        }
        if (countA == 0 || countB == 0)
            return nullptr;
        p = headA;
        ListNode* q = headB;
        if (countA < countB)
            swap(q, p);
        // 此时 p 指向长链表
        int temp = abs(countA - countB);
        while (temp--)
            p = p->next;
        while (p != q) {
            p = p->next;
            q = q->next;
        }
        return q;
    }
};

// 巧妙，尾连接
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode *p = headA, *q = headB;
        while (p != q) {
            if (p == nullptr) p = headB;
            else p = p->next;

            if (q == nullptr) q = headA;
            else q = q->next;
        }
        return q;
    }
};
```

***js***
```js
```

### 141. 环形链表

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)

***python***
```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

***cpp***
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        while (fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) return true;
        }
        return false;
    }
};
```

***js***
```js
```

### 142.环形链表II

[142.环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

***python***
```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

            if fast == slow:
                p, q = fast, head
                while p != q:
                    p = p.next
                    q = q.next
                return q
        return None
```

***cpp***
```cpp
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode *fast = head, *slow = head;

        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;

            if (fast == slow) {
                ListNode* p = fast;
                ListNode* q = head;
                while (q != p) {
                    q = q->next;
                    p = p->next;
                }
                return q;
            }
        }
        return nullptr;
    }
};
```

***js***
```js
```

### 21. 合并两个有序链表

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

***python***
```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(0, list1)
        p, q = dummyHead, list2
        while p.next and q:
            if q.val <= p.next.val:
                cur = q
                q = q.next
                cur.next = p.next
                p.next = cur
            p = p.next

        if q:
            p.next = q
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummyHead = new ListNode(0, list1);
        ListNode *p = dummyHead, *q = list2;
        while (p->next && q) {
            if (q->val <= p->next->val) {
                ListNode* cur = q;
                q = q->next;
                cur->next = p->next;
                p->next = cur;
            }
            p = p->next;
        }
        if (q)
            p->next = q;
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 23. 合并 K 个升序链表

[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

***python***
```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        p = dummyHead = ListNode(0)
        heap = []
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(heap, (lists[i].val, i))
                lists[i] = lists[i].next

        while heap:
            val, idx = heapq.heappop(heap)
            p.next = ListNode(val)
            p = p.next
            if lists[idx]:
                heapq.heappush(heap, (lists[idx].val, idx))
                lists[idx] = lists[idx].next

        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    struct compare { // 小顶堆
        bool operator()(const ListNode* const& l, const ListNode* const& r) {
            return l->val > r->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty())
            return nullptr;
        ListNode* dummyHead = new ListNode(0);
        ListNode* p = dummyHead;

        priority_queue<ListNode*, vector<ListNode*>, compare> pq;
        for (auto head : lists) // 将 k 个头结点入队
            if (head)
                pq.push(head);

        while (!pq.empty()) {
            ListNode* cur = pq.top();
            pq.pop();
            if (cur->next)
                pq.push(cur->next);
            p->next = cur;
            p = p->next;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 86. 分隔链表

[86. 分隔链表](https://leetcode.cn/problems/partition-list/description/)

***python***
```python
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        p = dummyHead = ListNode(0, head)
        while p.next and p.next.val < x:
            p = p.next

        q = p.next
        while q and q.next:
            if q.next.val < x:
                cur = q.next
                q.next = cur.next
                cur.next = p.next
                p.next = cur
                p = cur
            else:
                q = q.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next && p->next->val < x)
            p = p->next;

        ListNode* q = p->next; // 此时 q 指向右半节点的头，p 指向左半节点的头
        while (q && q->next)
            if (q->next->val < x) {
                ListNode* cur = q->next;
                q->next = cur->next;
                cur->next = p->next;
                p->next = cur;
                p = cur;
            } else
                q = q->next;

        return dummyHead->next;
    }
};
```

***js***
```js
```

### 876. 链表的中间结点

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)

***python***
```python
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
```

***cpp***
```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *fast = head, *slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

***js***
```js
```

### 234. 回文链表
[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/)

***python***
```python
# 借用空间
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        p = head
        arr = []
        while p:
            arr.append(p.val)
            p = p.next
        left, right = 0, len(arr) - 1
        while left <= right:
            if arr[left] != arr[right]:
                return False
            left += 1
            right -= 1
        return True

# 递归 (dfs)
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        self.p = head
        def dfs(head: Optional[ListNode]) -> bool:
            if head is None:
                return True

            if not dfs(head.next):
                return False

            if self.p.val != head.val:
                return False

            self.p = self.p.next
            return True

        return dfs(head)

# 双指针 + 反转链表
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        if fast:
            slow = slow.next

        # 翻转后半部分链表
        pre, cur = None, slow
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp

        while pre:
            if pre.val != head.val:
                return False
            pre = pre.next
            head = head.next
        return True
```

***cpp***
```cpp
// 借用空间
class Solution {
  public:
  bool isPalindrome(ListNode *head) {
    vector<int> vec;
    ListNode *p = head;
    while (p) {
      vec.push_back(p->val);
      p = p->next;
    }
    int left = 0, right = vec.size() - 1;
    while (left < right)
      if (vec[left++] != vec[right--]) return false;
    return true;
  }
};

// 递归 （dfs）
class Solution {
private:
    ListNode* p, *headback;
    bool dfs(ListNode* head) {
        if (head == nullptr || (p != headback && p == head))   // 剪枝，到中间就返回
            return true;

        bool res1 = dfs(head->next);
        bool res2 = head->val == p->val;
        p = p->next;
        return res1 && res2;
    }

public:
    bool isPalindrome(ListNode* head) {
        headback = p = head;
        return dfs(head);
    }
};

// 双指针 + 反转链表
class Solution {
public:
  bool isPalindrome(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
    }
    if (fast) slow = slow->next;

    // 翻转后半部分链表
    ListNode *pre = nullptr, *cur = slow, *nex = slow;
    while (cur) {
      nex = cur->next;
      cur->next = pre;
      pre = cur;
      cur = nex;
    }
    while (pre) {
      if (pre->val != head->val) return false;
      pre = pre->next;
      head = head->next;
    }
    return true;
  }
};
```

***js***
```js
```

------------------------------

## 3 哈希表

### 242.有效的字母异位词

[242.有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/)

***python***
```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        arr = [0] * 26
        for c in s:
            arr[ord(c) - ord('a')] += 1     # ord() 用来获取字符的 ASCII 码

        for c in t:
            arr[ord(c) - ord('a')] -= 1

        for num in arr:
            if num:
                return False

        return True
```

***cpp***
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size())
            return false;
        int a[26] = {0};
        for (char ch : s)
            ++a[ch - 'a'];
        for (char ch : t)
            --a[ch - 'a'];
        
        for (int i = 0; i < 26; ++i)
            if (a[i])
                return false;
        
        return true;
    }
};
```

### 383. 赎金信

[383. 赎金信](https://leetcode.cn/problems/ransom-note/description/)

***python***
```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        arr = [0] * 26
        for c in magazine:
            arr[ord(c) - ord("a")] += 1

        for c in ransomNote:
            arr[ord(c) - ord("a")] -= 1

        for num in arr:
            if num < 0:
                return False

        return True
```


***cpp***
```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        for (char ch : magazine)
            ++record[ch - 'a'];
        
        for (char ch : ransomNote)
            --record[ch - 'a'];
        
        for (int i = 0; i < 26; ++i)
            if (record[i] < 0)
                return false;
        
        return true;
    }
};
```

### 49. 字母异位词分组

[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)

***python***
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        umap = {}
        for string in strs:
            sorted_str = "".join(sorted(string))    # 排序后的字符串作为 key
            if sorted_str not in umap:
                umap[sorted_str] = []
            umap[sorted_str].append(string)

        return list(umap.values())  # 返回字典的值, 并转换为列表
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> umap;
        for (const string& str : strs) {
            string temp = str;
            sort(temp.begin(), temp.end());
            umap[temp].emplace_back(str);
        }
        vector<vector<string>> res;
        for (auto it = umap.begin(); it != umap.end(); ++it)
            res.push_back(it->second);
        return res;
    }
};
```

### 438. 找到字符串中所有字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

***python***
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        umap = {}
        res = []
        for c in p:
            if c not in umap:
                umap[c] = 0
            umap[c] += 1

        invalid = len(umap)
        left = right = 0  # [)
        while right < len(s):
            c = s[right]  # 扩大窗口
            right += 1
            if c in umap:
                umap[c] -= 1
                if umap[c] == 0:
                    invalid -= 1

            if right - left == len(p):
                if invalid == 0:
                    res.append(left)  # 收结果
                d = s[left]
                left += 1  # 收缩窗口
                if d in umap:
                    if umap[d] == 0:
                        invalid += 1
                    umap[d] += 1

        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        if (s.size() < p.size())
            return res;
        unordered_map<char, int> umap;
        for (const char& c : p)
            ++umap[c];
        int invalid = umap.size();
        int left = 0, right = 0; // [)
        while (right < s.size()) {
            char c = s[right++]; // 扩大窗口
            if (umap.find(c) != umap.end()) {
                --umap[c];
                if (umap[c] == 0)
                    --invalid;
            }

            if (right - left == p.size()) {
                if (invalid == 0)
                    res.emplace_back(left); // 收结果
                char d = s[left++];         // 缩小窗口
                if (umap.find(d) != umap.end()) {
                    if (umap[d] == 0)
                        ++invalid;
                    ++umap[d];
                }
            }
        }
        return res;
    }
};
```

### 349. 两个数组的交集

[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

***python***
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        my_set = set(nums1)
        res = []

        for num in nums2:
            if num in my_set:
                res.append(num)
                my_set.remove(num)

        return res
```

***cpp***
```cpp
class Solution{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2){
        unordered_set<int> mySet;
        vector<int> res;

        for (int num1 : nums1)
            mySet.insert(num1);
        for (int num2 : nums2)
            if (mySet.find(num2) != mySet.end()){
                res.emplace_back(num2);
                mySet.erase(num2);
            }

        return res;
    }
};
```

### 350. 两个数组的交集 II

[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/)

***python***
```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        umap = {}
        res = []
        for num in nums1:
            if num not in umap:
                umap[num] = 0
            umap[num] += 1

        for num in nums2:
            if num in umap and umap[num]:
                res.append(num)
                umap[num] -= 1

        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> umap;
        vector<int> res;
        for (int num : nums1)
            ++umap[num];

        for (int num : nums2) {
            auto it = umap.find(num);
            if (it != umap.end() && it->second) {
                res.push_back(num);
                --(it->second);
            }
        }
        return res;
    }
};
```

### 202. 快乐数

[202. 快乐数](https://leetcode.cn/problems/happy-number/description/)

***python***
```python
class Solution:
    def isHappy(self, n: int) -> bool:
        num_set = set()
        while n != 1:
            num_set.add(n)
            sum_of_digits = 0
            while n:
                sum_of_digits += (n % 10) * (n % 10)
                n //= 10
            if sum_of_digits in num_set:
                return False
            n = sum_of_digits
        return True
```

***cpp***
```cpp
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> uset;
        while (n != 1) {
            uset.insert(n);
            int sum = 0;
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            if (uset.count(sum))
                return false;
            n = sum;
        }
        return true;
    }
};
```

### 1. 两数之和

[1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

***python***
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        umap = {}
        for idx, num in enumerate(nums):
            if target - num in umap:
                return [umap[target - num], idx]
            umap[num] = idx
```

***cpp***
```cpp
class Solution {
public:
  vector<int> twoSum(vector<int> &nums, int target) {
    unordered_map<int, int> umap;
    for (int i = 0; i < nums.size(); i++) {
      auto it = umap.find(target - nums[i]);
      if (it != umap.end())
        return {it->second, i};
      umap.insert({nums[i], i});
    }
    return {-1, -1};
  }
};
```

### 454. 四数相加II

[454. 四数相加II](https://leetcode.cn/problems/4sum-ii/description/)

***python***
```python
class Solution:
    def fourSumCount(
        self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]
    ) -> int:
        umap = {}
        res = 0
        for n1 in nums1:
            for n2 in nums2:
                temp = n1 + n2
                if temp not in umap:
                    umap[temp] = 0
                umap[temp] += 1

        for n3 in nums3:
            for n4 in nums4:
                temp = -n3 -n4
                if temp in umap:
                    res += umap[temp]

        return res
```

***cpp***
```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,
                     vector<int>& nums4) {
        unordered_map<int, int> umap;
        int res = 0;
        for (int num1 : nums1)
            for (int num2 : nums2)
                ++umap[num1 + num2];

        for (int num3 : nums3)
            for (int num4 : nums4) {
                auto it = umap.find(-num3 - num4);
                if (it != umap.end())
                    res += it->second;
            }

        return res;
    }
};
```

### 15. 三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/description/)

***python***
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        i = 0
        while i < len(nums):
            if nums[i] > 0:
                break
            left, right = i + 1, len(nums) - 1
            while left < right:
                if nums[i] + nums[left] == -nums[right]:
                    res.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif nums[i] + nums[left] < -nums[right]:
                    left += 1
                else:
                    right -= 1
            while i < len(nums) - 1 and nums[i] == nums[i + 1]:
                i += 1
            i += 1
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] > 0)
                break;
            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                if (nums[i] + nums[left] == -nums[right]) {
                    res.push_back(
                        vector<int>{nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1])
                        ++left;
                    while (left < right && nums[right] == nums[right - 1])
                        --right;
                    ++left;
                    --right;
                } else if (nums[i] + nums[left] < -nums[right])
                    ++left;
                else
                    --right;
            }
            while (i < nums.size() - 1 && nums[i] == nums[i + 1])
                ++i;
        }
        return res;
    }
};
```

### 18. 四数之和

[18. 四数之和](https://leetcode.cn/problems/4sum/description/)

***python***
```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        res = []
        nums.sort()
        i, j = 0, 1
        while i < len(nums):
            sum = nums[i]
            if sum > 0 and sum > target:    # 剪枝
                return res
            j = i + 1
            while j < len(nums):
                sum = nums[i] + nums[j]
                if sum > 0 and sum > target:    # 剪枝
                    break
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[i] + nums[j] == target - nums[left] - nums[right]:
                        res.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        left += 1
                        right -= 1
                    elif nums[i] + nums[j] < target - nums[left] - nums[right]:
                        left += 1
                    else:
                        right -= 1
                while j < len(nums) - 1 and nums[j] == nums[j + 1]:
                    j += 1
                j += 1
            while i < len(nums) - 1 and nums[i] == nums[i + 1]:
                i += 1
            i += 1
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < (int)nums.size() - 3; i++) {
            int sum = nums[i];
            if (sum > 0 && sum > target) // 剪枝
                return res;
            if (i > 0 && nums[i] == nums[i - 1])
                continue;

            for (int j = i + 1; j < (int)nums.size() - 2; ++j) {
                sum = nums[i] + nums[j];
                if (sum > 0 && sum > target) // 剪枝
                    break;
                if (j > i + 1 && nums[j] == nums[j - 1])
                    continue;

                int left = j + 1;
                int right = nums.size() - 1;
                while (left < right) {
                    if ((long)nums[i] + nums[j] <
                        (long)target - nums[left] - nums[right])
                        ++left;
                    else if ((long)nums[i] + nums[j] >
                             (long)target - nums[left] - nums[right])
                        --right;
                    else {
                        res.emplace_back(vector<int>{nums[i], nums[j],
                                                     nums[left], nums[right]});
                        ++left;
                        --right;
                        while (left < right && nums[left] == nums[left - 1])
                            ++left;
                        while (left < right && nums[right] == nums[right + 1])
                            --right;
                    }
                }
            }
        }
        return res;
    }
};
```


----------------------------------------

## 4 字符串

### 344. 反转字符串

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)

***python***
```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

***cpp***
```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0, right = s.size() - 1;
        while (left < right)
            swap(s[left++], s[right--]);
    }
};
```

### 541. 反转字符串II

[541. 反转字符串II](https://leetcode.cn/problems/reverse-string-ii/description/)

***python***
```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        def reverseString(s: str, left, right) -> str:
            s_list = list(s)
            while left < right:
                s_list[left], s_list[right] = s_list[right], s_list[left]
                left += 1
                right -= 1
            return "".join(s_list)

        left, right = 0, k  # [)
        for _ in range(len(s) // (2 * k)):
            s = reverseString(s, left, right - 1)
            left += 2 * k
            right += 2 * k

        if right >= len(s):
            s = reverseString(s, left, len(s) - 1)
        else:
            s = reverseString(s, left, right - 1)
        return s
```

***cpp***
```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        int count = s.size() / (2 * k);
        int left, right;
        for (left = 0, right = k; count; --count) {
            reverse(s.begin() + left, s.begin() + right);
            left += (2 * k);
            right = left + k;
        }
        right > s.size() ? reverse(s.begin() + left, s.end())
                         : reverse(s.begin() + left, s.begin() + right);
        return s;
    }
};
```

### 替换数字（第八期模拟笔试）

[替换数字（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1064)

***python***
```python
s = input()

res = ""
for ch in s:
    if ch.isdigit():
        res += "number"
    else:
        res += ch

print(res)
```

***cpp***
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
  string s;
  cin >> s;

  string res;
  for (auto ch : s) {
    if (isdigit(ch))
      res += "number";
    else
      res.push_back(ch);
  }
  cout << res;
  return 0;
}
```

### 151. 翻转字符串里的单词

[151. 翻转字符串里的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

***python***
```python
s = input()

res = ""
for ch in s:
    if ch.isdigit():
        res += "number"
    else:
        res += ch

print(res)
```

***cpp***
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
  string s;
  cin >> s;

  string res;
  for (auto ch : s) {
    if (isdigit(ch))
      res += "number";
    else
      res.push_back(ch);
  }
  cout << res;
  return 0;
}
```

### 55. 右旋字符串（第八期模拟笔试）

[55. 右旋字符串（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1065)

***python***
```python
def rotate_string(s, k):
    k %= len(s)  # Ensure k is within the bounds of the string length
    s = s[::-1]  # Reverse the entire string
    s = s[:k][::-1] + s[k:][::-1]  # Reverse the first k characters and the remaining characters separately
    return s

# Input
k = int(input())
s = input()

# Output the rotated string
print(rotate_string(s, k))

```

***cpp***
```cpp
#include <algorithm>
#include <iostream>
#include <string>

using namespace std;

int main() {
  int k;
  string s;
  cin >> k >> s;
  k %= s.size();
  reverse(s.begin(), s.end());
  reverse(s.begin(), s.begin() + k);
  reverse(s.begin() + k, s.end());
  cout << s << endl;
  return 0;
}
```

### 28. 找出字符串中第一个匹配项的下标

#### KMP

`search(char pat[], char txt[])` 函数用于在字符串 `txt` 中查找字符串 `pat`，假设 `txt.size() > pat.size()`

KMP 算法对 `pat[]` 进行预处理，得到 `next[]` 数组，`next[i]` 表示 `pat[0..i]` 的**最长真前缀后缀匹配长度**，所谓**真**是指不允许包含整个字符串的前缀

**预处理（求 `next[]` 数组）算法**
- 计算 `next[]` 中的值。为此，跟踪前一个索引的最长前缀后缀值得长度（使用 `len` 变量）
- `next[0]` 和 `len` 都初始化为 `0`
- 如果 `pat[len]` 和 `pat[i]` 匹配，将 `len` 加 `1`，并将增加后的值赋给 `lps[i]`
- 如果 `pat[i]` 和 `pat[len]` 不匹配并且 `len` 不为 `0`，我们将 `len` 更新为 `lps[len-1]`


**KMP 算法的实现**

使用 `next[]` 中的值来决定下一个要匹配的字符，不匹配那些我们知道无论如何都会匹配的字符

- `txt[i]` 和 `pat[j]` 做匹配
- 如果**匹配**，`i` 和 `j` 都加 `1`
- 如果 `j = pat.size()`，说明找到了匹配项，重置 `j = next[j - 1]` 继续匹配
- 如果**不匹配**，`j = next[j - 1]`

```cpp
class KMP {
public:
  vector<int> KMPSearch(string txt, string pat) {
    vector<int> res;
    vector<int> next = getNext(pat);
    int i = 0, j = 0;
    while (txt.size() - i >= pat.size() - j) {
      if (pat[j] == txt[i]) {
        ++i;
        ++j;
      }
      if (j == pat.size()) {
        res.push_back(i - j);
        j = next[j - 1];
      } else if (i < txt.size() && pat[j] != txt[i]) {
        if (j)
          j = next[j - 1];
        else
          ++i;
      }
    }
    return res;
  }

private:
  vector<int> getNext(const string &pat) {
    vector<int> next(pat.size());
    next[0] = 0;
    int len = 0, i = 1;

    while (i < pat.size())
      if (pat[i] == pat[len])
        next[i++] = ++len;
      else if (len) // if (pat[i] != pat[len] && len != 0)
        len = next[len - 1];
      else // if (pat[i] != pat[len] && len == 0)
        next[i++] = 0;
    return next;
  }
};
```

-----------------------------------


[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

***python***
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def getNext(pat: str):
            next = [0] * len(pat)
            length, i = 0, 1
            while i < len(pat):
                if pat[i] == pat[length]:
                    length += 1
                    next[i] = length
                    i += 1
                else:
                    if length:
                        length = next[length - 1]
                    else:
                        next[i] = 0
                        i += 1
            return next

        next = getNext(needle)
        i, j = 0, 0
        while i < len(haystack):
            if haystack[i] == needle[j]:
                i += 1
                j += 1
            if j == len(needle):
                return i - j
            elif i < len(haystack) and haystack[i] != needle[j]:
                if j:
                    j = next[j - 1]
                else:
                    i += 1
        return -1
```

***cpp***
```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        vector<int> next(needle.size());
        getNext(needle, next);
        int i = 0, j = 0;
        while (haystack.size() - i >= needle.size() - j) {
            if (haystack[i] == needle[j]) {
                ++i;
                ++j;
            }
            if (needle.size() == j)
                return i - j;
            else if (i < haystack.size() && haystack[i] != needle[j]) {
                if (j)
                    j = next[j - 1];
                else
                    ++i;
            }
        }
        return -1;
    }

private:
    void getNext(const string& pat, vector<int>& next) {
        next[0] = 0;
        int len = 0, i = 1;
        while (i < pat.size())
            if (pat[i] == pat[len])
                next[i++] = ++len;
            else if (len)
                len = next[len - 1];
            else
                next[i++] = len;
    }
};
```

### 459.重复的子字符串

[459.重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)

`s` repeated => `s` in `s + s`
`s` no in `s + s` => `s` not repeated

***python***
```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        return (s + s).find(s, 1) != len(s)
```

***cpp***
```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s + s).find(s, 1) != s.size();
    }
};
```

## 5 双指针

### [27. 移除元素](#27-移除元素)
### [344. 反转字符串](#344-反转字符串-1)
### [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试)
### [151. 翻转字符串里的单词](#151-翻转字符串里的单词)
### [206.反转链表](#206反转链表)
### [19.删除链表的倒数第N个节点](#19删除链表的倒数第n个节点)
### [面试题 02.07. 链表相交](#面试题-0207-链表相交)
### [142.环形链表II](#142环形链表ii)
### [15. 三数之和](#15-三数之和)
### [18. 四数之和](#18-四数之和)

## 6 栈与队列

### 232. 用栈实现队列

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

***python***
```python
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def transfer(self):
        while self.s1:
            self.s2.append(self.s1.pop())

    def push(self, x: int) -> None:
        self.s1.append(x)

    def pop(self) -> int:
        if not self.s2:
            self.transfer()
        return self.s2.pop()

    def peek(self) -> int:
        if not self.s2:
            self.transfer()
        return self.s2[-1]

    def empty(self) -> bool:
        return not self.s1 and not self.s2
```

***cpp***
```cpp
class MyQueue {
private:
    stack<int> s1;
    stack<int> s2;

    void transfer() {
        while (!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
    }

public:
    MyQueue() {}

    void push(int x) { s1.push(x); }

    int pop() {
        if (s2.empty())
            transfer();
        int temp = s2.top();
        s2.pop();
        return temp;
    }

    int peek() {
        if (s2.empty())
            transfer();
        return s2.top();
    }

    bool empty() { return s1.empty() && s2.empty(); }
};
```

### 225. 用队列实现栈

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

***python***
```python
class MyStack:

    def __init__(self):
        self.q = deque()

    def push(self, x: int) -> None:
        self.q.append(x)

    def pop(self) -> int:
        for _ in range(len(self.q) - 1):
            self.q.append(self.q.popleft())
        return self.q.popleft()

    def top(self) -> int:
        return self.q[-1]

    def empty(self) -> bool:
        return len(self.q) == 0
```

***cpp***
```cpp
class MyStack {
private:
    queue<int> q;

public:
    MyStack() {}

    void push(int x) { q.push(x); }

    int pop() {
        int size = q.size() - 1;
        while (size--) {
            q.push(q.front());
            q.pop();
        }
        int temp = q.front();
        q.pop();
        return temp;
    }

    int top() { return q.back(); }

    bool empty() { return q.empty(); }
};
```


### 20. 有效的括号

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

***python***
```python
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2:
            return False
        stack = []
        for c in s:
            if c in "([{":
                stack.append(c)
            else:
                if not stack:
                    return False

                top = stack.pop()
                if c == ")" and top != "(":
                    return False
                if c == "]" and top != "[":
                    return False
                if c == "}" and top != "{":
                    return False
        return not stack
```

***cpp***
```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2)
            return false;
        stack<char> st;
        for (char c : s) 
            if (c == '(' || c == '[' || c == '{')
                st.push(c);
            else {
                if (st.empty())
                    return false;

                char top = st.top();
                st.pop();
                if ((c == ')' && top != '(') || (c == ']' && top != '[') ||
                    (c == '}' && top != '{'))
                    return false;
            }

        return st.empty();
    }
};
```

### 1047. 删除字符串中的所有相邻重复项

[1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

***python***
```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        res = []
        for c in s:
            if not res or res[-1] != c:
                res.append(c)
            else:
                res.pop()
        return ''.join(res)
```


***cpp***
```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string res;
        for (char c : s)
            if (res.empty() || res.back() != c)
                res.push_back(c);
            else
                res.pop_back();

        return res;
    }
};
```

### 150. 逆波兰表达式求值

[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

***python***
```py
class Solution:
    def string_to_int(self, s: str) -> int:
        i, res, neg = 0, 0, False
        if s[0] == "-":
            neg = True
            i = 1
        while i < len(s):
            res = res * 10 + ord(s[i]) - ord("0")
            i += 1
        return -res if neg else res

    def evalRPN(self, tokens: List[str]) -> int:
        st = []
        for s in tokens:
            if len(s) > 1 or (s >= "0" and s <= "9"):
                st.append(self.string_to_int(s))
            else:
                y = st.pop()
                x = st.pop()
                if s == "+":
                    st.append(x + y)
                elif s == "-":
                    st.append(x - y)
                elif s == "*":
                    st.append(x * y)
                elif s == "/":
                    st.append(int(x / y))
        return st.pop()
```

***cpp***
```cpp
class Solution {
private:
    int stringToInt(string& s) {
        int i = 0, res = 0;
        bool neg = false;
        if (s[0] == '-') {
            neg = true;
            i = 1;
        }
        while (i < s.size())
            res = res * 10 + s[i++] - '0';
        return neg ? -res : res;
    }

public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (string& s : tokens)
            if (s.size() > 1 || (s >= "0" && s <= "9"))
                st.push(stringToInt(s));
            else {
                int y = st.top();
                st.pop();
                int x = st.top();
                st.pop();
                switch (s[0]) {
                case '+':
                    st.push(x + y);
                    break;
                case '-':
                    st.push(x - y);
                    break;
                case '*':
                    st.push(x * y);
                    break;
                case '/':
                    st.push(x / y);
                }
            }
        return st.top();
    }
};
```


### 239. 滑动窗口最大值

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

***python***
```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        res = []
        dq = deque()

        for i in range(k):
            while dq and nums[i] > dq[-1]:
                dq.pop()
            dq.append(nums[i])

        left, right = 0, k  # [left, right)

        while right < len(nums):
            res.append(dq[0])  # Collect result

            # Remove element from deque if it's out of the window
            if nums[left] == dq[0]:
                dq.popleft()
            left += 1

            # Add new element to deque
            while dq and nums[right] > dq[-1]:
                dq.pop()
            dq.append(nums[right])
            right += 1

        res.append(dq[0])  # Collect result for the last window
        return res
```


***cpp***
```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> dq;
        for (int i = 0; i < k; ++i) {
            while (!dq.empty() && nums[i] > dq.back())
                dq.pop_back();
            dq.push_back(nums[i]);
        }
        int left = 0, right = k; // [)
        while (right < nums.size()) {
            res.push_back(dq.front()); // 收获结果

            // 出队
            if (nums[left++] == dq.front())
                dq.pop_front();

            // 入队
            while (!dq.empty() && nums[right] > dq.back())
                dq.pop_back();
            dq.push_back(nums[right++]);
        }
        res.push_back(dq.front());
        return res;
    }
};
```

### 347.前 K 个高频元素

[347.前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

***python***
```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 使用Counter统计每个数字的出现频率
        count = Counter(nums)

        # 创建一个优先队列（最小堆）
        # 需要频率最高的k个元素，因此使用负频率来创建最大堆
        pq = []
        for num, freq in count.items():
            heapq.heappush(pq, (freq, num))
            if len(pq) > k:
                heapq.heappop(pq)

        # 从堆中取出前k个频率最高的元素
        res = []
        while pq:
            res.append(heapq.heappop(pq)[1])

        # 由于使用的是最小堆，因此需要将结果反转
        return res[::-1]
```


***cpp***
```cpp
class Solution {
private:
    struct compare {
        bool operator()(const pair<int, int>& left,
                        const pair<int, int>& right) {
            return left.second > right.second;
        }
    };

public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> umap;
        for (int num : nums)
            ++umap[num];
        priority_queue<pair<int, int>, vector<pair<int, int>>, compare> pq;
        for (unordered_map<int, int>::iterator it = umap.begin();
             it != umap.end(); ++it) {
            pq.push(*it);
            if (pq.size() > k)
                pq.pop();
        }
        // umap.clear();
        vector<int> res;
        res.reserve(k);
        while (!pq.empty()) {
            res.push_back(pq.top().first);
            pq.pop();
        }
        return res;
    }
};
```


## 7 二叉树

### 144. 二叉树的前序遍历

[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: List[int]) -> None:
        if cur is None:
            return
        res.append(cur.val)
        self.traversal(cur.left, res)
        self.traversal(cur.right, res)

    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root is None:
            return res
        st = [root]
        while st:
            cur = st.pop()
            res.append(cur.val)
            if cur.right:
                st.append(cur.right)
            if cur.left:
                st.append(cur.left)
        return res

class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root is None:
            return res
        res.append(root.val)
        left = self.preorderTraversal(root.left)
        right = self.preorderTraversal(root.right)
        res.extend(left)
        res.extend(right)
        return res
```

```cpp
// 递归
class Solution
{
public:
    void traversal(TreeNode *cur, vector<int> &res)
    {
        if (cur == nullptr)
            return;
        res.push_back(cur->val);
        traversal(cur->left, res);
        traversal(cur->right, res);
    }

    vector<int> preorderTraversal(TreeNode *root)
    {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};

// 迭代
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty())
        {
            TreeNode *cur = st.top();
            st.pop();
            res.push_back(cur->val);
            if (cur->right) st.push(cur->right);
            if(cur->left) st.push(cur->left);
        }
        return res;
    }
};

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) { //前序遍历
        vector<int> res;
        if(!root) return res;

        res.push_back(root->val);
        vector<int> left = preorderTraversal(root->left);
        vector<int> right = preorderTraversal(root->right);
        res.insert(res.end(), left.begin(), left.end());
        res.insert(res.end(), right.begin(), right.end());
        return res;
    }
};
```

### 94. 二叉树的中序遍历

[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

***python***
```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: list):
        if not cur:
            return
        self.traversal(cur.left, res)
        res.append(cur.val)
        self.traversal(cur.right, res)

    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def inorderTraversal(self, root: TreeNode) -> list:
        res = []
        stack = []
        cur = root
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left  # 一直向左走
            else:
                cur = stack.pop()
                res.append(cur.val)  # 根
                cur = cur.right  # 右
        return res
```

***cpp***
```cpp
// 递归
class Solution {
private:
    void traversal(TreeNode* cur, vector<int>& res) {
        if (!cur)
            return;
        traversal(cur->left, res);
        res.push_back(cur->val);
        traversal(cur->right, res);
    }

public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};

// 迭代
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur || !st.empty()) {
            if (cur) {
                st.push(cur);
                cur = cur->left;    // 一直向左走
            } else {
                cur = st.top();
                st.pop();
                res.push_back(cur->val);    // 根
                cur = cur->right;   // 右
            }
        }
        return res;
    }
};
```


### 145. 二叉树的后序遍历

[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

***python***
```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: list):
        if not cur:
            return
        self.traversal(cur.left, res)
        self.traversal(cur.right, res)
        res.append(cur.val)
    
    def postorderTraversal(self, root: TreeNode) -> list:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def postorderTraversal(self, root: TreeNode) -> list:
        res = []
        if not root:
            return res
        stack = [root]
        while stack:
            cur = stack.pop()
            res.append(cur.val)
            if cur.left:
                stack.append(cur.left)
            if cur.right:
                stack.append(cur.right)
        res.reverse()
        return res
```

***cpp***
```cpp
// 递归
class Solution{
public:
    void traversal(TreeNode *cur, vector<int> &res){
        if (cur == nullptr)
            return;
        traversal(cur->left, res);
        traversal(cur->right, res);
        res.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode *root){
        vector<int> res;
        traversal(root, res);
        return res;
    }
};

// 迭代
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if (root==nullptr) return res;
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty()){
            TreeNode *cur = st.top();
            st.pop();
            res.push_back(cur->val);
            if (cur->left) st.push(cur->left);
            if (cur->right) st.push(cur->right);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```


### 102. 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

***python***
```python
class Solution:
    def levelOrder(self, root: TreeNode) -> list:
        res = []
        if not root:
            return res
        que = deque([root])
        while que:
            level_size = len(que)
            level = []
            for _ in range(level_size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
                level.append(cur.val)
            res.append(level)
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
            res.push_back(vec);
        }
        return res;
    }
};
```


### 107. 二叉树的层序遍历 II

[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

***python***
```python
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        if not root:
            return res
        que = deque([root])
        while que:
            level_size = len(que)
            level = []
            for _ in range(level_size):
                cur = que.popleft()
                level.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(level)
        res.reverse()
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                if (cur->left)
                    que.push(cur -> left);
                if (cur->right)
                    que.push(cur -> right);
            }
            res.push_back(vec);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### 199. 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

***python***
```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
                if i == size - 1:  # last node in this level
                    res.append(cur.val)
        
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
                if (!size) res.push_back(cur->val);
            }
        }
        return res;
    }
};
```


### 637. 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

***python***
```python
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        res = []
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            sum_val = 0
            for _ in range(size):
                cur = que.popleft()
                sum_val += cur.val
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(sum_val / size)
        
        return res
```


***cpp***
```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            int size_backup = size;
            double sum = 0;
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                sum += cur->val;
                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
            res.push_back(sum / size_backup);
        }
        return res;
    }
};
```

### 429. N叉树的层序遍历

[429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

***python***
```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        res = []
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            level = []
            for _ in range(size):
                cur = que.popleft()
                level.append(cur.val)
                for child in cur.children:
                    que.append(child)
            res.append(level)
        
        return res 
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        queue<Node*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            while (size--) {
                Node* cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                for (Node* node : cur->children)
                    que.push(node);
            }
            res.push_back(vec);
        }
        return res;
    }
};
```


### 515. 在每个树行中找最大值

[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

***python***
```python
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            max_val = float('-inf')
            for _ in range(size):
                cur = que.popleft()
                max_val = max(max_val, cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(max_val)
        
        return res
```


***cpp***
```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            res.push_back(que.front()->val);
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                res.back() = max(cur->val, res.back());
                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
        }
        return res;
    }
};
```

### 116. 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

***python***
```python
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if i < size - 1:
                    cur.next = que[0]
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return root 
```

***cpp***
```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                Node* cur = que.front();
                que.pop();
                if (size) cur->next = que.front();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```


### 117. 填充每个节点的下一个右侧节点指针 II

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

***python***
```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        
        que = deque([root])
        
        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if i < size - 1:  # If it's not the last node in the current level
                    cur.next = que[0]
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return root
```

***cpp***
```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                Node* cur = que.front();
                que.pop();
                if (size) cur->next = que.front();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```


### 104. 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

***python***
```python
# 层序
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        res = 0
        que = deque([root])
        
        while que:
            res += 1
            size = len(que)
            for _ in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return res

# 回溯
class Solution:
    def __init__(self):
        self.res = 0
        self.depth = 0

    def traverse(self, root: TreeNode):
        if not root:
            return
        self.depth += 1
        self.traverse(root.left)
        self.traverse(root.right)
        self.res = max(self.res, self.depth)
        self.depth -= 1

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        self.traverse(root)
        return self.res

# dfs, 带返回值
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

***cpp***
```cpp
// 层序遍历
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            ++res;
            int size = que.size();
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return res;
    }
};

// 回溯
class Solution {
private:
    int res = 0, depth = 0;

    void traverse(TreeNode* root) {
        if (!root)
            return;
        ++depth;
        traverse(root->left);
        traverse(root->right);
        res = max(res, depth);
        --depth;
    }

public:
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
}

// dfs，带返回值
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```


### 111. 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

***python***
```python
# 层序遍历
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        depth = 0
        que = deque([root])
        
        while que:
            depth += 1
            size = len(que)
            for _ in range(size):
                cur = que.popleft()
                if not cur.left and not cur.right:
                    return depth
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return depth

# dfs, 带返回值
class Solution:
    def dfs(self, root: TreeNode) -> int:
        if not root:
            return float('inf')
        if not root.left and not root.right:
            return 1
        return min(self.dfs(root.left), self.dfs(root.right)) + 1

    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return self.dfs(root)

# dfs, 分情况讨论
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        if root.left and not root.right:
            return self.minDepth(root.left) + 1
        elif not root.left and root.right:
            return self.minDepth(root.right) + 1
        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
```

***cpp***
```cpp
// 层序遍历
class Solution {
public:
    int minDepth(TreeNode* root) {
        int depth = 0;
        queue<TreeNode*> que;
        if (root) que.push(root);
        while (!que.empty()) {
            ++depth;
            int size = que.size();
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                if (!cur->left && !cur->right) return depth;
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return depth;
    }
};

// dfs, 带返回值
class Solution {
private:
    int dfs(TreeNode* root) {
        if (!root) return 10001;
        if (!root->left && !root->right) return 1;
        return min(dfs(root->left), dfs(root->right)) + 1;
    }

public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        return dfs(root);
    }
};

// dfs, 分情况讨论
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == nullptr)
            return 0;
        if (root->left && root->right == nullptr)
            return minDepth(root->left) + 1;
        else if (root->left == nullptr && root->right)
            return minDepth(root->right) + 1;
        return min(minDepth(root->left), minDepth(root->right)) + 1;
    }
};
```

### 226. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

***python***
```python
# dfs
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        self.invertTree(root.left)
        self.invertTree(root.right)
        root.left, root.right = root.right, root.left
        return root

# bfs
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        
        stack = [root]
        while stack:
            cur = stack.pop()
            cur.left, cur.right = cur.right, cur.left
            if cur.left:
                stack.append(cur.left)
            if cur.right:
                stack.append(cur.right)
        
        return root
```

***cpp***
```cpp
// dfs
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return root;
        invertTree(root->left);
        invertTree(root->right);
        swap(root->left, root->right);
        return root;
    }
};

// bfs
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            swap(cur->left,cur->right);
            if (cur->left) st.push(cur->left);
            if (cur->right) st.push(cur->right);
        }
        return root;
    }
};
```


---------------------------------


### 1553. 吃掉 N 个橘子的最少天数

[1553. 吃掉 N 个橘子的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/description/)

***python***

```python
class Solution:
    memo = {0: 0, 1: 1, 2: 2}

    def minDays(self, n: int) -> int:
        if n in self.memo:
            return self.memo[n]

        self.memo[n] = min(self.minDays(n // 2) + n % 2, self.minDays(n // 3) + n % 3) + 1
        return self.memo[n]
```

***cpp***

```cpp
// 动态规划超时
class Solution {
public:
    int minDays(int n) {
        if (n == 1 || n == 2)  return n;
        if (n == 3) return 2;
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2, dp[3] = 2;
        for (int i = 4; i <= n; i++) {
            int res1 = i, res2 = i;
            if (i % 2 == 0)
                res1 = dp[i / 2] + 1;
            if (i % 3 == 0)
                res2 = dp[i / 3] + 1;
            dp[i] = min({res1, res2, dp[i - 1] + 1});
        }
        return dp[n];
    }
};

// memo
class Solution {
public:
    unordered_map<int, int> umap{{1, 1}, {2, 2}};

    int minDays(int n) {
        if (umap.count(n))
            return umap[n];
        int d2 = n % 2, d3 = n % 3;
        return umap[n] = min(d2 + minDays(n / 2), d3 + minDays(n / 3)) + 1;
    }
};
```