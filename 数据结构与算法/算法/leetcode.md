- [1 数组](#1-数组)
  - [704. 二分查找](#704-二分查找)
  - [35. 搜索插入位置](#35-搜索插入位置)
  - [34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)
  - [69. x 的平方根](#69-x-的平方根)
  - [367. 有效的完全平方数](#367-有效的完全平方数)
  - [27. 移除元素](#27-移除元素)
  - [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项)
  - [283. 移动零](#283-移动零)
  - [844. 比较含退格的字符串](#844-比较含退格的字符串)
  - [977. 有序数组的平方](#977-有序数组的平方)
  - [209. 长度最小的子数组](#209-长度最小的子数组)
  - [904. 水果成篮](#904-水果成篮)
  - [76. 最小覆盖子串](#76-最小覆盖子串)
  - [59. 螺旋矩阵 II](#59-螺旋矩阵-ii)
  - [54. 螺旋矩阵](#54-螺旋矩阵)
  - [剑指Offer 29. 顺时针打印矩阵](#剑指offer-29-顺时针打印矩阵)
  - [167. 两数之和 II - 输入有序数组](#167-两数之和-ii---输入有序数组)
  - [344. 反转字符串](#344-反转字符串)
  - [5. 最长回文子串](#5-最长回文子串)
- [2 链表](#2-链表)
  - [83. 删除排序链表中的重复元素](#83-删除排序链表中的重复元素)
  - [203.移除链表元素](#203移除链表元素)
  - [707. 设计链表](#707-设计链表)
  - [206.反转链表](#206反转链表)
  - [92. 反转链表 II](#92-反转链表-ii)
  - [25. K 个一组翻转链表](#25-k-个一组翻转链表)
  - [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
  - [19.删除链表的倒数第N个节点](#19删除链表的倒数第n个节点)
  - [面试题 02.07. 链表相交](#面试题-0207-链表相交)
  - [141. 环形链表](#141-环形链表)
  - [142.环形链表II](#142环形链表ii)
  - [21. 合并两个有序链表](#21-合并两个有序链表)
  - [23. 合并 K 个升序链表](#23-合并-k-个升序链表)
  - [86. 分隔链表](#86-分隔链表)
  - [876. 链表的中间结点](#876-链表的中间结点)
  - [234. 回文链表](#234-回文链表)
- [3 哈希表](#3-哈希表)
  - [242.有效的字母异位词](#242有效的字母异位词)
  - [383. 赎金信](#383-赎金信)
  - [49. 字母异位词分组](#49-字母异位词分组)
  - [438. 找到字符串中所有字母异位词](#438-找到字符串中所有字母异位词)
  - [349. 两个数组的交集](#349-两个数组的交集)
  - [350. 两个数组的交集 II](#350-两个数组的交集-ii)
  - [202. 快乐数](#202-快乐数)
  - [1. 两数之和](#1-两数之和)
  - [454. 四数相加II](#454-四数相加ii)
  - [15. 三数之和](#15-三数之和)
  - [18. 四数之和](#18-四数之和)
- [4 字符串](#4-字符串)
  - [344. 反转字符串](#344-反转字符串-1)
  - [541. 反转字符串II](#541-反转字符串ii)
  - [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试)
  - [151. 翻转字符串里的单词](#151-翻转字符串里的单词)
  - [55. 右旋字符串（第八期模拟笔试）](#55-右旋字符串第八期模拟笔试)
  - [28. 找出字符串中第一个匹配项的下标](#28-找出字符串中第一个匹配项的下标)
    - [KMP](#kmp)
  - [459.重复的子字符串](#459重复的子字符串)
- [5 双指针](#5-双指针)
  - [27. 移除元素](#27-移除元素-1)
  - [344. 反转字符串](#344-反转字符串-2)
  - [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试-1)
  - [151. 翻转字符串里的单词](#151-翻转字符串里的单词-1)
  - [206.反转链表](#206反转链表-1)
  - [19.删除链表的倒数第N个节点](#19删除链表的倒数第n个节点-1)
  - [面试题 02.07. 链表相交](#面试题-0207-链表相交-1)
  - [142.环形链表II](#142环形链表ii-1)
  - [15. 三数之和](#15-三数之和-1)
  - [18. 四数之和](#18-四数之和-1)
- [6 栈与队列](#6-栈与队列)
  - [232. 用栈实现队列](#232-用栈实现队列)
  - [225. 用队列实现栈](#225-用队列实现栈)
  - [20. 有效的括号](#20-有效的括号)
  - [1047. 删除字符串中的所有相邻重复项](#1047-删除字符串中的所有相邻重复项)
  - [150. 逆波兰表达式求值](#150-逆波兰表达式求值)
  - [239. 滑动窗口最大值](#239-滑动窗口最大值)
  - [347.前 K 个高频元素](#347前-k-个高频元素)
- [7 二叉树](#7-二叉树)
  - [144. 二叉树的前序遍历](#144-二叉树的前序遍历)
  - [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
  - [145. 二叉树的后序遍历](#145-二叉树的后序遍历)
  - [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
  - [107. 二叉树的层序遍历 II](#107-二叉树的层序遍历-ii)
  - [199. 二叉树的右视图](#199-二叉树的右视图)
  - [637. 二叉树的层平均值](#637-二叉树的层平均值)
  - [429. N叉树的层序遍历](#429-n叉树的层序遍历)
  - [515. 在每个树行中找最大值](#515-在每个树行中找最大值)
  - [116. 填充每个节点的下一个右侧节点指针](#116-填充每个节点的下一个右侧节点指针)
  - [117. 填充每个节点的下一个右侧节点指针 II](#117-填充每个节点的下一个右侧节点指针-ii)
  - [104. 二叉树的最大深度](#104-二叉树的最大深度)
  - [111. 二叉树的最小深度](#111-二叉树的最小深度)
  - [226. 翻转二叉树](#226-翻转二叉树)
  - [101. 对称二叉树](#101-对称二叉树)
  - [100. 相同的树](#100-相同的树)
  - [572. 另一棵树的子树](#572-另一棵树的子树)
  - [559. n叉树的最大深度](#559-n叉树的最大深度)
  - [222. 完全二叉树的节点个数](#222-完全二叉树的节点个数)
  - [110. 平衡二叉树](#110-平衡二叉树)
  - [257. 二叉树的所有路径](#257-二叉树的所有路径)
  - [404. 左叶子之和](#404-左叶子之和)
  - [513. 找树左下角的值](#513-找树左下角的值)
  - [112. 路径总和](#112-路径总和)
  - [113. 路径总和ii](#113-路径总和ii)
  - [106. 从中序与后序遍历序列构造二叉树](#106-从中序与后序遍历序列构造二叉树)
  - [105.从前序与中序遍历序列构造二叉树](#105从前序与中序遍历序列构造二叉树)
  - [654. 最大二叉树](#654-最大二叉树)
  - [617. 合并二叉树](#617-合并二叉树)
  - [700. 二叉搜索树中的搜索](#700-二叉搜索树中的搜索)
  - [98. 验证二叉搜索树](#98-验证二叉搜索树)
  - [530. 二叉搜索树的最小绝对差](#530-二叉搜索树的最小绝对差)
  - [501.二叉搜索树中的众数](#501二叉搜索树中的众数)
  - [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)
  - [235. 二叉搜索树的最近公共祖先](#235-二叉搜索树的最近公共祖先)
  - [701. 二叉搜索树中的插入操作](#701-二叉搜索树中的插入操作)
  - [450. 删除二叉搜索树中的节点](#450-删除二叉搜索树中的节点)
  - [669. 修剪二叉搜索树](#669-修剪二叉搜索树)
  - [108.将有序数组转换为二叉搜索树](#108将有序数组转换为二叉搜索树)
  - [538.把二叉搜索树转换为累加树](#538把二叉搜索树转换为累加树)
- [8 回溯算法](#8-回溯算法)
  - [77. 组合](#77-组合)
  - [216. 组合总和 III](#216-组合总和-iii)
  - [17. 电话号码的字母组合](#17-电话号码的字母组合)
  - [39. 组合总和](#39-组合总和)
  - [40. 组合总和II](#40-组合总和ii)
  - [131. 分割回文串](#131-分割回文串)
  - [93. 复原IP地址](#93-复原ip地址)
  - [78. 子集](#78-子集)
  - [90. 子集II](#90-子集ii)
  - [491. 非递减子序列](#491-非递减子序列)
  - [46. 全排列](#46-全排列)
  - [47. 全排列 II](#47-全排列-ii)
  - [332. 重新安排行程](#332-重新安排行程)
  - [51. N皇后](#51-n皇后)
  - [37. 解数独](#37-解数独)
- [9 贪心算法](#9-贪心算法)
  - [455. 分发饼干](#455-分发饼干)
  - [376. 摆动序列](#376-摆动序列)
  - [53. 最大子序和](#53-最大子序和)
  - [122. 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii)
  - [55. 跳跃游戏](#55-跳跃游戏)
  - [45. 跳跃游戏 II](#45-跳跃游戏-ii)
  - [1005. K次取反后最大化的数组和](#1005-k次取反后最大化的数组和)
  - [134. 加油站](#134-加油站)
  - [135. 分发糖果](#135-分发糖果)
  - [860. 柠檬水找零](#860-柠檬水找零)
  - [406. 根据身高重建队列](#406-根据身高重建队列)
  - [452. 用最少数量的箭引爆气球](#452-用最少数量的箭引爆气球)
  - [435. 无重叠区间](#435-无重叠区间)
  - [763. 划分字母区间](#763-划分字母区间)
  - [56. 合并区间](#56-合并区间)
  - [738. 单调递增的数字](#738-单调递增的数字)
  - [968. 监控二叉树](#968-监控二叉树)
  - [1553. 吃掉 N 个橘子的最少天数](#1553-吃掉-n-个橘子的最少天数)


## 1 数组

### 704. 二分查找

[704. 二分查找](https://leetcode.cn/problems/binary-search/description/)

***python***
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1  # []
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

***cpp***
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // []
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return -1;
    }
};
```

***js***
```js
var search = function (nums, target) {
    let l = 0, r = nums.length - 1; // []
    while (l <= r) {
        let mid = (r + l) >> 1;
        if (nums[mid] === target) return mid;
        else if (nums[mid] < target)
            l = mid + 1;
        else r = mid - 1;
    }
    return -1;
};
```

### 35. 搜索插入位置

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

***python***
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid - 1
            else :
                left = mid + 1
        return left
```

***cpp***
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // []
        while(left <= right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] > target)
                right = mid - 1;
            else 
                left = mid + 1;
        }
        return left;
    }
};
```

***js***
```js
var searchInsert = function (nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] === target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1;
        else right = mid - 1;
    }
    return left;
};
```

### 34. 在排序数组中查找元素的第一个和最后一个位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

***python***
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1  # []

        def getLeftBound(nums, target):
            nonlocal left, right
            while left <= right:
                mid = left + (right - left) // 2
                if nums[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left < len(nums) and nums[left] == target:
                return left
            return -1

        def getRightBound(nums, target):
            nonlocal left, right
            right = len(nums) - 1
            while left <= right:
                mid = left + (right - left) // 2
                if nums[mid] <= target:
                    left = mid + 1
                else:
                    right = mid - 1
            return right

        leftBound = getLeftBound(nums, target)
        if leftBound == -1:
            return [-1, -1]
        return [leftBound, getRightBound(nums, target)]
```

***cpp***
```cpp
class Solution {
public:
    int left = 0, right;
    int findLeftBound(const vector<int>& nums, const int& target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target)
                right = mid - 1;
            else
                left = mid + 1;
        }
        if (left < nums.size() && nums[left] == target)
            return left;
        return -1;
    }

    int findRightBound(const vector<int>& nums, const int& target) {
        right = nums.size() - 1; // []
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        right = nums.size() - 1; // []
        int leftBound = findLeftBound(nums, target);
        if (leftBound == -1)
            return {-1, -1};
        return {leftBound, findRightBound(nums, target)};
    }
};
```

***js***
```js
var searchLeftBound = function (nums, target) {
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] >= target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    if (left < nums.length && nums[left] === target)
        return left;
    return -1;
};

var searchRightBound = function (nums, target) {
    right = nums.length - 1;
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (nums[mid] <= target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return right;
};

var searchRange = function (nums, target) {
    left = 0;
    right = nums.length - 1;
    let leftBound = searchLeftBound(nums, target);
    if (leftBound === -1) return [-1, -1];
    return [leftBound, searchRightBound(nums, target)];
};
```


### 69. x 的平方根

[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/description/)

***python***
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return x
        left, right = 1, x
        while left <= right:
            mid = left + (right - left) // 2
            if x // mid == mid:
                return mid
            elif x // mid > mid:
                left = mid + 1
            else :
                right = mid - 1
        return right
```

***cpp***
```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0)
            return 0;
        int left = 1, right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (x / mid == mid) // 防止数值溢出
                return mid;
            else if (x / mid > mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }
};
```

***js***
```js
var mySqrt = function (x) {
    if (x === 0) return x;
    let left = 1, right = x;
    while (left <= right) {
        let mid = left + ((right - left) >> 1);
        if (mid === Math.floor(x / mid))
            return mid;
        else if (mid < Math.floor(x / mid))
            left = mid + 1;
        else
            right = mid - 1;
    }
    return right;
};
```

### 367. 有效的完全平方数

[367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/description/)

***python***
```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 1, num
        while left <= right:
            mid = left + (right - left) // 2
            if mid * mid == num:
                return True
            elif mid * mid < num:
                left = mid + 1
            else:
                right = mid - 1
        return False
```

***cpp***
```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 1, right = num;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if ((long)mid * mid == num)
                return true;
            else if (mid < num / mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return false;
    }
};
```

***js***
```js
var isPerfectSquare = function (num) {
    let left = 1, right = num;
    while (left <= right) {
        let mid = left + ((right - left) >> 1);
        if (mid * mid == num)
            return true;
        else if (mid * mid < num)
            left = mid + 1;
        else right = mid - 1;
    }
    return false;
};
```

### 27. 移除元素

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/description/)

***python***
```python
class Solution(object):
    def removeElement(self, nums, val):
        left, right  = 0, len(nums) - 1
        while left <= right:
            while left <= right and nums[left] != val:
                left += 1
            while left <= right and nums[right] == val:
                right -= 1
            if left <= right:
                nums[left] = nums[right]
                left += 1
                right -= 1
        return left
```

***cpp***
```cpp
// 左右指针
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            while (left <= right && nums[left] != val) ++left;
            while (left <= right && nums[right] == val) --right;
            if (left <= right) nums[left++] = nums[right--];
        }
        return left;
    }
};

// 快慢指针
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0, fast = 0;
        while (fast < nums.size()) {
            if (nums[fast] != val) nums[slow++] = nums[fast];
            ++fast;
        }
        return slow;
    }
};
```

***js***
```js
var removeElement = function(nums, val) {
    let slow = 0, fast = 0;
    for(; fast < nums.length; fast++)
        if (nums[fast] != val)
            nums[slow++] = nums[fast];
    return slow;
};
```

### 26. 删除排序数组中的重复项

[26. 删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

***python***

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 0
        while fast < len(nums):
            if fast < len(nums) - 1 and nums[fast] == nums[fast + 1]:
                fast += 1
                continue
            else:
                nums[slow] = nums[fast]
                slow += 1
                fast += 1
        return slow
```

***cpp***

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 0, fast = 0;
        while (fast < nums.size() - 1) {
            if (nums[fast] != nums[fast + 1]) nums[slow++] = nums[fast];
            ++fast;
        }
        nums[slow++] = nums[fast];
        return slow;
    }
};
```

***js***
```js
var removeDuplicates = function(nums) {
    let slow = 1, fast = 0;
    while (fast < nums.length){
        if (fast > 0 && nums[fast] != nums[fast - 1])
            nums[slow++] = nums[fast];
        fast++;
    }
    return slow;
};
```

### 283. 移动零

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/description/)

***python***

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow, fast = 0, 0
        while fast < len(nums):
            if nums[fast]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        while slow < len(nums):
            nums[slow] = 0
            slow += 1
```

***cpp***

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0, fast = 0;
        for(; fast < nums.size(); fast++)
            if(nums[fast])
                nums[slow++] = nums[fast];

        while(slow < nums.size())
            nums[slow++] = 0;
    }
};
```

***js***
```js
var moveZeroes = function (nums) {
    let slow = 0, fast = 0;
    for (; fast < nums.length; fast++)
        if (nums[fast] != 0)
            nums[slow++] = nums[fast];

    while (slow < nums.length)
        nums[slow++] = 0;
};
```

### 844. 比较含退格的字符串

[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/description/)

***python***

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def modify(S):
            stack = []
            for char in S:
                if char != '#':
                    stack.append(char)
                elif stack:
                    stack.pop()
            return ''.join(stack)

        return modify(s) == modify(t)


# ----------------------------
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        return self.modifyString(s) == self.modifyString(t)
    
    def modifyString(self, s: str) -> str:
        slow, fast = 0, 0
        s_list = list(s)
        while fast < len(s_list):
            if s_list[fast] != '#':
                s_list[slow] = s_list[fast]
                slow += 1
            elif slow > 0:
                slow -= 1

            fast += 1
        return ''.join(s_list[:slow])
```

***cpp***

```cpp
class Solution {
private:
    void help(string& s) {
        int slow = 0, fast = 0;
        while (fast < s.size()) {
            if (s[fast] == '#') {
                if (slow > 0)
                    --slow;
            } else
                s[slow++] = s[fast];
            ++fast;
        }
        s.resize(slow);
    }

public:
    bool backspaceCompare(string s, string t) {
        help(s);
        help(t);
        return s == t;
    }
}
```

***js***
```js
var backspaceCompare = function (s, t) {
    modify = function (s) {
        let slow = 0, sArr = s.split('');
        for (let fast = 0; fast < sArr.length; fast++) {
            if (sArr[fast] != '#')
                sArr[slow++] = sArr[fast];
            else if (slow > 0)
                slow--;
        }
        sArr.length = slow;
        return sArr.join('');
    }
    s = modify(s);
    t = modify(t);
    return s == t;
};
```

### 977. 有序数组的平方

[977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/description/)

***python***

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        res = [0] * len(nums)
        nums = [num * num for num in nums]
        i, j, k = 0, len(nums) - 1, len(nums) - 1
        while k >= 0:
            if nums[i] >= nums[j]:
                res[k] = nums[i]
                i += 1
            else:
                res[k] = nums[j]
                j -= 1
            k -= 1
        return res
```

***cpp***

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for (int& num : nums)
            num = num * num;

        vector<int> res(nums.size());
        int i = nums.size() - 1, left = 0, right = nums.size() - 1;
        while (i >= 0)
            res[i--] = nums[right] >= nums[left] ? nums[right--] : nums[left++];
        return res;
    }
};
```

***js***

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function (nums) {
    // 将 nums 数组中的每个元素取平方，并生成一个新的数组
    nums = nums.map(num => num * num)
    let res = new Array(nums.length);
    let i = 0, j = nums.length - 1, k = nums.length - 1;
    while (k >= 0) {
        if (nums[i] >= nums[j]) {
            res[k] = nums[i];
            i++;
        } else {
            res[k] = nums[j];
            j--;
        }
        k--;
    }
    return res;
};
```

### 209. 长度最小的子数组

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/)

***python***

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left, right = 0, 0  # [)
        sum = 0
        res = len(nums) + 1
        while right < len(nums):
            while right < len(nums) and sum < target:
                sum += nums[right]
                right += 1
            while sum >= target:
                res = min(res, right - left)
                sum -= nums[left]
                left += 1
        return 0 if res == len(nums) + 1 else res
```

***cpp***

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum = 0, res = INT32_MAX;
        for (int slow = 0, fast = 0; fast < nums.size(); ++fast) {
            sum += nums[fast];
            while (sum >= target) {
                res = min(res, fast - slow + 1);
                sum -= nums[slow++];
            }
        }
        return res == INT32_MAX ? 0 : res;
    }
};
```

***js***

```js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
    let left = 0, right = 0;    // [)
    let sum = 0;
    let res = nums.length + 1;
    while (right < nums.length) {
        sum += nums[right];
        right++;
        while (sum >= target) {
            res = Math.min(res, right - left);  // 注意是Math.min()
            sum -= nums[left++];
        }
    }
    return res === nums.length + 1 ? 0 : res;
};
```

### 904. 水果成篮

[904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/description/)

***python***

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        fruit_map = {}
        left, right = 0, 0
        temp_res, res = 0, 0
        for fruit in fruits:
            if fruit in fruit_map:
                fruit_map[fruit] += 1
            else:
                fruit_map[fruit] = 1
            
            if len(fruit_map) <= 2:
                temp_res += 1
                res = max(res, temp_res)
            else:
                while len(fruit_map) > 2:
                    fruit_map[fruits[left]] -= 1
                    if fruit_map[fruits[left]] == 0:
                        del fruit_map[fruits[left]]
                    left += 1
                temp_res = right - left + 1
            right += 1
        return res
```

***cpp***

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> umap;
        int res = 0;
        int slow = 0, fast = 0;
        while (fast < fruits.size()) {
            ++umap[fruits[fast++]];
            if (umap.size() <= 2) res = max(res, fast - slow);
            else
                while (umap.size() > 2) {
                    if (umap[fruits[slow]] == 1) umap.erase(fruits[slow]);
                    else --umap[fruits[slow]];
                    ++slow;
                }
        }
        return res;
    }
}
```

***js***

```js
/**
 * @param {number[]} fruits
 * @return {number}
 */
var totalFruit = function (fruits) {
    const fruitMap = new Map();
    let res = 0, tempRes = 0;
    let slow = 0, fast = 0;
    for (const fruit of fruits) {
        fruitMap.set(fruit, (fruitMap.get(fruit) || 0) + 1);

        if (fruitMap.size <= 2) {
            tempRes += 1;
            res = Math.max(res, tempRes);
        } else {
            while (fruitMap.size > 2) {
                fruitMap.set(fruits[slow], fruitMap.get(fruits[slow]) - 1);
                if (fruitMap.get(fruits[slow]) === 0) {
                    fruitMap.delete(fruits[slow]);
                }
                slow += 1;
            }
            tempRes = fast - slow + 1;
        }
        fast += 1;
    }
    return res;
};
```

### 76. 最小覆盖子串

[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/description/)

***python***

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = {}
        for c in t:
            if c in need:
                need[c] += 1
            else:
                need[c] = 1
        left, right, start_index = 0, 0, 0
        length = 100001
        invalid = len(need)

        while right < len(s):
            # 扩大窗口
            if s[right] in need:
                need[s[right]] -= 1
                if need[s[right]] == 0:
                    invalid -= 1
            right += 1

            while invalid == 0:
                # 缩小窗口
                if s[left] in need:
                    need[s[left]] += 1
                    if need[s[left]] > 0:
                        invalid += 1
                        if right - left < length: # 收获结果
                            start_index = left
                            length = right - left
                left += 1
        return "" if length == 100001 else s[start_index:start_index + length]
        
```

***cpp***

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> umap;
        for (const char& c : t)
            ++umap[c];
        int invalid = umap.size();
        int start_index = 0, length = 100001;
        int slow = 0, fast = 0;
        while (fast < s.size()) {
            // 扩大窗口
            auto it = umap.find(s[fast++]);
            if (it != umap.end()) {
                --it->second;
                if (it->second == 0)
                    --invalid;
            }

            // 收缩窗口
            while (invalid == 0) {
                if (fast - slow < length) { // 收获结果
                    start_index = slow;
                    length = fast - slow;
                }
                auto it = umap.find(s[slow++]);
                if (it != umap.end()) {
                    ++it->second;
                    if (it->second == 1)
                        ++invalid;
                }
            }
        }
        return length == 100001 ? "" : s.substr(start_index, length);
    }
};
```

***js***

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
    let umap = new Map();
    for (let c of t) {
        umap.set(c, (umap.get(c) || 0) + 1);
    }
    let left = 0, right = 0;
    let invalid = umap.size;
    let start_index = 0, length = 100001;

    while (right < s.length) {
        // 扩大窗口
        let char = s[right++];
        if (umap.has(char)) {
            umap.set(char, umap.get(char) - 1);
            if (umap.get(char) === 0) {
                invalid--;
            }
        }

        // 收缩窗口
        while (invalid === 0) {
            let charLeft = s[left];
            if (umap.has(charLeft)) {
                umap.set(charLeft, umap.get(charLeft) + 1);
                if (umap.get(charLeft) > 0) {
                    invalid++;
                    if (right - left < length) { // 收获结果
                        start_index = left;
                        length = right - left;
                    }
                }
            }
            left++;
        }
    }
    return length === 100001 ? "" : s.substr(start_index, length);
};
```

### 59. 螺旋矩阵 II

[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/description/)

***python***

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0] * n for _ in range(n)] # 二维数组
        left_bound, right_bound = 0, n - 1
        up_bound, down_bound = 0, n - 1
        count = 1

        while count <= n * n:
            # 上边
            for j in range(left_bound, right_bound + 1):
                res[up_bound][j] = count
                count += 1
            up_bound += 1

            # 右边
            for i in range(up_bound, down_bound + 1):
                res[i][right_bound] = count
                count += 1
            right_bound -= 1

            # 下边
            for j in range(right_bound, left_bound - 1, - 1):
                res[down_bound][j] = count
                count += 1
            down_bound -= 1

            # 左边
            for i in range(down_bound, up_bound - 1, -1):
                res[i][left_bound] = count
                count += 1
            left_bound += 1

        return res
```

***cpp***

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n));
        int leftBound = 0, rightBound = n - 1;
        int upBound = 0, downBound = n - 1;
        int count = 1;
        while (count <= n * n) {
            // 上边
            for (int j = leftBound; j <= rightBound; ++j)
                res[upBound][j] = count++;
            upBound++;

            // 右边
            for (int i = upBound; i <= downBound; ++i)
                res[i][rightBound] = count++;
            rightBound--;

            // 下边
            for (int j = rightBound; j >= leftBound; --j)
                res[downBound][j] = count++;
            downBound--;

            // 左边
            for (int i = downBound; i >= upBound; --i)
                res[i][leftBound] = count++;
            leftBound++;
        }
        return res;
    }
};
```

***js***

```js
/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function (n) {
    let res = new Array(n).fill().map(() => new Array(n).fill(0));
    let leftBound = 0, rightBound = n - 1;
    let upBound = 0, downBound = n - 1;
    let count = 1;

    while (count <= n * n) {
        // 上边
        for (let j = leftBound; j <= rightBound; j++)
            res[upBound][j] = count++;
        upBound++;

        // 右边
        for (let i = upBound; i <= downBound; i++)
            res[i][rightBound] = count++;
        rightBound--;

        // 下边
        for (let j = rightBound; j >= leftBound; j--)
            res[downBound][j] = count++;
        downBound--;

        // 左边
        for (let i = downBound; i >= upBound; i--)
            res[i][leftBound] = count++;
        leftBound++;
    }
    return res;
};
```

### 54. 螺旋矩阵

[54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/description/)

***python***

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        m, n = len(matrix), len(matrix[0])
        up_bound, down_bound = 0, m - 1
        left_bound, right_bound = 0, n - 1

        while up_bound <= down_bound and left_bound <= right_bound:
            # 上边
            for j in range(left_bound, right_bound + 1):
                res.append(matrix[up_bound][j])
            up_bound += 1
            if up_bound > down_bound:
                break
            
            # 右边
            for i in range(up_bound, down_bound + 1):
                res.append(matrix[i][right_bound])
            right_bound -= 1
            if left_bound > right_bound:
                break
            
            # 下边
            for j in range(right_bound, left_bound - 1, -1):
                res.append(matrix[down_bound][j])
            down_bound -= 1

            # 左边
            for i in range(down_bound, up_bound - 1, -1):
                res.append(matrix[i][left_bound])
            left_bound += 1
        return res
```

***cpp***

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int m = matrix.size(), n = matrix[0].size();
        res.reserve(m * n);
        int leftBound = 0, rightBound = n - 1;
        int upBound = 0, downBound = m - 1;
        int count = m * n;
        while (count) {
            for (int j = leftBound; j <= rightBound; ++j)
                res.push_back(matrix[upBound][j]);
            count -= (rightBound - leftBound + 1);
            if (count == 0) break;
            ++upBound;

            for (int i = upBound; i <= downBound; ++i)
                res.push_back(matrix[i][rightBound]);
            count -= (downBound - upBound + 1);
            if (count == 0) break;
            --rightBound;

            for (int j = rightBound; j >= leftBound; --j)
                res.push_back(matrix[downBound][j]);
            count -= (rightBound - leftBound + 1);
            --downBound;

            for (int i = downBound; i >= upBound; --i)
                res.push_back(matrix[i][leftBound]);
            count -= (downBound - upBound + 1);
            ++leftBound;
        }
        return res;
    }
}
```

***js***

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function (matrix) {
    let res = [];
    let m = matrix.length, n = matrix[0].length;
    let upBound = 0, downBound = m - 1;
    let leftBound = 0, rightBound = n - 1;

    while (upBound <= downBound && leftBound <= rightBound) {
        // 上
        for (let j = leftBound; j <= rightBound; j++) {
            res.push(matrix[upBound][j]);
        }
        upBound++;
        if (upBound > downBound) break;

        // 右
        for (let i = upBound; i <= downBound; i++) {
            res.push(matrix[i][rightBound]);
        }
        rightBound--;
        if (leftBound > rightBound) break;

        // 下
        for (let j = rightBound; j >= leftBound; j--) {
            res.push(matrix[downBound][j]);
        }
        downBound--;

        // 左
        for (let i = downBound; i >= upBound; i--) {
            res.push(matrix[i][leftBound]);
        }
        leftBound++;
    }
    return res;
};
```

### 剑指Offer 29. 顺时针打印矩阵

[剑指Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/)

同 [54. 螺旋矩阵](#54-螺旋矩阵)

### 167. 两数之和 II - 输入有序数组

[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/)

***python***

```python
# 左右指针
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers) - 1
        while left < right:
            sum = numbers[left] + numbers[right]
            if sum == target:
                return [left + 1, right + 1]
            elif sum < target:
                left += 1
            else:
                right -= 1
        return [-1, -1]

# 哈希
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        umap = {}
        for i, num in enumerate(numbers):
            if target - num in umap:
                return [umap[target - num] + 1, i + 1]
            umap[num] = i
```

***cpp***

```cpp
// 左右指针
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (target == sum) return {left + 1, right + 1};
            else if (target < sum) --right;
            else ++left;
        }
        return {-1, -1};
    }
};

// 哈希
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        unordered_map<int, int> umap;
        for (int i = 0; i < numbers.size(); ++i) {
            auto it = umap.find(target - numbers[i]);
            if (it != umap.end()) return {it->second + 1, i + 1};
            umap[numbers[i]] = i;
        }
        return {-1, -1};
    }
};
```

***js***

```js
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
// 左右指针
var twoSum = function (numbers, target) {
    let left = 0, right = numbers.length - 1;
    while (left < right) {
        let sum = numbers[left] + numbers[right];
        if (target === sum) {
            return [left + 1, right + 1];
        } else if (target < sum) {
            right--;
        } else {
            left++;
        }
    }
    return [-1, -1];
};

// 哈希
var twoSum = function (numbers, target) {
    let umap = new Map();
    for (let i = 0; i < numbers.length; i++) {
        if (umap.has(target - numbers[i])) {
            return [umap.get(target - numbers[i]) + 1, i + 1];
        }
        umap.set(numbers[i], i);
    }
};
```

### 344. 反转字符串

[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/description/)

***python***

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

***cpp***

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0, right = s.size() - 1;
        while (left < right)
            swap(s[left++], s[right--]);
    }
};
```

***js***

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function (s) {
    let i = 0, j = s.length - 1;
    while (i < j) {
        [s[i], s[j]] = [s[j], s[i]];
        i++;
        j--;
    }
};
```

### 5. 最长回文子串

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/description/)

***python***

```python
class Solution:
    def extend(self, s: str, i: int, j: int) -> int:
        res = 0
        while i >= 0 and j < len(s) and s[i] == s[j]:
            if i != j:
                res += 2
            else:
                res += 1
            i -= 1
            j += 1
        return res

    def longestPalindrome(self, s: str) -> str:
        length = 1
        start_index = 0
        for i in range(len(s)):
            length1 = self.extend(s, i, i)
            length2 = self.extend(s, i, i + 1)
            length = max(length, length1, length2)
            if length == length1:
                start_index = i - (length1 - 1) // 2
            elif length == length2:
                start_index = i - length2 // 2 + 1
        return s[start_index : start_index + length]
```

***cpp***

```cpp
class Solution {
private:
    int extend(const string& s, int i, int j) {
        int length = 0;
        for (; i >= 0 && j < s.size() && s[i] == s[j]; --i, ++j)
            length += i == j ? 1 : 2;
        return length;
    }

public:
    string longestPalindrome(string s) {
        int mid_index = 0, length = 0;
        for (int i = 0; i < s.size(); ++i) {
            int temp_length = max(extend(s, i, i), extend(s, i, i + 1));
            if (temp_length > length) {
                length = temp_length;
                mid_index = i;
            }
        }
        return s.substr(mid_index - (length - 1) / 2, length);
    }
};
```

***js***

```js
/**
 * @param {string} s
 * @return {string}
 */

var extend = function (s, i, j) {
    let res = 0;
    while (i >= 0 && j < s.length && s[i] === s[j]) {
        if (i !== j) {
            res += 2;
        } else {
            res += 1;
        }
        i--;
        j++;
    }
    return res;
}

var longestPalindrome = function (s) {
    let length = 1;
    let startIndex = 0;
    for (let i = 0; i < s.length; i++) {
        let length1 = extend(s, i, i);
        let length2 = extend(s, i, i + 1);
        let lengthTemp = Math.max(length, length1, length2);
        if (lengthTemp === length1) {
            startIndex = i - Math.floor((length1 - 1) / 2);
        } else if (lengthTemp === length2) {
            startIndex = i - Math.floor(length2 / 2) + 1;
        }
        length = lengthTemp;
    }
    return s.substring(startIndex, startIndex + length);
};
```

----------------------------

## 2 链表

### 83. 删除排序链表中的重复元素

[83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)

***python***

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        p = head
        while p.next:
            if p.next.val == p.val:
                p.next = p.next.next
            else:
                p = p.next
        return head
```

***cpp***

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head)
            return head;
        ListNode* p = head;
        while (p->next) {
            if (p->next->val == p->val) {
                ListNode* del = p->next;
                p->next = del->next;
                delete del;
            }else
                p = p->next;
        }
        return head;
    }
};
```

***js***

```js
var deleteDuplicates = function (head) {
     if (!head || !head.next) 
        return head;

    let p = head;
    while (p.next) {
        if (p.next.val === p.val) {
            p.next = p.next.next;
        } else {
            p = p.next;
        }
    }
    return head;
};
```


### 203.移除链表元素

[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

***python***
```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummyHead = ListNode(0, head);
        p = dummyHead;
        while p.next:
            if p.next.val == val:
                p.next = p.next.next
            else:
                p = p.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next) {
            if (p->next->val == val) {
                ListNode* temp = p->next;
                p->next = temp->next;
                delete temp;
            } else
                p = p->next;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
var removeElements = function (head, val) {
    const dummyHead = new ListNode(0, head);
    let p = dummyHead;
    while (p.next) {
        if (p.next.val === val) {
            const temp = p.next;
            p.next = temp.next;
            temp.next = null; // Optional: Helps in garbage collection
        } else {
            p = p.next;
        }
    }
    return dummyHead.next;
};
```

### 707. 设计链表

[707. 设计链表](https://leetcode.cn/problems/design-linked-list/description/)

***python***
```python
class ListNode:
    def __init__(self, val = 0,next = None):
        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):
        self.head = None
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        p = self.head
        for _ in range(index):
            p = p.next
        return p.val

    def addAtHead(self, val: int) -> None:
        self.head = ListNode(val, self.head)
        self.size += 1

    def addAtTail(self, val: int) -> None:
        p = self.head
        while p.next:
            p = p.next
        p.next = ListNode(val)
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        p = self.head
        for _ in range(index - 1):
            p = p.next
        p.next = ListNode(val, p.next)
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        p = self.head
        for _ in range(index - 1):
            p = p.next
        p.next = p.next.next
        self.size -= 1



# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

***cpp***
```cpp
class MyLinkedList {
private:
    // 定义链表
    struct ListNode {
        int val;
        ListNode* next;
        ListNode() : val(0), next(nullptr) {}
        ListNode(int x) : val(x), next(nullptr) {}
        ListNode(int x, ListNode* next) : val(x), next(next) {}
    };

    ListNode* _dummyHead;
    int _size;

public:
    MyLinkedList() {
        _dummyHead = new ListNode();
        _size = 0;
    }

    int get(int index) {
        if (index < 0 || index >= _size)
            return -1;
        ListNode* p = _dummyHead->next;
        while (index--)
            p = p->next;
        return p->val;
    }

    void addAtHead(int val) {
        ListNode* p = new ListNode(val, _dummyHead->next);
        _dummyHead->next = p;
        ++_size;
    }

    void addAtTail(int val) {
        ListNode* p = _dummyHead;
        while (p->next)
            p = p->next;
        p->next = new ListNode(val);
        ++_size;
    }

    void addAtIndex(int index, int val) {
        ListNode* p = _dummyHead;
        if (index < 0 || index > _size)
            return;
        while (index--)
            p = p->next;
        ListNode* temp = new ListNode(val, p->next);
        p->next = temp;
        ++_size;
    }

    void deleteAtIndex(int index) {
        if (index < 0 || index >= _size)
            return;
        ListNode* p = _dummyHead;
        while (index--)
            p = p->next;
        ListNode* temp = p->next;
        p->next = p->next->next;
        delete temp;
        --_size;
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

***js***
```js
var ListNode = function (val = 0, next = null) {
    this.val = val;
    this.next = next;
};

var MyLinkedList = function () {
    this._dummyHead = new ListNode();
    this._size = 0;
};

/** 
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.get = function (index) {
    if (index < 0 || index >= this._size)
        return -1;
    let p = this._dummyHead.next;
    while (index--)
        p = p.next;
    return p.val;
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function (val) {
    const p = new ListNode(val, this._dummyHead.next);
    this._dummyHead.next = p;
    this._size++;
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function (val) {
    let p = this._dummyHead;
    while (p.next)
        p = p.next;
    p.next = new ListNode(val);
    this._size++;
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function (index, val) {
    if (index < 0 || index > this._size)
        return;
    let p = this._dummyHead;
    while (index--)
        p = p.next;
    const temp = new ListNode(val, p.next);
    p.next = temp;
    this._size++;
};

/** 
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function (index) {
    if (index < 0 || index >= this._size)
        return;
    let p = this._dummyHead;
    while (index--)
        p = p.next;
    p.next = p.next.next;
    this._size--;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * var obj = new MyLinkedList()
 * var param_1 = obj.get(index)
 * obj.addAtHead(val)
 * obj.addAtTail(val)
 * obj.addAtIndex(index,val)
 * obj.deleteAtIndex(index)
 */
```

### 206.反转链表

[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

***python***
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# 逐个节点反转
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre, cur = None, head
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre

# 递归
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head
        
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```

***cpp***
```cpp
// 逐个翻转每个节点的指向
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr;
        ListNode *cur = head;
        while (cur)
        {
            ListNode *temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};

// 递归
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr || head->next == nullptr) return head;
        ListNode *last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};
```

***js***
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
// 逐个节点反转
var reverseList = function (head) {
    let pre = null;
    let cur = head;
    while (cur) {
        const temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
};

// 递归
var reverseList = function (head) {
    if (head === null || head.next === null)
        return head;

    const last = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return last;
};
```

### 92. 反转链表 II

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

***python***
```python
# 迭代法
class Solution:
    def reverseBetween(
        self, head: Optional[ListNode], left: int, right: int
    ) -> Optional[ListNode]:
        if left == right:
            return head
        dummyHead = ListNode(0, head)
        p = dummyHead
        for _ in range(left - 1):
            p = p.next
        # 此时 p 指向 left 的前驱
        pre, cur = p.next, p.next.next
        for _ in range(right - left):
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        p.next.next = cur
        p.next = pre
        return dummyHead.next

# 递归
class Solution:
    backup = None  # right 的后继

    def reverse(self, q, count, right):
        if count == right:
            self.backup = q.next
            return q
        count += 1
        last = self.reverse(q.next, count, right)
        q.next.next = q  # 调转指向
        q.next = self.backup  # 指向 right 的后继
        return last

    def reverseBetween(
        self, head: Optional[ListNode], left: int, right: int
    ) -> Optional[ListNode]:
        if left == right:
            return head
        dummyHead = ListNode(0, head)
        p = dummyHead
        for _ in range(1, left):
            p = p.next
        # 此时 p 指向 left 的前驱
        p.next = self.reverse(p.next, left, right)
        return dummyHead.next
```

***cpp***
```cpp
// 迭代法
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if (left == right)
            return head;

        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        int count = left - 1;
        while (count--) // p 指向 left 的前驱
            p = p->next;
        ListNode* pre = p->next;
        ListNode* cur = pre->next;
        count = right - left;
        while (count--) {
            ListNode* count = cur->next;
            cur->next = pre;
            pre = cur;
            cur = count;
        }
        p->next->next = cur;
        p->next = pre;
        return dummyHead->next;
    }
};

// 递归
class Solution {
public:
    ListNode* backup = nullptr;     // right 的后继
    ListNode* reverse(ListNode* q, int& count, const int& right) {
        if (count == right) {
            backup = q->next;
            return q;
        }
        ++count;
        ListNode* last = reverse(q->next, count, right);
        q->next->next = q;      // 调转指向
        q->next = backup;       // 指向 right 的后继
        return last;
    }

    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if (left == right)
            return head;
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        for (int count = 1; count < left; count++)
            p = p->next;
        // 此时 p 指向 left 的前驱
        p->next = reverse(p->next, left, right);
        return dummyHead->next;
    }
};
```

***js***
```js

```

### 25. K 个一组翻转链表

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)

***python***
```python
class Solution:
    def reverse(self, head: ListNode, tail: ListNode):  # [)
        pre, cur = None, head
        while cur != tail:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre

    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        p = q = head
        for _ in range(k):
            if q == None:
                return head
            q = q.next
        # 此时 q 指向下一组的头节点
        last = self.reverse(p, q)
        p.next = self.reverseKGroup(q, k)
        return last
```

***cpp***
```cpp
class Solution {
private:
  ListNode* reverse(ListNode* a, ListNode* b) { // [)
    ListNode* pre = nullptr;
    ListNode *cur = a, *next = a;
    while (cur != b) {
      next = cur->next;
      cur->next = pre;
      pre = cur;
      cur = next;
    }
    return pre;
  }

public:
  ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr) return head;
    ListNode *a, *b;
    a = b = head;
    for (int i = 0; i < k; i++) {
      if (b == nullptr) return head;
      b = b->next;
    }

    // 此时 b 指向下一组的头节点
    ListNode* newHead = reverse(a, b);
    a->next = reverseKGroup(b, k);
    return newHead;
  }
};
```

***js***
```js
```

### 24. 两两交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

***python***
```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(0, head)
        p = dummyHead
        while p.next and p.next.next:
            temp = p.next
            p.next = temp.next
            temp.next = temp.next.next
            p.next.next = temp
            p = temp
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next && p->next->next) {
            ListNode* temp = p->next;
            p->next = temp->next;
            temp->next = temp->next->next;
            p->next->next = temp;
            p = temp;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 19.删除链表的倒数第N个节点

[19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

***python***
```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummyHead = ListNode(0, head)
        slow, fast = dummyHead, head
        for _ in range(n):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
  ListNode *removeNthFromEnd(ListNode *head, int n) {
    ListNode *dummyHead = new ListNode(0, head);
    ListNode *fast = dummyHead;
    ListNode *slow = dummyHead;
    while (n-- >= 0) // 走 n + 1 步
      fast = fast->next;

    while (fast) {
      fast = fast->next;
      slow = slow->next;
    }

    ListNode *del = slow->next;
    slow->next = del->next;
    delete del;
    return dummyHead->next;
  }
};
```

***js***
```js
```

### 面试题 02.07. 链表相交

[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

***python***
```python
# 方法一：提前记载各自长度
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p = headA
        countA = countB = 0
        while p:
            p = p.next
            countA += 1

        p = headB
        while p:
            p = p.next
            countB += 1

        if countA == 0 or countB == 0:
            return None
        p, q = headA, headB

        if countA < countB:
            p, q = q, p
        # 此时 p 指向长链表
        for _ in range(abs(countA - countB)):
            p = p.next
        while p != q:
            p = p.next
            q = q.next

        return p

# 优雅解法，尾连接
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p, q = headA, headB
        while p != q:
            if p == None:
                p = headB
            else:
                p = p.next

            if q == None:
                q = headA
            else:
                q = q.next

        return q
```

***cpp***
```cpp
// 方法一：提前记载各自长度
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode* p = headA;
        int countA = 0, countB = 0;
        while (p) {
            p = p->next;
            ++countA;
        }
        p = headB;
        while (p) {
            p = p->next;
            ++countB;
        }
        if (countA == 0 || countB == 0)
            return nullptr;
        p = headA;
        ListNode* q = headB;
        if (countA < countB)
            swap(q, p);
        // 此时 p 指向长链表
        int temp = abs(countA - countB);
        while (temp--)
            p = p->next;
        while (p != q) {
            p = p->next;
            q = q->next;
        }
        return q;
    }
};

// 巧妙，尾连接
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode *p = headA, *q = headB;
        while (p != q) {
            if (p == nullptr) p = headB;
            else p = p->next;

            if (q == nullptr) q = headA;
            else q = q->next;
        }
        return q;
    }
};
```

***js***
```js
```

### 141. 环形链表

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)

***python***
```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

***cpp***
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        while (fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) return true;
        }
        return false;
    }
};
```

***js***
```js
```

### 142.环形链表II

[142.环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

***python***
```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

            if fast == slow:
                p, q = fast, head
                while p != q:
                    p = p.next
                    q = q.next
                return q
        return None
```

***cpp***
```cpp
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode *fast = head, *slow = head;

        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;

            if (fast == slow) {
                ListNode* p = fast;
                ListNode* q = head;
                while (q != p) {
                    q = q->next;
                    p = p->next;
                }
                return q;
            }
        }
        return nullptr;
    }
};
```

***js***
```js
```

### 21. 合并两个有序链表

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

***python***
```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(0, list1)
        p, q = dummyHead, list2
        while p.next and q:
            if q.val <= p.next.val:
                cur = q
                q = q.next
                cur.next = p.next
                p.next = cur
            p = p.next

        if q:
            p.next = q
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummyHead = new ListNode(0, list1);
        ListNode *p = dummyHead, *q = list2;
        while (p->next && q) {
            if (q->val <= p->next->val) {
                ListNode* cur = q;
                q = q->next;
                cur->next = p->next;
                p->next = cur;
            }
            p = p->next;
        }
        if (q)
            p->next = q;
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 23. 合并 K 个升序链表

[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

***python***
```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        p = dummyHead = ListNode(0)
        heap = []
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(heap, (lists[i].val, i))
                lists[i] = lists[i].next

        while heap:
            val, idx = heapq.heappop(heap)
            p.next = ListNode(val)
            p = p.next
            if lists[idx]:
                heapq.heappush(heap, (lists[idx].val, idx))
                lists[idx] = lists[idx].next

        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    struct compare { // 小顶堆
        bool operator()(const ListNode* const& l, const ListNode* const& r) {
            return l->val > r->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty())
            return nullptr;
        ListNode* dummyHead = new ListNode(0);
        ListNode* p = dummyHead;

        priority_queue<ListNode*, vector<ListNode*>, compare> pq;
        for (auto head : lists) // 将 k 个头结点入队
            if (head)
                pq.push(head);

        while (!pq.empty()) {
            ListNode* cur = pq.top();
            pq.pop();
            if (cur->next)
                pq.push(cur->next);
            p->next = cur;
            p = p->next;
        }
        return dummyHead->next;
    }
};
```

***js***
```js
```

### 86. 分隔链表

[86. 分隔链表](https://leetcode.cn/problems/partition-list/description/)

***python***
```python
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        p = dummyHead = ListNode(0, head)
        while p.next and p.next.val < x:
            p = p.next

        q = p.next
        while q and q.next:
            if q.next.val < x:
                cur = q.next
                q.next = cur.next
                cur.next = p.next
                p.next = cur
                p = cur
            else:
                q = q.next
        return dummyHead.next
```

***cpp***
```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next && p->next->val < x)
            p = p->next;

        ListNode* q = p->next; // 此时 q 指向右半节点的头，p 指向左半节点的头
        while (q && q->next)
            if (q->next->val < x) {
                ListNode* cur = q->next;
                q->next = cur->next;
                cur->next = p->next;
                p->next = cur;
                p = cur;
            } else
                q = q->next;

        return dummyHead->next;
    }
};
```

***js***
```js
```

### 876. 链表的中间结点

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)

***python***
```python
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
```

***cpp***
```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *fast = head, *slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

***js***
```js
```

### 234. 回文链表
[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/)

***python***
```python
# 借用空间
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        p = head
        arr = []
        while p:
            arr.append(p.val)
            p = p.next
        left, right = 0, len(arr) - 1
        while left <= right:
            if arr[left] != arr[right]:
                return False
            left += 1
            right -= 1
        return True

# 递归 (dfs)
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        self.p = head
        def dfs(head: Optional[ListNode]) -> bool:
            if head is None:
                return True

            if not dfs(head.next):
                return False

            if self.p.val != head.val:
                return False

            self.p = self.p.next
            return True

        return dfs(head)

# 双指针 + 反转链表
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        if fast:
            slow = slow.next

        # 翻转后半部分链表
        pre, cur = None, slow
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp

        while pre:
            if pre.val != head.val:
                return False
            pre = pre.next
            head = head.next
        return True
```

***cpp***
```cpp
// 借用空间
class Solution {
  public:
  bool isPalindrome(ListNode *head) {
    vector<int> vec;
    ListNode *p = head;
    while (p) {
      vec.push_back(p->val);
      p = p->next;
    }
    int left = 0, right = vec.size() - 1;
    while (left < right)
      if (vec[left++] != vec[right--]) return false;
    return true;
  }
};

// 递归 （dfs）
class Solution {
private:
    ListNode* p, *headback;
    bool dfs(ListNode* head) {
        if (head == nullptr || (p != headback && p == head))   // 剪枝，到中间就返回
            return true;

        bool res1 = dfs(head->next);
        bool res2 = head->val == p->val;
        p = p->next;
        return res1 && res2;
    }

public:
    bool isPalindrome(ListNode* head) {
        headback = p = head;
        return dfs(head);
    }
};

// 双指针 + 反转链表
class Solution {
public:
  bool isPalindrome(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next->next;
    }
    if (fast) slow = slow->next;

    // 翻转后半部分链表
    ListNode *pre = nullptr, *cur = slow, *nex = slow;
    while (cur) {
      nex = cur->next;
      cur->next = pre;
      pre = cur;
      cur = nex;
    }
    while (pre) {
      if (pre->val != head->val) return false;
      pre = pre->next;
      head = head->next;
    }
    return true;
  }
};
```

***js***
```js
```

------------------------------

## 3 哈希表

### 242.有效的字母异位词

[242.有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/)

***python***
```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        arr = [0] * 26
        for c in s:
            arr[ord(c) - ord('a')] += 1     # ord() 用来获取字符的 ASCII 码

        for c in t:
            arr[ord(c) - ord('a')] -= 1

        for num in arr:
            if num:
                return False

        return True
```

***cpp***
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size())
            return false;
        int a[26] = {0};
        for (char ch : s)
            ++a[ch - 'a'];
        for (char ch : t)
            --a[ch - 'a'];
        
        for (int i = 0; i < 26; ++i)
            if (a[i])
                return false;
        
        return true;
    }
};
```

### 383. 赎金信

[383. 赎金信](https://leetcode.cn/problems/ransom-note/description/)

***python***
```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        arr = [0] * 26
        for c in magazine:
            arr[ord(c) - ord("a")] += 1

        for c in ransomNote:
            arr[ord(c) - ord("a")] -= 1

        for num in arr:
            if num < 0:
                return False

        return True
```


***cpp***
```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        for (char ch : magazine)
            ++record[ch - 'a'];
        
        for (char ch : ransomNote)
            --record[ch - 'a'];
        
        for (int i = 0; i < 26; ++i)
            if (record[i] < 0)
                return false;
        
        return true;
    }
};
```

### 49. 字母异位词分组

[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)

***python***
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        umap = {}
        for string in strs:
            sorted_str = "".join(sorted(string))    # 排序后的字符串作为 key
            if sorted_str not in umap:
                umap[sorted_str] = []
            umap[sorted_str].append(string)

        return list(umap.values())  # 返回字典的值, 并转换为列表
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> umap;
        for (const string& str : strs) {
            string temp = str;
            sort(temp.begin(), temp.end());
            umap[temp].emplace_back(str);
        }
        vector<vector<string>> res;
        for (auto it = umap.begin(); it != umap.end(); ++it)
            res.push_back(it->second);
        return res;
    }
};
```

### 438. 找到字符串中所有字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

***python***
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        umap = {}
        res = []
        for c in p:
            if c not in umap:
                umap[c] = 0
            umap[c] += 1

        invalid = len(umap)
        left = right = 0  # [)
        while right < len(s):
            c = s[right]  # 扩大窗口
            right += 1
            if c in umap:
                umap[c] -= 1
                if umap[c] == 0:
                    invalid -= 1

            if right - left == len(p):
                if invalid == 0:
                    res.append(left)  # 收结果
                d = s[left]
                left += 1  # 收缩窗口
                if d in umap:
                    if umap[d] == 0:
                        invalid += 1
                    umap[d] += 1

        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        if (s.size() < p.size())
            return res;
        unordered_map<char, int> umap;
        for (const char& c : p)
            ++umap[c];
        int invalid = umap.size();
        int left = 0, right = 0; // [)
        while (right < s.size()) {
            char c = s[right++]; // 扩大窗口
            if (umap.find(c) != umap.end()) {
                --umap[c];
                if (umap[c] == 0)
                    --invalid;
            }

            if (right - left == p.size()) {
                if (invalid == 0)
                    res.emplace_back(left); // 收结果
                char d = s[left++];         // 缩小窗口
                if (umap.find(d) != umap.end()) {
                    if (umap[d] == 0)
                        ++invalid;
                    ++umap[d];
                }
            }
        }
        return res;
    }
};
```

### 349. 两个数组的交集

[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

***python***
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        my_set = set(nums1)
        res = []

        for num in nums2:
            if num in my_set:
                res.append(num)
                my_set.remove(num)

        return res
```

***cpp***
```cpp
class Solution{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2){
        unordered_set<int> mySet;
        vector<int> res;

        for (int num1 : nums1)
            mySet.insert(num1);
        for (int num2 : nums2)
            if (mySet.find(num2) != mySet.end()){
                res.emplace_back(num2);
                mySet.erase(num2);
            }

        return res;
    }
};
```

### 350. 两个数组的交集 II

[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/)

***python***
```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        umap = {}
        res = []
        for num in nums1:
            if num not in umap:
                umap[num] = 0
            umap[num] += 1

        for num in nums2:
            if num in umap and umap[num]:
                res.append(num)
                umap[num] -= 1

        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> umap;
        vector<int> res;
        for (int num : nums1)
            ++umap[num];

        for (int num : nums2) {
            auto it = umap.find(num);
            if (it != umap.end() && it->second) {
                res.push_back(num);
                --(it->second);
            }
        }
        return res;
    }
};
```

### 202. 快乐数

[202. 快乐数](https://leetcode.cn/problems/happy-number/description/)

***python***
```python
class Solution:
    def isHappy(self, n: int) -> bool:
        num_set = set()
        while n != 1:
            num_set.add(n)
            sum_of_digits = 0
            while n:
                sum_of_digits += (n % 10) * (n % 10)
                n //= 10
            if sum_of_digits in num_set:
                return False
            n = sum_of_digits
        return True
```

***cpp***
```cpp
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> uset;
        while (n != 1) {
            uset.insert(n);
            int sum = 0;
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            if (uset.count(sum))
                return false;
            n = sum;
        }
        return true;
    }
};
```

### 1. 两数之和

[1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

***python***
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        umap = {}
        for idx, num in enumerate(nums):
            if target - num in umap:
                return [umap[target - num], idx]
            umap[num] = idx
```

***cpp***
```cpp
class Solution {
public:
  vector<int> twoSum(vector<int> &nums, int target) {
    unordered_map<int, int> umap;
    for (int i = 0; i < nums.size(); i++) {
      auto it = umap.find(target - nums[i]);
      if (it != umap.end())
        return {it->second, i};
      umap.insert({nums[i], i});
    }
    return {-1, -1};
  }
};
```

### 454. 四数相加II

[454. 四数相加II](https://leetcode.cn/problems/4sum-ii/description/)

***python***
```python
class Solution:
    def fourSumCount(
        self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]
    ) -> int:
        umap = {}
        res = 0
        for n1 in nums1:
            for n2 in nums2:
                temp = n1 + n2
                if temp not in umap:
                    umap[temp] = 0
                umap[temp] += 1

        for n3 in nums3:
            for n4 in nums4:
                temp = -n3 -n4
                if temp in umap:
                    res += umap[temp]

        return res
```

***cpp***
```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,
                     vector<int>& nums4) {
        unordered_map<int, int> umap;
        int res = 0;
        for (int num1 : nums1)
            for (int num2 : nums2)
                ++umap[num1 + num2];

        for (int num3 : nums3)
            for (int num4 : nums4) {
                auto it = umap.find(-num3 - num4);
                if (it != umap.end())
                    res += it->second;
            }

        return res;
    }
};
```

### 15. 三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/description/)

***python***
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        i = 0
        while i < len(nums):
            if nums[i] > 0:
                break
            left, right = i + 1, len(nums) - 1
            while left < right:
                if nums[i] + nums[left] == -nums[right]:
                    res.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif nums[i] + nums[left] < -nums[right]:
                    left += 1
                else:
                    right -= 1
            while i < len(nums) - 1 and nums[i] == nums[i + 1]:
                i += 1
            i += 1
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] > 0)
                break;
            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                if (nums[i] + nums[left] == -nums[right]) {
                    res.push_back(
                        vector<int>{nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1])
                        ++left;
                    while (left < right && nums[right] == nums[right - 1])
                        --right;
                    ++left;
                    --right;
                } else if (nums[i] + nums[left] < -nums[right])
                    ++left;
                else
                    --right;
            }
            while (i < nums.size() - 1 && nums[i] == nums[i + 1])
                ++i;
        }
        return res;
    }
};
```

### 18. 四数之和

[18. 四数之和](https://leetcode.cn/problems/4sum/description/)

***python***
```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        res = []
        nums.sort()
        i, j = 0, 1
        while i < len(nums):
            sum = nums[i]
            if sum > 0 and sum > target:    # 剪枝
                return res
            j = i + 1
            while j < len(nums):
                sum = nums[i] + nums[j]
                if sum > 0 and sum > target:    # 剪枝
                    break
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[i] + nums[j] == target - nums[left] - nums[right]:
                        res.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        left += 1
                        right -= 1
                    elif nums[i] + nums[j] < target - nums[left] - nums[right]:
                        left += 1
                    else:
                        right -= 1
                while j < len(nums) - 1 and nums[j] == nums[j + 1]:
                    j += 1
                j += 1
            while i < len(nums) - 1 and nums[i] == nums[i + 1]:
                i += 1
            i += 1
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < (int)nums.size() - 3; i++) {
            int sum = nums[i];
            if (sum > 0 && sum > target) // 剪枝
                return res;
            if (i > 0 && nums[i] == nums[i - 1])
                continue;

            for (int j = i + 1; j < (int)nums.size() - 2; ++j) {
                sum = nums[i] + nums[j];
                if (sum > 0 && sum > target) // 剪枝
                    break;
                if (j > i + 1 && nums[j] == nums[j - 1])
                    continue;

                int left = j + 1;
                int right = nums.size() - 1;
                while (left < right) {
                    if ((long)nums[i] + nums[j] <
                        (long)target - nums[left] - nums[right])
                        ++left;
                    else if ((long)nums[i] + nums[j] >
                             (long)target - nums[left] - nums[right])
                        --right;
                    else {
                        res.emplace_back(vector<int>{nums[i], nums[j],
                                                     nums[left], nums[right]});
                        ++left;
                        --right;
                        while (left < right && nums[left] == nums[left - 1])
                            ++left;
                        while (left < right && nums[right] == nums[right + 1])
                            --right;
                    }
                }
            }
        }
        return res;
    }
};
```


----------------------------------------

## 4 字符串

### 344. 反转字符串

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)

***python***
```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

***cpp***
```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0, right = s.size() - 1;
        while (left < right)
            swap(s[left++], s[right--]);
    }
};
```

### 541. 反转字符串II

[541. 反转字符串II](https://leetcode.cn/problems/reverse-string-ii/description/)

***python***
```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        def reverseString(s: str, left, right) -> str:
            s_list = list(s)
            while left < right:
                s_list[left], s_list[right] = s_list[right], s_list[left]
                left += 1
                right -= 1
            return "".join(s_list)

        left, right = 0, k  # [)
        for _ in range(len(s) // (2 * k)):
            s = reverseString(s, left, right - 1)
            left += 2 * k
            right += 2 * k

        if right >= len(s):
            s = reverseString(s, left, len(s) - 1)
        else:
            s = reverseString(s, left, right - 1)
        return s
```

***cpp***
```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        int count = s.size() / (2 * k);
        int left, right;
        for (left = 0, right = k; count; --count) {
            reverse(s.begin() + left, s.begin() + right);
            left += (2 * k);
            right = left + k;
        }
        right > s.size() ? reverse(s.begin() + left, s.end())
                         : reverse(s.begin() + left, s.begin() + right);
        return s;
    }
};
```

### 替换数字（第八期模拟笔试）

[替换数字（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1064)

***python***
```python
s = input()

res = ""
for ch in s:
    if ch.isdigit():
        res += "number"
    else:
        res += ch

print(res)
```

***cpp***
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
  string s;
  cin >> s;

  string res;
  for (auto ch : s) {
    if (isdigit(ch))
      res += "number";
    else
      res.push_back(ch);
  }
  cout << res;
  return 0;
}
```

### 151. 翻转字符串里的单词

[151. 翻转字符串里的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

***python***
```python
s = input()

res = ""
for ch in s:
    if ch.isdigit():
        res += "number"
    else:
        res += ch

print(res)
```

***cpp***
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
  string s;
  cin >> s;

  string res;
  for (auto ch : s) {
    if (isdigit(ch))
      res += "number";
    else
      res.push_back(ch);
  }
  cout << res;
  return 0;
}
```

### 55. 右旋字符串（第八期模拟笔试）

[55. 右旋字符串（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1065)

***python***
```python
def rotate_string(s, k):
    k %= len(s)  # Ensure k is within the bounds of the string length
    s = s[::-1]  # Reverse the entire string
    s = s[:k][::-1] + s[k:][::-1]  # Reverse the first k characters and the remaining characters separately
    return s

# Input
k = int(input())
s = input()

# Output the rotated string
print(rotate_string(s, k))

```

***cpp***
```cpp
#include <algorithm>
#include <iostream>
#include <string>

using namespace std;

int main() {
  int k;
  string s;
  cin >> k >> s;
  k %= s.size();
  reverse(s.begin(), s.end());
  reverse(s.begin(), s.begin() + k);
  reverse(s.begin() + k, s.end());
  cout << s << endl;
  return 0;
}
```

### 28. 找出字符串中第一个匹配项的下标

#### KMP

`search(char pat[], char txt[])` 函数用于在字符串 `txt` 中查找字符串 `pat`，假设 `txt.size() > pat.size()`

KMP 算法对 `pat[]` 进行预处理，得到 `next[]` 数组，`next[i]` 表示 `pat[0..i]` 的**最长真前缀后缀匹配长度**，所谓**真**是指不允许包含整个字符串的前缀

**预处理（求 `next[]` 数组）算法**
- 计算 `next[]` 中的值。为此，跟踪前一个索引的最长前缀后缀值得长度（使用 `len` 变量）
- `next[0]` 和 `len` 都初始化为 `0`
- 如果 `pat[len]` 和 `pat[i]` 匹配，将 `len` 加 `1`，并将增加后的值赋给 `lps[i]`
- 如果 `pat[i]` 和 `pat[len]` 不匹配并且 `len` 不为 `0`，我们将 `len` 更新为 `lps[len-1]`


**KMP 算法的实现**

使用 `next[]` 中的值来决定下一个要匹配的字符，不匹配那些我们知道无论如何都会匹配的字符

- `txt[i]` 和 `pat[j]` 做匹配
- 如果**匹配**，`i` 和 `j` 都加 `1`
- 如果 `j = pat.size()`，说明找到了匹配项，重置 `j = next[j - 1]` 继续匹配
- 如果**不匹配**，`j = next[j - 1]`

```cpp
class KMP {
public:
  vector<int> KMPSearch(string txt, string pat) {
    vector<int> res;
    vector<int> next = getNext(pat);
    int i = 0, j = 0;
    while (txt.size() - i >= pat.size() - j) {
      if (pat[j] == txt[i]) {
        ++i;
        ++j;
      }
      if (j == pat.size()) {
        res.push_back(i - j);
        j = next[j - 1];
      } else if (i < txt.size() && pat[j] != txt[i]) {
        if (j)
          j = next[j - 1];
        else
          ++i;
      }
    }
    return res;
  }

private:
  vector<int> getNext(const string &pat) {
    vector<int> next(pat.size());
    next[0] = 0;
    int len = 0, i = 1;

    while (i < pat.size())
      if (pat[i] == pat[len])
        next[i++] = ++len;
      else if (len) // if (pat[i] != pat[len] && len != 0)
        len = next[len - 1];
      else // if (pat[i] != pat[len] && len == 0)
        next[i++] = 0;
    return next;
  }
};
```

-----------------------------------


[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

***python***
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def getNext(pat: str):
            next = [0] * len(pat)
            length, i = 0, 1
            while i < len(pat):
                if pat[i] == pat[length]:
                    length += 1
                    next[i] = length
                    i += 1
                else:
                    if length:
                        length = next[length - 1]
                    else:
                        next[i] = 0
                        i += 1
            return next

        next = getNext(needle)
        i, j = 0, 0
        while i < len(haystack):
            if haystack[i] == needle[j]:
                i += 1
                j += 1
            if j == len(needle):
                return i - j
            elif i < len(haystack) and haystack[i] != needle[j]:
                if j:
                    j = next[j - 1]
                else:
                    i += 1
        return -1
```

***cpp***
```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        vector<int> next(needle.size());
        getNext(needle, next);
        int i = 0, j = 0;
        while (haystack.size() - i >= needle.size() - j) {
            if (haystack[i] == needle[j]) {
                ++i;
                ++j;
            }
            if (needle.size() == j)
                return i - j;
            else if (i < haystack.size() && haystack[i] != needle[j]) {
                if (j)
                    j = next[j - 1];
                else
                    ++i;
            }
        }
        return -1;
    }

private:
    void getNext(const string& pat, vector<int>& next) {
        next[0] = 0;
        int len = 0, i = 1;
        while (i < pat.size())
            if (pat[i] == pat[len])
                next[i++] = ++len;
            else if (len)
                len = next[len - 1];
            else
                next[i++] = len;
    }
};
```

### 459.重复的子字符串

[459.重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)

`s` repeated => `s` in `s + s`
`s` no in `s + s` => `s` not repeated

***python***
```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        return (s + s).find(s, 1) != len(s)
```

***cpp***
```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s + s).find(s, 1) != s.size();
    }
};
```

## 5 双指针

### [27. 移除元素](#27-移除元素)
### [344. 反转字符串](#344-反转字符串-1)
### [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试)
### [151. 翻转字符串里的单词](#151-翻转字符串里的单词)
### [206.反转链表](#206反转链表)
### [19.删除链表的倒数第N个节点](#19删除链表的倒数第n个节点)
### [面试题 02.07. 链表相交](#面试题-0207-链表相交)
### [142.环形链表II](#142环形链表ii)
### [15. 三数之和](#15-三数之和)
### [18. 四数之和](#18-四数之和)

## 6 栈与队列

### 232. 用栈实现队列

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

***python***
```python
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def transfer(self):
        while self.s1:
            self.s2.append(self.s1.pop())

    def push(self, x: int) -> None:
        self.s1.append(x)

    def pop(self) -> int:
        if not self.s2:
            self.transfer()
        return self.s2.pop()

    def peek(self) -> int:
        if not self.s2:
            self.transfer()
        return self.s2[-1]

    def empty(self) -> bool:
        return not self.s1 and not self.s2
```

***cpp***
```cpp
class MyQueue {
private:
    stack<int> s1;
    stack<int> s2;

    void transfer() {
        while (!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
    }

public:
    MyQueue() {}

    void push(int x) { s1.push(x); }

    int pop() {
        if (s2.empty())
            transfer();
        int temp = s2.top();
        s2.pop();
        return temp;
    }

    int peek() {
        if (s2.empty())
            transfer();
        return s2.top();
    }

    bool empty() { return s1.empty() && s2.empty(); }
};
```

### 225. 用队列实现栈

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

***python***
```python
class MyStack:

    def __init__(self):
        self.q = deque()

    def push(self, x: int) -> None:
        self.q.append(x)

    def pop(self) -> int:
        for _ in range(len(self.q) - 1):
            self.q.append(self.q.popleft())
        return self.q.popleft()

    def top(self) -> int:
        return self.q[-1]

    def empty(self) -> bool:
        return len(self.q) == 0
```

***cpp***
```cpp
class MyStack {
private:
    queue<int> q;

public:
    MyStack() {}

    void push(int x) { q.push(x); }

    int pop() {
        int size = q.size() - 1;
        while (size--) {
            q.push(q.front());
            q.pop();
        }
        int temp = q.front();
        q.pop();
        return temp;
    }

    int top() { return q.back(); }

    bool empty() { return q.empty(); }
};
```


### 20. 有效的括号

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

***python***
```python
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2:
            return False
        stack = []
        for c in s:
            if c in "([{":
                stack.append(c)
            else:
                if not stack:
                    return False

                top = stack.pop()
                if c == ")" and top != "(":
                    return False
                if c == "]" and top != "[":
                    return False
                if c == "}" and top != "{":
                    return False
        return not stack
```

***cpp***
```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2)
            return false;
        stack<char> st;
        for (char c : s) 
            if (c == '(' || c == '[' || c == '{')
                st.push(c);
            else {
                if (st.empty())
                    return false;

                char top = st.top();
                st.pop();
                if ((c == ')' && top != '(') || (c == ']' && top != '[') ||
                    (c == '}' && top != '{'))
                    return false;
            }

        return st.empty();
    }
};
```

### 1047. 删除字符串中的所有相邻重复项

[1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

***python***
```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        res = []
        for c in s:
            if not res or res[-1] != c:
                res.append(c)
            else:
                res.pop()
        return ''.join(res)
```


***cpp***
```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string res;
        for (char c : s)
            if (res.empty() || res.back() != c)
                res.push_back(c);
            else
                res.pop_back();

        return res;
    }
};
```

### 150. 逆波兰表达式求值

[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

***python***
```py
class Solution:
    def string_to_int(self, s: str) -> int:
        i, res, neg = 0, 0, False
        if s[0] == "-":
            neg = True
            i = 1
        while i < len(s):
            res = res * 10 + ord(s[i]) - ord("0")
            i += 1
        return -res if neg else res

    def evalRPN(self, tokens: List[str]) -> int:
        st = []
        for s in tokens:
            if len(s) > 1 or (s >= "0" and s <= "9"):
                st.append(self.string_to_int(s))
            else:
                y = st.pop()
                x = st.pop()
                if s == "+":
                    st.append(x + y)
                elif s == "-":
                    st.append(x - y)
                elif s == "*":
                    st.append(x * y)
                elif s == "/":
                    st.append(int(x / y))
        return st.pop()
```

***cpp***
```cpp
class Solution {
private:
    int stringToInt(string& s) {
        int i = 0, res = 0;
        bool neg = false;
        if (s[0] == '-') {
            neg = true;
            i = 1;
        }
        while (i < s.size())
            res = res * 10 + s[i++] - '0';
        return neg ? -res : res;
    }

public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (string& s : tokens)
            if (s.size() > 1 || (s >= "0" && s <= "9"))
                st.push(stringToInt(s));
            else {
                int y = st.top();
                st.pop();
                int x = st.top();
                st.pop();
                switch (s[0]) {
                case '+':
                    st.push(x + y);
                    break;
                case '-':
                    st.push(x - y);
                    break;
                case '*':
                    st.push(x * y);
                    break;
                case '/':
                    st.push(x / y);
                }
            }
        return st.top();
    }
};
```


### 239. 滑动窗口最大值

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

***python***
```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        res = []
        dq = deque()

        for i in range(k):
            while dq and nums[i] > dq[-1]:
                dq.pop()
            dq.append(nums[i])

        left, right = 0, k  # [left, right)

        while right < len(nums):
            res.append(dq[0])  # Collect result

            # Remove element from deque if it's out of the window
            if nums[left] == dq[0]:
                dq.popleft()
            left += 1

            # Add new element to deque
            while dq and nums[right] > dq[-1]:
                dq.pop()
            dq.append(nums[right])
            right += 1

        res.append(dq[0])  # Collect result for the last window
        return res
```


***cpp***
```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> dq;
        for (int i = 0; i < k; ++i) {
            while (!dq.empty() && nums[i] > dq.back())
                dq.pop_back();
            dq.push_back(nums[i]);
        }
        int left = 0, right = k; // [)
        while (right < nums.size()) {
            res.push_back(dq.front()); // 收获结果

            // 出队
            if (nums[left++] == dq.front())
                dq.pop_front();

            // 入队
            while (!dq.empty() && nums[right] > dq.back())
                dq.pop_back();
            dq.push_back(nums[right++]);
        }
        res.push_back(dq.front());
        return res;
    }
};
```

### 347.前 K 个高频元素

[347.前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

***python***
```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 使用Counter统计每个数字的出现频率
        count = Counter(nums)

        # 创建一个优先队列（最小堆）
        # 需要频率最高的k个元素，因此使用负频率来创建最大堆
        pq = []
        for num, freq in count.items():
            heapq.heappush(pq, (freq, num))
            if len(pq) > k:
                heapq.heappop(pq)

        # 从堆中取出前k个频率最高的元素
        res = []
        while pq:
            res.append(heapq.heappop(pq)[1])

        # 由于使用的是最小堆，因此需要将结果反转
        return res[::-1]
```


***cpp***
```cpp
class Solution {
private:
    struct compare {
        bool operator()(const pair<int, int>& left,
                        const pair<int, int>& right) {
            return left.second > right.second;
        }
    };

public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> umap;
        for (int num : nums)
            ++umap[num];
        priority_queue<pair<int, int>, vector<pair<int, int>>, compare> pq;
        for (unordered_map<int, int>::iterator it = umap.begin();
             it != umap.end(); ++it) {
            pq.push(*it);
            if (pq.size() > k)
                pq.pop();
        }
        // umap.clear();
        vector<int> res;
        res.reserve(k);
        while (!pq.empty()) {
            res.push_back(pq.top().first);
            pq.pop();
        }
        return res;
    }
};
```


## 7 二叉树

### 144. 二叉树的前序遍历

[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: List[int]) -> None:
        if cur is None:
            return
        res.append(cur.val)
        self.traversal(cur.left, res)
        self.traversal(cur.right, res)

    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root is None:
            return res
        st = [root]
        while st:
            cur = st.pop()
            res.append(cur.val)
            if cur.right:
                st.append(cur.right)
            if cur.left:
                st.append(cur.left)
        return res

class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root is None:
            return res
        res.append(root.val)
        left = self.preorderTraversal(root.left)
        right = self.preorderTraversal(root.right)
        res.extend(left)
        res.extend(right)
        return res
```

```cpp
// 递归
class Solution
{
public:
    void traversal(TreeNode *cur, vector<int> &res)
    {
        if (cur == nullptr)
            return;
        res.push_back(cur->val);
        traversal(cur->left, res);
        traversal(cur->right, res);
    }

    vector<int> preorderTraversal(TreeNode *root)
    {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};

// 迭代
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty())
        {
            TreeNode *cur = st.top();
            st.pop();
            res.push_back(cur->val);
            if (cur->right) st.push(cur->right);
            if(cur->left) st.push(cur->left);
        }
        return res;
    }
};

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) { //前序遍历
        vector<int> res;
        if(!root) return res;

        res.push_back(root->val);
        vector<int> left = preorderTraversal(root->left);
        vector<int> right = preorderTraversal(root->right);
        res.insert(res.end(), left.begin(), left.end());
        res.insert(res.end(), right.begin(), right.end());
        return res;
    }
};
```

### 94. 二叉树的中序遍历

[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

***python***
```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: list):
        if not cur:
            return
        self.traversal(cur.left, res)
        res.append(cur.val)
        self.traversal(cur.right, res)

    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def inorderTraversal(self, root: TreeNode) -> list:
        res = []
        stack = []
        cur = root
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left  # 一直向左走
            else:
                cur = stack.pop()
                res.append(cur.val)  # 根
                cur = cur.right  # 右
        return res
```

***cpp***
```cpp
// 递归
class Solution {
private:
    void traversal(TreeNode* cur, vector<int>& res) {
        if (!cur)
            return;
        traversal(cur->left, res);
        res.push_back(cur->val);
        traversal(cur->right, res);
    }

public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};

// 迭代
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur || !st.empty()) {
            if (cur) {
                st.push(cur);
                cur = cur->left;    // 一直向左走
            } else {
                cur = st.top();
                st.pop();
                res.push_back(cur->val);    // 根
                cur = cur->right;   // 右
            }
        }
        return res;
    }
};
```


### 145. 二叉树的后序遍历

[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

***python***
```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: list):
        if not cur:
            return
        self.traversal(cur.left, res)
        self.traversal(cur.right, res)
        res.append(cur.val)
    
    def postorderTraversal(self, root: TreeNode) -> list:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def postorderTraversal(self, root: TreeNode) -> list:
        res = []
        if not root:
            return res
        stack = [root]
        while stack:
            cur = stack.pop()
            res.append(cur.val)
            if cur.left:
                stack.append(cur.left)
            if cur.right:
                stack.append(cur.right)
        res.reverse()
        return res
```

***cpp***
```cpp
// 递归
class Solution{
public:
    void traversal(TreeNode *cur, vector<int> &res){
        if (cur == nullptr)
            return;
        traversal(cur->left, res);
        traversal(cur->right, res);
        res.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode *root){
        vector<int> res;
        traversal(root, res);
        return res;
    }
};

// 迭代
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if (root==nullptr) return res;
        stack<TreeNode*> st;
        st.push(root);
        while (!st.empty()){
            TreeNode *cur = st.top();
            st.pop();
            res.push_back(cur->val);
            if (cur->left) st.push(cur->left);
            if (cur->right) st.push(cur->right);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```


### 102. 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

***python***
```python
class Solution:
    def levelOrder(self, root: TreeNode) -> list:
        res = []
        if not root:
            return res
        que = deque([root])
        while que:
            level_size = len(que)
            level = []
            for _ in range(level_size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
                level.append(cur.val)
            res.append(level)
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
            res.push_back(vec);
        }
        return res;
    }
};
```


### 107. 二叉树的层序遍历 II

[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

***python***
```python
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        if not root:
            return res
        que = deque([root])
        while que:
            level_size = len(que)
            level = []
            for _ in range(level_size):
                cur = que.popleft()
                level.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(level)
        res.reverse()
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                if (cur->left)
                    que.push(cur -> left);
                if (cur->right)
                    que.push(cur -> right);
            }
            res.push_back(vec);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### 199. 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

***python***
```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
                if i == size - 1:  # last node in this level
                    res.append(cur.val)
        
        return res
```

***cpp***
```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
                if (!size) res.push_back(cur->val);
            }
        }
        return res;
    }
};
```


### 637. 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

***python***
```python
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        res = []
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            sum_val = 0
            for _ in range(size):
                cur = que.popleft()
                sum_val += cur.val
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(sum_val / size)
        
        return res
```


***cpp***
```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            int size_backup = size;
            double sum = 0;
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                sum += cur->val;
                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
            res.push_back(sum / size_backup);
        }
        return res;
    }
};
```

### 429. N叉树的层序遍历

[429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

***python***
```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        res = []
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            level = []
            for _ in range(size):
                cur = que.popleft()
                level.append(cur.val)
                for child in cur.children:
                    que.append(child)
            res.append(level)
        
        return res 
```

***cpp***
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        queue<Node*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            while (size--) {
                Node* cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                for (Node* node : cur->children)
                    que.push(node);
            }
            res.push_back(vec);
        }
        return res;
    }
};
```


### 515. 在每个树行中找最大值

[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

***python***
```python
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            max_val = float('-inf')
            for _ in range(size):
                cur = que.popleft()
                max_val = max(max_val, cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(max_val)
        
        return res
```


***cpp***
```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            res.push_back(que.front()->val);
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                res.back() = max(cur->val, res.back());
                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
        }
        return res;
    }
};
```

### 116. 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

***python***
```python
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        que = deque([root]) if root else deque()
        
        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if i < size - 1:
                    cur.next = que[0]
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return root 
```

***cpp***
```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                Node* cur = que.front();
                que.pop();
                if (size) cur->next = que.front();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```


### 117. 填充每个节点的下一个右侧节点指针 II

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

***python***
```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        
        que = deque([root])
        
        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if i < size - 1:  # If it's not the last node in the current level
                    cur.next = que[0]
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return root
```

***cpp***
```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            int size = que.size();
            while (size--) {
                Node* cur = que.front();
                que.pop();
                if (size) cur->next = que.front();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```


### 104. 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

***python***
```python
# 层序
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        res = 0
        que = deque([root])
        
        while que:
            res += 1
            size = len(que)
            for _ in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return res

# 回溯
class Solution:
    def __init__(self):
        self.res = 0
        self.depth = 0

    def traverse(self, root: TreeNode):
        if not root:
            return
        self.depth += 1
        self.traverse(root.left)
        self.traverse(root.right)
        self.res = max(self.res, self.depth)
        self.depth -= 1

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        self.traverse(root)
        return self.res

# dfs, 带返回值
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

***cpp***
```cpp
// 层序遍历
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        queue<TreeNode*> que;
        if (root)
            que.push(root);
        while (!que.empty()) {
            ++res;
            int size = que.size();
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return res;
    }
};

// 回溯
class Solution {
private:
    int res = 0, depth = 0;

    void traverse(TreeNode* root) {
        if (!root)
            return;
        ++depth;
        traverse(root->left);
        traverse(root->right);
        res = max(res, depth);
        --depth;
    }

public:
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
}

// dfs，带返回值
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```


### 111. 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

***python***
```python
# 层序遍历
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        depth = 0
        que = deque([root])
        
        while que:
            depth += 1
            size = len(que)
            for _ in range(size):
                cur = que.popleft()
                if not cur.left and not cur.right:
                    return depth
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return depth

# dfs, 带返回值
class Solution:
    def dfs(self, root: TreeNode) -> int:
        if not root:
            return float('inf')
        if not root.left and not root.right:
            return 1
        return min(self.dfs(root.left), self.dfs(root.right)) + 1

    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return self.dfs(root)

# dfs, 分情况讨论
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        if root.left and not root.right:
            return self.minDepth(root.left) + 1
        elif not root.left and root.right:
            return self.minDepth(root.right) + 1
        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
```

***cpp***
```cpp
// 层序遍历
class Solution {
public:
    int minDepth(TreeNode* root) {
        int depth = 0;
        queue<TreeNode*> que;
        if (root) que.push(root);
        while (!que.empty()) {
            ++depth;
            int size = que.size();
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                if (!cur->left && !cur->right) return depth;
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return depth;
    }
};

// dfs, 带返回值
class Solution {
private:
    int dfs(TreeNode* root) {
        if (!root) return 10001;
        if (!root->left && !root->right) return 1;
        return min(dfs(root->left), dfs(root->right)) + 1;
    }

public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        return dfs(root);
    }
};

// dfs, 分情况讨论
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == nullptr)
            return 0;
        if (root->left && root->right == nullptr)
            return minDepth(root->left) + 1;
        else if (root->left == nullptr && root->right)
            return minDepth(root->right) + 1;
        return min(minDepth(root->left), minDepth(root->right)) + 1;
    }
};
```

### 226. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

***python***
```python
# dfs
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        self.invertTree(root.left)
        self.invertTree(root.right)
        root.left, root.right = root.right, root.left
        return root

# bfs
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        
        stack = [root]
        while stack:
            cur = stack.pop()
            cur.left, cur.right = cur.right, cur.left
            if cur.left:
                stack.append(cur.left)
            if cur.right:
                stack.append(cur.right)
        
        return root
```

***cpp***
```cpp
// dfs
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return root;
        invertTree(root->left);
        invertTree(root->right);
        swap(root->left, root->right);
        return root;
    }
};

// bfs
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            swap(cur->left,cur->right);
            if (cur->left) st.push(cur->left);
            if (cur->right) st.push(cur->right);
        }
        return root;
    }
};
```

### 101. 对称二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

***python***
```python
# 递归
class Solution:
    def compare(self, left: TreeNode, right: TreeNode) -> bool:
        if (left is None and right is not None) or (left is not None and right is None):
            return False
        elif left is None and right is None:
            return True
        elif left.val != right.val:
            return False
        else:
            return self.compare(left.left, right.right) and self.compare(
                left.right, right.left
            )

    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        return self.compare(root.left, root.right)

# 迭代
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        
        stack = []
        stack.append(root.right)
        stack.append(root.left)
        
        while stack:
            left = stack.pop()
            right = stack.pop()
            
            if not left and not right:
                continue
            if not left or not right:
                return False
            if left.val != right.val:
                return False
            
            stack.append(left.left)
            stack.append(right.right)
            stack.append(left.right)
            stack.append(right.left)
        
        return True
```

***cpp***
```cpp
// 递归
class Solution {
public:
    bool compare(TreeNode *left, TreeNode *right) {
        if ((left == nullptr && right != nullptr) || (left != nullptr && right == nullptr))
            return false;
        else if(left == nullptr && right == nullptr) return true;
        else if (left->val != right->val)
            return false;
        else
            return compare(left->left, right->right) && compare(left->right, right->left);
    }

    bool isSymmetric(TreeNode *root) {
        return compare(root->left, root->right);
    }
};


// 迭代
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        stack<TreeNode*> st;
        st.push(root->right);
        st.push(root->left);
        while (!st.empty()) {
            TreeNode* left = st.top();
            st.pop();
            TreeNode* right = st.top();
            st.pop();
            if (!left && !right) continue;
            if (!left && right) return false;
            if (left && !right) return false;
            if (left->val != right->val) return false;
            st.push(left->left);
            st.push(right->right);
            st.push(left->right);
            st.push(right->left);
        }
        return true;
    }
};
```

### 100. 相同的树

[100. 相同的树](https://leetcode.cn/problems/same-tree/description/)

***python***
```python
# 递归
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None and q is None:
            return True
        elif p is None and q is not None:
            return False
        elif p is not None and q is None:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

# 迭代
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        queue = deque()
        queue.append(p)
        queue.append(q)
        
        while queue:
            left = queue.popleft()
            right = queue.popleft()
            
            if not left and not right:
                continue
            if left and not right:
                return False
            if not left and right:
                return False
            if left.val != right.val:
                return False
            
            queue.append(left.left)
            queue.append(right.left)
            queue.append(left.right)
            queue.append(right.right)
        
        return True
```

***cpp***
```cpp
// 递归
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (p == nullptr && q == nullptr)
            return true;
        else if (p == nullptr && q !=nullptr) return false;
        else if (p != nullptr && q ==nullptr) return false;
        else if (p->val != q->val) return false;
        else return (isSameTree(p->left,q->left) && isSameTree(p->right,q->right));
    }
};

// 迭代
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode *> que;
        que.push(p);
        que.push(q);
        while (!que.empty()){
            TreeNode *left = que.front();
            que.pop();
            TreeNode *right = que.front();
            que.pop();
            if (!left && !right) continue;
            if (left && !right) return false;
            if (!left && right) return false;
            if (left->val != right->val) return false;
            que.push(left->left);
            que.push(right->left);
            que.push(left->right);
            que.push(right->right);
        }
        return true;
    }
};
```

### 572. 另一棵树的子树

[572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)

***python***
```python
# 层序 + 逐棵子树对比
class Solution:
    def compare(self, p: TreeNode, q: TreeNode) -> bool:
        stack = []
        stack.append(p)
        stack.append(q)
        
        while stack:
            qNode = stack.pop()
            pNode = stack.pop()
            
            if not qNode and not pNode:
                continue
            elif qNode is None and pNode is not None:
                return False
            elif qNode is not None and pNode is None:
                return False
            elif qNode.val != pNode.val:
                return False
            
            stack.append(pNode.left)
            stack.append(qNode.left)
            stack.append(pNode.right)
            stack.append(qNode.right)
        
        return True

    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        if not root:
            return False
        
        queue = deque()
        queue.append(root)
        
        while queue:
            cur = queue.popleft()
            if self.compare(cur, subRoot):
                return True
            if cur.left:
                queue.append(cur.left)
            if cur.right:
                queue.append(cur.right)
        
        return False


# KMP + 先序遍历
class KMP:
    def getNext(self, vec):
        res = [0] * len(vec)
        length = 0
        i = 1
        while i < len(vec):
            if vec[i].val == vec[length].val:
                length += 1
                res[i] = length
                i += 1
            elif length:
                length = res[length - 1]
            else:
                res[i] = 0
                i += 1
        return res

    def findStart(self, vec, vecsub):
        res = []
        next_arr = self.getNext(vecsub)
        i = 0
        j = 0
        while len(vec) - i >= len(vecsub) - j:
            if vec[i].val == vecsub[j].val:
                i += 1
                j += 1

            if j == len(vecsub):
                res.append(vec[i - j])
                j = next_arr[j - 1]
            elif i < len(vec) and vec[i].val != vecsub[j].val:
                if j != 0:
                    j = next_arr[j - 1]
                else:
                    i += 1
        return res

class Solution:
    def compare(self, p: TreeNode, q: TreeNode) -> bool:
        stack = []
        stack.append(p)
        stack.append(q)
        
        while stack:
            qNode = stack.pop()
            pNode = stack.pop()
            
            if not qNode and not pNode:
                continue
            elif not qNode or not pNode:
                return False
            elif qNode.val != pNode.val:
                return False
            
            stack.append(pNode.left)
            stack.append(qNode.left)
            stack.append(pNode.right)
            stack.append(qNode.right)
        
        return True

    def preorder(self, cur: TreeNode, res: list):
        if cur is None:
            return
        res.append(cur)
        self.preorder(cur.left, res)
        self.preorder(cur.right, res)

    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        vec = []
        vecsub = []
        self.preorder(root, vec)
        self.preorder(subRoot, vecsub)
        
        kmp = KMP()
        res = kmp.findStart(vec, vecsub)
        
        for cur in res:
            if self.compare(cur, subRoot):
                return True
        
        return False 
```

***cpp***
```cpp
// 层序 + 逐棵子树对比
class Solution {
public:
    bool compare(TreeNode *p, TreeNode *q) { // 比较 p 和 q是否为同一棵树
        stack<TreeNode *> st;
        st.push(p);
        st.push(q);
        while (!st.empty()) {
            TreeNode *qNode = st.top();
            st.pop();
            TreeNode *pNode = st.top();
            st.pop();
            if (!qNode && !pNode)
                continue;
            else if (qNode == nullptr && pNode != nullptr)
                return false;
            else if (qNode != nullptr && pNode == nullptr)
                return false;
            else if (qNode->val != pNode->val)
                return false;

            st.push(pNode->left);
            st.push(qNode->left);
            st.push(pNode->right);
            st.push(qNode->right);
        }
        return true;
    }

    bool isSubtree(TreeNode *root, TreeNode *subRoot) {
        queue<TreeNode *> que;
        que.push(root);
        while (!que.empty()) {
            TreeNode *cur = que.front();
            if (compare(cur, subRoot))
                return true;
            que.pop();
            if (cur->left)
                que.push(cur->left);
            if (cur->right)
                que.push(cur->right);
        }
        return false;
    }
};

// 先序遍历 + KMP
class Solution {
public:
    class KMP {
    public:
        vector<int> getNext(vector<TreeNode*> vec) {
            vector<int> res(vec.size(), 0);
            int len = 0; // len 跟踪最长公共前缀
            int i = 1;
            while (i < vec.size()) {
                if (vec[i]->val == vec[len]->val) {
                    ++len;
                    res[i++] = len;
                } else if (len)
                    len = res[len - 1];
                else
                    res[i++] = 0;
            }
            return res;
        }

        vector<TreeNode*> findStart(vector<TreeNode*> vec,
                                    vector<TreeNode*> vecsub) {
            vector<TreeNode*> res;
            vector<int> next = getNext(vecsub);
            int i = 0, j = 0; // i 追踪 vec，j 追踪 vecsub
            while (vec.size() - i >= vecsub.size() - j) {
                if (vec[i]->val == vecsub[j]->val) {
                    i++;
                    j++;
                }

                if (j == vecsub.size()) {
                    res.push_back(vec[i - j]);
                    j = next[j - 1];
                } else if (i < vec.size() && vec[i]->val != vecsub[j]->val) {
                    if (j != 0)
                        j = next[j - 1];
                    else
                        i++;
                }
            }
            return res;
        }
    };

    bool compare(TreeNode* p, TreeNode* q) { // 比较 p 和 q是否为同一棵树
        stack<TreeNode*> st;
        st.push(p);
        st.push(q);
        while (!st.empty()) {
            TreeNode* qNode = st.top();
            st.pop();
            TreeNode* pNode = st.top();
            st.pop();
            if (!qNode && !pNode)
                continue;
            else if (qNode == nullptr && pNode != nullptr)
                return false;
            else if (qNode != nullptr && pNode == nullptr)
                return false;
            else if (qNode->val != pNode->val)
                return false;

            st.push(pNode->left);
            st.push(qNode->left);
            st.push(pNode->right);
            st.push(qNode->right);
        }
        return true;
    }

    void preorder(TreeNode* cur, vector<TreeNode*>& res) {
        if (cur == nullptr)
            return;
        res.push_back(cur);
        preorder(cur->left, res);
        preorder(cur->right, res);
    }

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        vector<TreeNode*> vec;
        vector<TreeNode*> vecsub;
        preorder(root, vec);       // vec 为 root 的先序遍历结果
        preorder(subRoot, vecsub); // vecsub 为 subRoot 的先序遍历结果
        KMP kmp;
        vector<TreeNode*> res = kmp.findStart(vec, vecsub);
        for (TreeNode* cur : res) {
            if (compare(cur, subRoot))
                return true;
        }
        return false;
    }
};
```


### 559. n叉树的最大深度

[559. n叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/)

***python***
```python
# bfs
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        
        queue = deque([root])
        depth = 0
        
        while queue:
            depth += 1
            level_size = len(queue)
            for _ in range(level_size):
                current = queue.popleft()
                for child in current.children:
                    queue.append(child)
        
        return depth 

# dfs
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        
        depth = 0
        for child in root.children:
            depth = max(depth, self.maxDepth(child))
        
        return depth + 1 
```

***cpp***
```cpp
// bfs
class Solution {
public:
    int maxDepth(Node *root) {
        queue<Node *> que;
        int res = 0;
        if (root)
            que.push(root);
        while (!que.empty()) {
            res++;
            int size = que.size();
            while (size--) {
                Node *cur = que.front();
                que.pop();
                for (Node *node : cur->children)
                    que.push(node);
            }
        }
        return res;
    }
};

// dfs
class Solution {
public:
    int maxDepth(Node* root) {
        if (!root) return 0;
        int depth = 0;
        for (Node* cur : root->children)
            depth = max(depth, maxDepth(cur));
        return depth + 1;
    }
};
```


### 222. 完全二叉树的节点个数

[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

***python***
```python
# 层序
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        queue = deque([root])
        count = 0
        
        while queue:
            count += 1
            current = queue.popleft()
            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)
        
        return count

# 递归
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        return self.countNodes(root.left) + self.countNodes(root.right) + 1


# 利用完全二叉树性质
class Solution:
    def isCompleteBinaryTree(self, root: Optional[TreeNode]) -> int:
        left, right = 0, 0
        cur = root
        while cur:
            left += 1
            cur = cur.left
        cur = root
        while cur:
            right += 1
            cur = cur.right

        if left == right:
            return 2**left - 1
        else:
            return -1

    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        temp = self.isCompleteBinaryTree(root)
        if temp != -1:
            return temp

        return self.countNodes(root.left) + self.countNodes(root.right) + 1
```

***cpp***
```cpp
// 层序
class Solution {
public:
    int countNodes(TreeNode* root) {
        queue<TreeNode*> que;
        int res = 0;
        if (root) que.push(root);
        while (!que.empty()) {
            ++res;
            TreeNode* cur = que.front();
            que.pop();
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
        return res;
    }
};


// 递归
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (!root) return 0;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};

// 利用完全二叉树性质
class Solution {
private:
    int isCompleteBinaryTree(TreeNode* root) {
        int left = 0, right = 0;
        TreeNode* cur = root;
        while(cur) {
            ++left;
            cur = cur->left;
        }
        cur = root;
        while (cur) {
            ++right;
            cur = cur->right;
        }
        return left == right ? pow(2, left) - 1 : -1;
    }

public:
    int countNodes(TreeNode* root) {
        if (!root) return 0;
        int temp = isCompleteBinaryTree(root);
        if (-1 != temp) return temp;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

### 110. 平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/description/)

***python***
```python
# bfs 进行逐个判断
class Solution:
    def getHeight(self, root: TreeNode) -> int:
        if not root:
            return 0
        left_height = self.getHeight(root.left)
        right_height = self.getHeight(root.right)
        return max(left_height, right_height) + 1

    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def checkBalance(node: TreeNode) -> int:
            if not node:
                return 0
            left_height = checkBalance(node.left)
            right_height = checkBalance(node.right)
            if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1
        
        return checkBalance(root) != -1

# dfs
class Solution:
    def dfs(self, root: TreeNode) -> tuple[bool, int]:
        if not root:
            return True, 0

        left = self.dfs(root.left)
        right = self.dfs(root.right)

        if not left[0] or not right[0] or abs(left[1] - right[1]) > 1:
            return False, 0

        return True, max(left[1], right[1]) + 1

    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        return self.dfs(root)[0]

# dfs
class Solution:
    def dfs(self, root: TreeNode, flag: list[bool]) -> int:
        if not root or not flag[0]:
            return 0
        left = self.dfs(root.left, flag)
        right = self.dfs(root.right, flag)
        if abs(left - right) > 1:
            flag[0] = False
        return max(left, right) + 1

    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        flag = [True]
        self.dfs(root, flag)
        return flag[0]
```

***cpp***
```cpp
// bfs 进行逐个判断
class Solution {
private:
    int getHeight(TreeNode* root) {
        if (!root) return 0;
        return max(getHeight(root->left), getHeight(root->right)) + 1;
    }

public:
    bool isBalanced(TreeNode* root) {
        queue<TreeNode*> que;
        if (root) que.push(root);
        while (!que.empty()) {
            TreeNode* cur = que.front();
            que.pop();
            if (abs(getHeight(cur->left) - getHeight(cur->right)) > 1)
                return false;
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
        return true;
    }
};

// dfs
class Solution {
private:
    pair<bool, int> dfs(TreeNode* root) {
        if (!root) return {true, 0};
        
        auto left = dfs(root->left);
        auto right = dfs(root->right);
        
        if (!left.first || !right.first || abs(left.second - right.second) > 1)
            return {false, 0};
        
        return {true, max(left.second, right.second) + 1};
    }
public:
    bool isBalanced(TreeNode* root) {
        return dfs(root).first;
    }
};

// dfs
class Solution {
private:
    int dfs(TreeNode* root, bool& flag) {
        if (!root || !flag)
            return 0;
        int left = dfs(root->left, flag);
        int right = dfs(root->right, flag);
        if (abs(left - right) > 1)
            flag = false;
        return max(left, right) + 1;
    }

public:
    bool isBalanced(TreeNode* root) {
        bool flag = true;
        dfs(root, flag);
        return flag;
    }
};
```

### 257. 二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/description/)

***python***
```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        def backtracking(node, path=""):
            if not node:
                return
            if not node.left and not node.right:
                res.append(path + str(node.val))
                return
            backtracking(node.left, path + str(node.val) + "->")
            backtracking(node.right, path + str(node.val) + "->")
        
        backtracking(root)
        return res
```

***cpp***
```cpp
class Solution {
private:
    vector<string> res;
    void backtracking(TreeNode* root, string path = "") {
        if (!root) return;
        if (!root->left && !root->right) {
            res.push_back(path + to_string(root->val));
            return;
        }
        backtracking(root->left, path + to_string(root->val) + "->");
        backtracking(root->right, path + to_string(root->val) + "->");
    }

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        backtracking(root);
        return res;
    }
};
```

### 404. 左叶子之和

[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/description/)

***python***
```python
# bfs 逐个判断
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        que = deque([root])
        sum = 0
        
        while que:
            cur = que.popleft()
            if cur.left and not cur.left.left and not cur.left.right:
                sum += cur.left.val
            if cur.left:
                que.append(cur.left)
            if cur.right:
                que.append(cur.right)
                
        return sum

# dfs
class Solution:
    def dfs(self, root: TreeNode, isLeft: bool) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return root.val if isLeft else 0  # 只有左叶子节点才累加其值
        return self.dfs(root.left, True) + self.dfs(root.right, False)

    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return self.dfs(root, False)
```

***cpp***
```cpp
// 层序，逐个判断
class Solution:
    def dfs(self, root: TreeNode, isLeft: bool) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return root.val if isLeft else 0  # 只有左叶子节点才累加其值
        return self.dfs(root.left, True) + self.dfs(root.right, False)

    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return self.dfs(root, False)

// dfs
class Solution {
private:
    int dfs(TreeNode* root, bool isLeft) {
        if (!root) return 0;
        if (!root->left && !root->right)  // 只有左叶子节点才累加其值
            return isLeft ? root->val : 0;
        return dfs(root->left, true) + dfs(root->right, false);
    }

public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (!root) return 0;
        return dfs(root, false);
    }
}
```

### 513. 找树左下角的值

[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/description/)

***python***
```python
# bfs
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        que = deque([root])
        ans = root.val
        
        while que:
            size = len(que)
            ans = que[0].val  # 第一个节点是当前层的最左边节点
            
            for _ in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
        
        return ans
```

***cpp***
```cpp
// bfs
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        int ans = root->val;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            ans = que.front()->val;
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return ans;
    }
};
```

### 112. 路径总和

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/description/)

***python***
```python
# dfs, 回溯
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        
        if not root.left and not root.right and targetSum == root.val:
            return True
        
        return (self.hasPathSum(root.left, targetSum - root.val) or
                self.hasPathSum(root.right, targetSum - root.val))
```

***cpp***
```cpp
// dfs, 回溯
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root) return false;

        if (!root->left && !root->right && targetSum == root->val)
            return true;
        return hasPathSum(root->left, targetSum - root->val) ||
               hasPathSum(root->right, targetSum - root->val);
    }
};
```

### 113. 路径总和ii

[113. 路径总和ii](https://leetcode-cn.com/problems/path-sum-ii/description/)

***python***
```python
class Solution:
    def backtracking(self, root: TreeNode, targetSum: int):
        if not root:
            return
        targetSum -= root.val
        self.path.append(root.val)

        if not root.left and not root.right and targetSum == 0:
            self.res.append(list(self.path))  # make a copy of the current path

        self.backtracking(root.left, targetSum)
        self.backtracking(root.right, targetSum)
        self.path.pop()

    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.res = []
        self.path = []
        self.backtracking(root, targetSum)
        return self.res
```

***cpp***
```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(TreeNode* root, int targetSum) {
        if (!root) return;
        targetSum -= root->val;
        path.push_back(root->val);

        if (!root->left && !root->right && !targetSum)
            res.push_back(path);

        backtracking(root->left, targetSum);
        backtracking(root->right, targetSum);
        path.pop_back();
    }

public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        backtracking(root, targetSum);
        return res;
    }
};
```

### 106. 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

***python***
```python
class Solution:
    def __init__(self):
        self.umap = {}
        
    def build(self, inorder, il, ir, postorder, pl, pr):
        if pl > pr:
            return None
        root = TreeNode(postorder[pr])  # 创建根节点
        if pl == pr:
            return root  # 仅有一个节点
        index = self.umap[postorder[pr]]
        root.right = self.build(inorder, index + 1, ir, postorder, pr - ir + index, pr - 1)
        root.left = self.build(inorder, il, index - 1, postorder, pl, pr - ir + index - 1)
        return root

    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        for i, val in enumerate(inorder):
            self.umap[val] = i
        return self.build(inorder, 0, len(inorder) - 1, postorder, 0, len(postorder) - 1)
```

***cpp***
```cpp
class Solution {
private:
    unordered_map<int, int> umap;
    TreeNode* build(const vector<int>& inorder, int il, int ir,
                    const vector<int>& postorder, int pl, int pr) {
        if (pl > pr)
            return nullptr;
        TreeNode* root = new TreeNode(postorder[pr]);
        if (pl == pr)
            return root;
        int index = umap[postorder[pr]];
        root->left =
            build(inorder, il, index - 1, postorder, pl, pr - ir + index - 1);
        root->right =
            build(inorder, index + 1, ir, postorder, pr - ir + index, pr - 1);
        return root;
    }

public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for (int i = 0; i < inorder.size(); ++i)
            umap[inorder[i]] = i;
        return build(inorder, 0, inorder.size() - 1, postorder, 0,
                     postorder.size() - 1);
    }
};
```

### 105.从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

***python***
```python
class Solution:
    def __init__(self):
        self.umap = {}

    def build(self, preorder, pl, pr, inorder, il, ir):
        if pl > pr:
            return None
        root = TreeNode(preorder[pl])
        if pl == pr:
            return root
        index = self.umap[preorder[pl]]
        root.left = self.build(preorder, pl + 1, pl + index - il, inorder, il, index - 1)
        root.right = self.build(preorder, pl + index - il + 1, pr, inorder, index + 1, ir)
        return root

    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        self.umap = {val: i for i, val in enumerate(inorder)}
        return self.build(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1)
```


***cpp***
```cpp
class Solution {
private:
    unordered_map<int, int> umap;
    TreeNode* build(const vector<int>& preorder, int pl, int pr,
                    const vector<int>& inorder, int il, int ir) {
        if (pl > pr)
            return nullptr;
        TreeNode* root = new TreeNode(preorder[pl]);
        if (pl == pr)
            return root;
        int index = umap[preorder[pl]];
        root->left =
            build(preorder, pl + 1, pl + index - il, inorder, il, index - 1);
        root->right =
            build(preorder, pl + index - il + 1, pr, inorder, index + 1, ir);
        return root;
    }

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < inorder.size(); ++i)
            umap[inorder[i]] = i;
        return build(preorder, 0, preorder.size() - 1, inorder, 0,
                     inorder.size() - 1);
    }
};
```

### 654. 最大二叉树

[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/description/)

***python***
```python
class Solution:
    def build(self, nums, l, r):
        if l > r:
            return None
        index = l
        for i in range(l, r + 1):
            if nums[i] > nums[index]:
                index = i
        root = TreeNode(nums[index])
        root.left = self.build(nums, l, index - 1)
        root.right = self.build(nums, index + 1, r)
        return root

    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        return self.build(nums, 0, len(nums) - 1)
```

***cpp***
```cpp
class Solution {
private:
    TreeNode* build(const vector<int>& nums, int l, int r) {
        if (l > r) return nullptr;
        int index = l;
        for (int i = l; i <= r; ++i)
            index = nums[index] == max(nums[index], nums[i]) ? index : i;
        TreeNode* root = new TreeNode(nums[index]);
        root->left = build(nums, l, index - 1);
        root->right = build(nums, index + 1, r);
        return root;
    }

public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return build(nums, 0, nums.size() - 1);
    }
};
```

### 617. 合并二叉树

[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)

***python***
```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1:
            return root2
        if root1 and root2:
            root1.val += root2.val
            root1.left = self.mergeTrees(root1.left, root2.left)
            root1.right = self.mergeTrees(root1.right, root2.right)
        return root1
```

***cpp***
```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (!root1) return root2;
        if (root1 && root2) {
            root1->val += root2->val;
            root1->left = mergeTrees(root1->left, root2->left);
            root1->right = mergeTrees(root1->right, root2->right);
        }
        return root1;
    }
};
```

### 700. 二叉搜索树中的搜索

[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/description/)

***python***
```python
# 递归
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root or val == root.val:
            return root
        elif val > root.val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)

# 迭代
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        p = root
        while p:
            if p.val == val:
                return p
            elif p.val < val:
                p = p.right
            else:
                p = p.left
        return None
```

***cpp***
```cpp
// 递归
class Solution {
public:
    TreeNode *searchBST(TreeNode *root, int val) {
        if (!root || val == root->val)
            return root;
        else if (val > root->val)
            return searchBST(root->right, val);
        else
            return searchBST(root->left, val);
    }
};

// 迭代
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        TreeNode *p = root;
        while (p){
            if (p->val == val) return p;
            else if (p->val < val) p = p->right;
            else p = p->left;
        }
        return nullptr;
    }
};
```

### 98. 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/description/)

***python***
```python
class Solution:
    def __init__(self):
        self.pre = None

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        if not self.isValidBST(root.left):
            return False

        # 每一个节点，都问一下它的上一个节点是否比他小
        if self.pre and self.pre.val >= root.val:
            return False
        self.pre = root

        return self.isValidBST(root.right)
```

***cpp***
```cpp
class Solution {
public:
    TreeNode* pre;
    bool isValidBST(TreeNode* root) {
        if (!root) return true;
        
        bool left = isValidBST(root->left);
        // 每一个节点，都问一下它的上一个节点是否比他小
        if (pre && pre->val >= root->val) return false;
        pre = root;

        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

### 530. 二叉搜索树的最小绝对差

[530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/description/)

***python***
```python
class Solution:
    def __init__(self):
        self.pre = None
        self.res = float('inf')

    def dfs(self, root: TreeNode):
        if not root:
            return
        self.dfs(root.left)
        if self.pre is not None:
            self.res = min(self.res, root.val - self.pre.val)
        self.pre = root
        self.dfs(root.right)

    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        self.dfs(root)
        return self.res 
```

***cpp***
```cpp
class Solution {
private:
    TreeNode *pre = nullptr;
    int res = 100000;
    void dfs(TreeNode *root){
        if (!root) return;
        dfs(root->left);
        if (pre) res = min(res, root->val - pre->val);
        pre = root;
        dfs(root->right);
    }


public:
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

### 501.二叉搜索树中的众数

[501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/description/)

***python***
```python
class Solution:
    def __init__(self):
        self.res = []
        self.fre = 0
        self.max_fre = 0
        self.pre = None

    def dfs(self, root):
        if not root:
            return

        self.dfs(root.left)  # 左

        if not self.pre or self.pre.val == root.val:
            self.fre += 1
        else:
            self.fre = 1
        self.pre = root

        if self.fre == self.max_fre:
            self.res.append(root.val)
        if self.fre > self.max_fre:
            self.res.clear()
            self.res.append(root.val)
            self.max_fre = self.fre

        self.dfs(root.right)  # 右

    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        self.dfs(root)
        return self.res

# 优化后
class Solution:
    def __init__(self):
        self.res = []
        self.fre = 0
        self.max_fre = 0
        self.pre = None

    def dfs(self, root):
        if not root:
            return

        self.dfs(root.left)  # 左

        if not self.pre or self.pre.val == root.val:
            self.fre += 1
        else:
            if self.fre == self.max_fre:
                self.res.append(self.pre.val)
            elif self.fre > self.max_fre:
                self.res.clear()
                self.res.append(self.pre.val)
                self.max_fre = self.fre
            self.fre = 1

        self.pre = root
        self.dfs(root.right)  # 右

    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        self.dfs(root)
        if self.fre == self.max_fre:
            self.res.append(self.pre.val)
        elif self.fre > self.max_fre:
            self.res.clear()
            self.res.append(self.pre.val)
        return self.res
```

***cpp***
```cpp
class Solution {
private:
    vector<int> res;
    int fre = 0, max_fre = 0;
    TreeNode *pre = nullptr;
    void dfs(TreeNode *root) {
        if (!root) return;

        dfs(root->left);    // 左

        if (!pre || pre->val == root->val) ++fre;
        else fre = 1;
        pre = root;

        if (fre == max_fre) res.push_back(root->val);
        if (fre > max_fre) {
            res.clear();
            res.push_back(root->val);
            max_fre = fre;
        }

        dfs(root->right);   // 右
    }
public:
    vector<int> findMode(TreeNode* root) {
        dfs(root);
        return res;
    }
};

// 优化后
class Solution {
private:
    vector<int> res;
    int fre = 0, max_fre = 0;
    TreeNode* pre = nullptr;
    void dfs(TreeNode* root) {
        if (!root)
            return;

        dfs(root->left); // 左

        if (!pre || pre->val == root->val)
            ++fre;
        else {
            if (fre == max_fre)
                res.push_back(pre->val);
            else if (fre > max_fre) {
                res.clear();
                res.push_back(pre->val);
                max_fre = fre;
            }
            fre = 1;
        }
        pre = root;
        dfs(root->right); // 右
    }

public:
    vector<int> findMode(TreeNode* root) {
        dfs(root);
        if (fre == max_fre)
            res.push_back(pre->val);
        else if (fre > max_fre) {
            res.clear();
            res.push_back(pre->val);
        }
        return res;
    }
};
```

### 236. 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

***python***
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None or root == p or root == q:
            return root

        left = self.lowestCommonAncestor(root.left, p, q)  # 左
        right = self.lowestCommonAncestor(root.right, p, q)  # 右

        if left and right:
            return root
        elif left:
            return left
        else:
            return right 
```

***cpp***
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q)
            return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if (left && right) return root;
        else if (left) return left;
        else return right;
    }
};
```

### 235. 二叉搜索树的最近公共祖先

[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

***python***
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            if p.val < root.val and q.val < root.val:  # 在左侧
                root = root.left
            elif p.val > root.val and q.val > root.val:  # 在右侧
                root = root.right
            else:
                return root
        return None
```

***cpp***
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while (root) {
            if (p->val < root->val && q->val < root->val) // 在左侧
                root = root->left;
            else if (p->val > root->val && q->val > root->val) // 在右侧
                root = root->right;
            else
                return root;
        }
        return nullptr;
    }
};
```


### 701. 二叉搜索树中的插入操作

[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/description/)

***python***
```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)

        cur = root
        while cur:
            if val < cur.val:
                if not cur.left:
                    cur.left = TreeNode(val)
                    break
                else:
                    cur = cur.left
            else:
                if not cur.right:
                    cur.right = TreeNode(val)
                    break
                else:
                    cur = cur.right
        return root
```

***cpp***
```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (!root) return new TreeNode(val);

        TreeNode *cur = root, *pre = nullptr;
        while (cur) {
            pre = cur;
            cur = val < cur->val ? cur->left : cur->right;
        }
        val < pre->val ? pre->left = new TreeNode(val)
                       : pre->right = new TreeNode(val);
        return root;
    }
};
```

### 450. 删除二叉搜索树中的节点

[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/description/)

***python***
```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
            
        if root.val == key:
            if root.left and root.right:
                p = root.right
                while p.left:
                    p = p.left
                p.left = root.left
                return root.right
            elif root.left:
                return root.left
            else:
                return root.right

        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        if root.val < key:
            root.right = self.deleteNode(root.right, key)
        return root
```

***cpp***
```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root)
            return nullptr;
            
        if (root->val == key) {
            if (root->left && root->right) {
                TreeNode* p = root->right;
                while (p->left)
                    p = p->left;
                p->left = root->left;
                return root->right;
            }
            else if (root->left) return root->left;
            else return root->right;
        }

        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```

### 669. 修剪二叉搜索树

[669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/)

***python***
```python
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if not root:
            return None
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        if root.val < low:
            return root.right
        if root.val > high:
            return root.left
        return root
```

***cpp***
```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (!root) return nullptr;
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        if (root->val < low) return root->right;
        if (root->val > high) return root->left;
        return root;
    }
};
```


### 108.将有序数组转换为二叉搜索树

[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/)

***python***
```python
class Solution:
    def build(self, nums, l, r):
        if l > r:
            return None
        mid = (l + r) // 2
        root = TreeNode(nums[mid])
        root.left = self.build(nums, l, mid - 1)
        root.right = self.build(nums, mid + 1, r)
        return root

    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        return self.build(nums, 0, len(nums) - 1)
```

***cpp***
```cpp
class Solution {
private:
    TreeNode* build(const vector<int>& nums, int l, int r) {
        if (l > r) return nullptr;
        int mid = l + (r - l) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = build(nums, l, mid - 1);
        root->right = build(nums, mid + 1, r);
        return root;
    }

public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return build(nums, 0, nums.size() - 1);
    }
};
```

### 538.把二叉搜索树转换为累加树

[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/description/)

***python***
```python
class Solution:
    def __init__(self):
        self.pre = None

    def dfs(self, root):
        if not root:
            return
        self.dfs(root.right)

        if self.pre:
            root.val += self.pre.val
        self.pre = root

        self.dfs(root.left)

    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.dfs(root)
        return root
```

***cpp***
```cpp
class Solution {
private:
    TreeNode *pre = nullptr;
    void dfs(TreeNode *root) {
        if (!root) return;
        dfs(root->right);

        if (pre) root->val += pre->val;
        pre = root;

        dfs(root->left);
    }

public:
    TreeNode* convertBST(TreeNode* root) {
        dfs(root);
        return root;
    }
};
```

## 8 回溯算法

### 77. 组合

[77. 组合](https://leetcode-cn.com/problems/combinations/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, n, k, start):
        if len(self.path) == k:
            self.res.append(self.path[:])
            return
        for i in range(start, n - (k - len(self.path)) + 2):
            self.path.append(i)
            self.backtracking(n, k, i + 1)
            self.path.pop()

    def combine(self, n: int, k: int) -> List[List[int]]:
        self.backtracking(n, k, 1)
        return self.res
```

```cpp
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const int& n, const int& k, int start) {
        if (path.size() == k) {
            res.push_back(path);
            return;
        }
        for (int i = start; i <= n - (k - path.size()) + 1; ++i) {
            path.push_back(i);
            backtracking(n, k, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return res;
    }
};
```

### 216. 组合总和 III

[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, k, n, start):
        if n == 0 and len(self.path) == k:
            self.res.append(self.path[:])
            return
        for i in range(start, 10):
            if n - i < 0 or 10 - i < k - len(self.path):
                return
            self.path.append(i)
            self.backtracking(k, n - i, i + 1)
            self.path.pop()

    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        self.backtracking(k, n, 1)
        return self.res
```

```cpp
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(int k, int n, int start) {
        if (!n && path.size() == k) {
            res.push_back(path);
            return;
        }
        for (int i = start; i <= 9; ++i){
            if (n - i < 0 || 10 - i < k - path.size()) return;
            path.push_back(i);
            backtracking(k, n - i, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k, n, 1);
        return res;
    }
};
```

### 17. 电话号码的字母组合

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/)

```python
class Solution:
    def __init__(self):
        self.letterMap = [
            "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
        ]
        self.path = []
        self.res = []

    def backtracking(self, digits, start):
        if len(self.path) == len(digits):
            self.res.append("".join(self.path))
            return
        for i in range(start, len(digits)):
            for c in self.letterMap[int(digits[i])]:
                self.path.append(c)
                self.backtracking(digits, i + 1)
                self.path.pop()

    def letterCombinations(self, digits: str) -> List[str]:
        if digits:
            self.backtracking(digits, 0)
        return self.res
```

```cpp
class Solution {
private:
    const string letterMap[10] = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxzy"
    };
    string path;
    vector<string> res;

    void backtracking(const string &digits, int start){
        if (path.size() == digits.size()){
            res.push_back(path);
            return;
        }
        for (int i = start; i < digits.size(); ++i)
            for (const char &c : letterMap[digits[i] - '0']){
                path.push_back(c);
                backtracking(digits, i + 1);
                path.pop_back();
            }
    }
public:
    vector<string> letterCombinations(string digits) {
        if (digits.size()) backtracking(digits, 0);
        return res;
    }
};
```

### 39. 组合总和

[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, candidates, target, start):
        if target == 0:
            self.res.append(list(self.path))
            return
        for i in range(start, len(candidates)):
            if target < candidates[i]:
                continue
            self.path.append(candidates[i])
            self.backtracking(candidates, target - candidates[i], i)
            self.path.pop()

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self.res = []
        self.path = []
        self.backtracking(candidates, target, 0)
        return self.res 
```

```cpp
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(vector<int>& candidates, int target, int start) {
        if (!target) {
            res.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size(); ++i) {
            if (target < candidates[i]) continue;
            path.push_back(candidates[i]);
            backtracking(candidates, target - candidates[i], i);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates, target, 0);
        return res;
    }
};
```

### 40. 组合总和II

[40. 组合总和II](https://leetcode-cn.com/problems/combination-sum-ii/description/)

```python
# used 数组去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, candidates, target, used, start):
        if target == 0:
            self.res.append(list(self.path))
            return
        for i in range(start, len(candidates)):
            if candidates[i] > target:
                break
            if i > start and candidates[i] == candidates[i - 1] and not used[i - 1]:
                continue
            self.path.append(candidates[i])
            used[i] = True
            self.backtracking(candidates, target - candidates[i], used, i + 1)
            used[i] = False
            self.path.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        used = [False] * len(candidates)
        self.res = []
        self.path = []
        self.backtracking(candidates, target, used, 0)
        return self.res


# set 去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, candidates, target, start):
        if target == 0:
            self.res.append(list(self.path))
            return
        uset = [False] * 51
        for i in range(start, len(candidates)):
            if candidates[i] > target:
                break
            if uset[candidates[i]]:
                continue
            else:
                uset[candidates[i]] = True
                self.path.append(candidates[i])
                self.backtracking(candidates, target - candidates[i], i + 1)
                self.path.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        self.res = []
        self.path = []
        self.backtracking(candidates, target, 0)
        return self.res
```

```cpp
// used 数组去重
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(vector<int>& candidates, int target, vector<bool>& used,
                      int start) {
        if (!target) {
            res.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size() && candidates[i] <= target; ++i) {
            if (i && candidates[i] == candidates[i - 1] && !used[i - 1])
                continue;
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates, target - candidates[i], used, i + 1);
            used[i] = false;
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, used, 0);
        return res;
    }
};

// set 去重
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;

    void backtracking(vector<int>& candidates, int target, int start) {
        if (!target) {
            res.push_back(path);
            return;
        }
        bool uset[51] = {false};
        for (int i = start; i < candidates.size() && candidates[i] <= target;
             ++i) {
            if (uset[candidates[i]]) continue;
            else {
                uset[candidates[i]] = true;
                path.push_back(candidates[i]);
                backtracking(candidates, target - candidates[i], i + 1);
                path.pop_back();
            }
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0);
        return res;
    }
};
```

### 131. 分割回文串

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def isPalindrome(self, s, left, right):
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True

    def backtracking(self, s, startIndex):
        if startIndex == len(s):
            self.res.append(list(self.path))
            return
        for i in range(startIndex, len(s)):
            if self.isPalindrome(s, startIndex, i):
                self.path.append(s[startIndex:i+1])
                self.backtracking(s, i + 1)
                self.path.pop()

    def partition(self, s: str) -> List[List[str]]:
        self.res = []
        self.path = []
        self.backtracking(s, 0)
        return self.res
```

```cpp
class Solution {
private:
    vector<string> path;
    vector<vector<string>> res;
    bool isPalinrome(const string& s, int left, int right) {
        while (left < right)
            if (s[left++] != s[right--])
                return false;
        return true;
    }

    void backtracking(const string& s, int startIndex) {
        if (startIndex == s.size()) {
            res.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); ++i){
            if (isPalinrome(s, startIndex, i)){
                path.push_back(s.substr(startIndex, i - startIndex + 1));
                backtracking(s, i + 1);
                path.pop_back();
            }
        }
    }

public:
    vector<vector<string>> partition(string s) {
        backtracking(s, 0);
        return res;
    }
};
```

### 93. 复原IP地址

[93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/description/)

```python
class Solution:
    def __init__(self):
        self.res = []

    def isValid(self, s, left, right):
        if left == right:
            return True
        elif s[left] == '0':
            return False
        num = 0
        while left <= right:
            num = num * 10 + (ord(s[left]) - ord('0'))
            left += 1
        return num >= 1 and num <= 255

    def backtracking(self, s, path, startIndex, layer):
        if layer == 4:
            if startIndex == len(s):
                self.res.append(path[:-1])
            return
        for i in range(startIndex, len(s)):
            if i - startIndex < 3 and len(s) - startIndex <= (4 - layer) * 3 and self.isValid(s, startIndex, i):
                self.backtracking(s, path + s[startIndex:i+1] + ".", i + 1, layer + 1)

    def restoreIpAddresses(self, s: str) -> List[str]:
        self.res = []
        self.backtracking(s, "", 0, 0)
        return self.res
```

```cpp
class Solution {
private:
    vector<string> res;
    bool isValid(const string& s, int left, int right) {
        if (left == right)
            return true;
        else if (s[left] == '0')
            return false;
        int num = 0;
        while (left <= right)
            num = num * 10 + (s[left++] - '0');
        return num >= 1 && num <= 255;
    }
    void backtracking(const string& s, string path, int startIndex, int layer) {
        if (4 == layer) {
            if (startIndex == s.size()) {
                res.push_back(path);
                res.back().resize(path.size() - 1);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); ++i)
            if (i - startIndex < 3 && s.size() - startIndex <= (4 - layer) * 3 &&
                isValid(s, startIndex, i))
                backtracking(
                    s, path + s.substr(startIndex, i - startIndex + 1) + ".",
                    i + 1, layer + 1);
    }

public:
    vector<string> restoreIpAddresses(string s) {
        string path;
        backtracking(s, path, 0, 0);
        return res;
    }
};
```

### 78. 子集

[78. 子集](https://leetcode-cn.com/problems/subsets/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, startIndex):
        self.res.append(list(self.path))
        for i in range(startIndex, len(nums)):
            self.path.append(nums[i])
            self.backtracking(nums, i + 1)
            self.path.pop()

    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        self.path = []
        self.backtracking(nums, 0)
        return self.res
```

```cpp
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& nums, int startIndex) {
        res.push_back(path);
        for (int i = startIndex; i < nums.size(); ++i) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums, 0);
        return res;
    }
};
```

### 90. 子集II

[90. 子集II](https://leetcode-cn.com/problems/subsets-ii/description/)

```python
# used 数组去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, used, startIndex):
        self.res.append(list(self.path))
        for i in range(startIndex, len(nums)):
            if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                continue
            self.path.append(nums[i])
            used[i] = True
            self.backtracking(nums, used, i + 1)
            used[i] = False
            self.path.pop()

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        used = [False] * len(nums)
        self.res = []
        self.path = []
        self.backtracking(nums, used, 0)
        return self.res


# set 去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, startIndex):
        self.res.append(list(self.path))
        used = [False] * 21  # Python doesn't have fixed-size arrays, so we use a list
        for i in range(startIndex, len(nums)):
            if not used[nums[i] + 10]:
                used[nums[i] + 10] = True
                self.path.append(nums[i])
                self.backtracking(nums, i + 1)
                self.path.pop()

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        self.res = []
        self.path = []
        self.backtracking(nums, 0)
        return self.res
```

```cpp
// used 数组去重
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& nums, vector<bool>& used,
                      int startIndex) {
        res.push_back(path);
        for (int i = startIndex; i < nums.size(); ++i) {
            if (i && nums[i] == nums[i - 1] && !used[i - 1])
                continue;
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, used, i + 1);
            used[i] = false;
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<bool> uesd(nums.size(), false);
        backtracking(nums, uesd, 0);
        return res;
    }
};

// set 去重
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& nums, int startIndex) {
        res.push_back(path);
        bool arr[21] = {false};
        for (int i = startIndex; i < nums.size(); ++i) {
            if (!arr[nums[i] + 10]) {
                arr[nums[i] + 10] = true;
                path.push_back(nums[i]);
                backtracking(nums, i + 1);
                path.pop_back();
            }
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        backtracking(nums, 0);
        return res;
    }
};
```

### 491. 非递减子序列

[491. 非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

```python
# 没有说有序，使用 set 去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, startIndex):
        if len(self.path) > 1:
            self.res.append(list(self.path))

        uset = set()
        for i in range(startIndex, len(nums)):
            if nums[i] in uset:
                continue
            if not self.path or nums[i] >= self.path[-1]:
                self.path.append(nums[i])
                uset.add(nums[i])
                self.backtracking(nums, i + 1)
                self.path.pop()

    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        self.path = []
        self.backtracking(nums, 0)
        return self.res
```

```cpp
// 没有说有序，使用 set 去重
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& nums, int startIndex) {
        if (path.size() > 1)
            res.push_back(path);

        unordered_set<int> uset;
        for (int i = startIndex; i < nums.size(); ++i) {
            if (uset.find(nums[i]) != uset.end())
                continue;
            if (!path.size() || nums[i] >= path.back()) {
                path.push_back(nums[i]);
                uset.insert(nums[i]);
                backtracking(nums, i + 1);
                path.pop_back();
            }
        }
    }

public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums, 0);
        return res;
    }
};
```

### 46. 全排列

[46. 全排列](https://leetcode-cn.com/problems/permutations/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, used):
        if len(self.path) == len(nums):
            self.res.append(list(self.path))
            return
        for i in range(len(nums)):
            if not used[i]:
                self.path.append(nums[i])
                used[i] = True
                self.backtracking(nums, used)
                self.path.pop()
                used[i] = False

    def permute(self, nums: List[int]) -> List[List[int]]:
        used = [False] * len(nums)
        self.res = []
        self.path = []
        self.backtracking(nums, used)
        return self.res
```

```cpp
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); ++i) {
            if (!used[i]) {
                path.push_back(nums[i]);
                used[i] = true;
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }

public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return res;
    }
};
```

### 47. 全排列 II

[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/description/)

```python
# 也可以使用 set 控制节点内去重， used 控制路径去重

class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, used):
        if len(self.path) == len(nums):
            self.res.append(list(self.path))
            return
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                continue
            if not used[i]:
                used[i] = True
                self.path.append(nums[i])
                self.backtracking(nums, used)
                self.path.pop()
                used[i] = False

    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        used = [False] * len(nums)
        self.res = []
        self.path = []
        self.backtracking(nums, used)
        return self.res
```

```cpp
// 也可以使用 set 控制节点内去重， used 控制路径去重

class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); ++i) {
            if (i && nums[i] == nums[i - 1] && !used[i - 1]) continue;
            if (!used[i]) {
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }

public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return res;
    }
};
```

### 332. 重新安排行程

[332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/description/)

```python
class Solution:
    def __init__(self):
        self.graph = defaultdict(lambda: defaultdict(int))
        self.res = []

    def backtracking(self, num):
        if len(self.res) == num:
            return True
        for to, count in sorted(self.graph[self.res[-1]].items()):
            if count > 0:
                self.res.append(to)
                self.graph[self.res[-2]][to] -= 1
                if self.backtracking(num):
                    return True
                self.res.pop()
                self.graph[self.res[-1]][to] += 1
        return False

    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        for ticket in tickets:
            self.graph[ticket[0]][ticket[1]] += 1
        self.res.append("JFK")
        self.backtracking(len(tickets) + 1)
        return self.res
```

```cpp
// 使用 map 保存 graph，使用 map 保存 graph[to]，并且使用 map 保存 graph[to] 的次数
class Solution {
  unordered_map<string, map<string, int>> graph;
  vector<string> res;

private:
  void backtracking(const int &num) {
    if (res.size() == num)
      return;
    for (auto &[to, count] : graph[res.back()]) {
      if (count > 0) {
        res.push_back(to);
        --count;
        backtracking(num);
        if (res.size() == num) // 防止 res.size() == num 时回溯，导致结果被 pop_back
          return;
        res.pop_back();
        ++count;
      }
    }
  }

public:
  vector<string> findItinerary(vector<vector<string>> &tickets) {
    for (auto &ticket : tickets)
      ++graph[ticket[0]][ticket[1]];
    res.push_back("JFK");
    backtracking(tickets.size() + 1);
    return res;
  }
};
```

### 51. N皇后

[51. N皇后](https://leetcode-cn.com/problems/n-queens/description/)

```python
class Solution:
    def __init__(self):
        self.res = []

    def isValid(self, row, col, chessboard):
        # Check the column for a queen
        for i in range(row):
            if chessboard[i][col] == 'Q':
                return False

        # Check the 45 degree diagonal
        i, j = row - 1, col + 1
        while i >= 0 and j < len(chessboard):
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j += 1

        # Check the 135 degree diagonal
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j -= 1

        return True

    def backtracking(self, row, chessboard):
        if row == len(chessboard):
            self.res.append([''.join(row) for row in chessboard])
            return

        for col in range(len(chessboard)):
            if self.isValid(row, col, chessboard):
                chessboard[row][col] = 'Q'
                self.backtracking(row + 1, chessboard)
                chessboard[row][col] = '.'

    def solveNQueens(self, n: int) -> List[List[str]]:
        chessboard = [['.' for _ in range(n)] for _ in range(n)]
        self.backtracking(0, chessboard)
        return self.res
```

```cpp
class Solution {
private:
  vector<vector<string>> res;
  bool isValid(const int &row, const int &col,
               const vector<string> &chessboard) {
    for (int i = 0; i < row; ++i)
      if (chessboard[i][col] == 'Q')
        return false;

    for (int i = row - 1, j = col + 1; i >= 0 && j < chessboard.size();
         --i, ++j)
      if (chessboard[i][j] == 'Q')
        return false;

    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)
      if (chessboard[i][j] == 'Q')
        return false;

    return true;
  }

  void backtracking(int row, vector<string> &chessboard) {
    if (row == chessboard.size()) {
      res.push_back(chessboard);
      return;
    }
    for (int col = 0; col < chessboard.size(); ++col) {
      if (isValid(row, col, chessboard)) {
        chessboard[row][col] = 'Q';
        backtracking(row + 1, chessboard);
        chessboard[row][col] = '.';
      }
    }
  }

public:
  vector<vector<string>> solveNQueens(int n) {
    vector<string> chessboard(n, string(n, '.'));
    backtracking(0, chessboard);
    return res;
  }
};
```

### 37. 解数独

[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/description/)

```python
class Solution:
    def isValid(self, row, col, k, board):
        for j in range(9):
            if board[row][j] == k:
                return False

        for i in range(9):
            if board[i][col] == k:
                return False

        startrow, startcol = (row // 3) * 3, (col // 3) * 3
        for i in range(startrow, startrow + 3):
            for j in range(startcol, startcol + 3):
                if board[i][j] == k:
                    return False

        return True

    def backtracking(self, board, row, col):
        if row == 9:
            return True

        if col == 9:
            return self.backtracking(board, row + 1, 0)

        if board[row][col] != '.':
            return self.backtracking(board, row, col + 1)

        for k in '123456789':
            if self.isValid(row, col, k, board):
                board[row][col] = k
                if self.backtracking(board, row, col + 1):
                    return True
                board[row][col] = '.'

        return False

    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        self.backtracking(board, 0, 0)
```

```cpp
class Solution {
private:
  bool isValid(int row, int col, char k, vector<vector<char>> &board) {
    for (int j = 0; j < 9; ++j) // 查看同行
      if (board[row][j] == k)
        return false;

    for (int i = 0; i < 9; ++i) // 查看同列
      if (board[i][col] == k)
        return false;

    int startrow = (row / 3) * 3;
    int startcol = (col / 3) * 3;
    for (int i = startrow; i < startrow + 3; ++i)
      for (int j = startcol; j < startcol + 3; ++j)
        if (board[i][j] == k)
          return false;

    return true;
  }

  bool backtracking(vector<vector<char>> &board) {
    for (int i = 0; i < 9; ++i) {
      for (int j = 0; j < 9; ++j) {
        if (board[i][j] != '.')
          continue;
        for (char k = '1'; k <= '9'; ++k) {
          if (isValid(i, j, k, board)) {
            board[i][j] = k;
            if (backtracking(board))
              return true;
            board[i][j] = '.';
          }
        }
        return false;
      }
    }
    return true;
  }

public:
  void solveSudoku(vector<vector<char>> &board) { backtracking(board); }
};

// 优化后
class Solution {
private:
  bool isValid(int row, int col, char k, vector<vector<char>> &board) {
    for (int j = 0; j < 9; ++j)
      if (board[row][j] == k)
        return false;

    for (int i = 0; i < 9; ++i)
      if (board[i][col] == k)
        return false;

    int startrow = (row / 3) * 3;
    int startcol = (col / 3) * 3;
    for (int i = startrow; i < startrow + 3; ++i)
      for (int j = startcol; j < startcol + 3; ++j)
        if (board[i][j] == k)
          return false;

    return true;
  }

  void backtracking(vector<vector<char>> &board, int row, int col, bool &flag) {
    if (row == 9) {
      flag = true;
      return;
    }

    if (col == 9) {
      backtracking(board, row + 1, 0, flag);
      return;
    }

    if (board[row][col] != '.') {
      backtracking(board, row, col + 1, flag);
      return;
    }

    for (char k = '1'; k <= '9'; ++k) {
      if (isValid(row, col, k, board)) {
        board[row][col] = k;
        backtracking(board, row, col + 1, flag);
        if (flag)
          return;
        board[row][col] = '.';
      }
    }
  }

public:
  void solveSudoku(vector<vector<char>> &board) {
    bool flag = false;
    backtracking(board, 0, 0, flag);
  }
};
```


---------------------------------

## 9 贪心算法

### 455. 分发饼干

[455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/description/)

```python
```

```cpp
```

### 376. 摆动序列

[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/description/)

```python
```

```cpp
```

### 53. 最大子序和

[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/description/)

```python
```

```cpp
```

### 122. 买卖股票的最佳时机 II

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

```python
```

```cpp
```

### 55. 跳跃游戏

[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/description/)

```python
```

```cpp
```

### 45. 跳跃游戏 II

[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/description/)

```python
```

```cpp
```

### 1005. K次取反后最大化的数组和

[1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/description/)

```python
```

```cpp
```

### 134. 加油站

[134. 加油站](https://leetcode-cn.com/problems/gas-station/description/)

```python
```

```cpp
```

### 135. 分发糖果

[135. 分发糖果](https://leetcode-cn.com/problems/candy/description/)

```python
```

```cpp
```

### 860. 柠檬水找零

[860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/description/)

```python
```

```cpp
```

### 406. 根据身高重建队列

[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/)

```python
```

```cpp
```

### 452. 用最少数量的箭引爆气球

[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)

```python
```

```cpp
```

### 435. 无重叠区间

[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/description/)

```python
```

```cpp
```

### 763. 划分字母区间

[763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/description/)

```python
```

```cpp
```

### 56. 合并区间

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/description/)

```python
```

```cpp
```

### 738. 单调递增的数字

[738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/description/)

```python
```

```cpp
```

### 968. 监控二叉树

[968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/description/)

```python
```

```cpp
```


---------------------------------








### 1553. 吃掉 N 个橘子的最少天数

[1553. 吃掉 N 个橘子的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/description/)

***python***

```python
class Solution:
    memo = {0: 0, 1: 1, 2: 2}

    def minDays(self, n: int) -> int:
        if n in self.memo:
            return self.memo[n]

        self.memo[n] = min(self.minDays(n // 2) + n % 2, self.minDays(n // 3) + n % 3) + 1
        return self.memo[n]
```

***cpp***

```cpp
// 动态规划超时
class Solution {
public:
    int minDays(int n) {
        if (n == 1 || n == 2)  return n;
        if (n == 3) return 2;
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2, dp[3] = 2;
        for (int i = 4; i <= n; i++) {
            int res1 = i, res2 = i;
            if (i % 2 == 0)
                res1 = dp[i / 2] + 1;
            if (i % 3 == 0)
                res2 = dp[i / 3] + 1;
            dp[i] = min({res1, res2, dp[i - 1] + 1});
        }
        return dp[n];
    }
};

// memo
class Solution {
public:
    unordered_map<int, int> umap{{1, 1}, {2, 2}};

    int minDays(int n) {
        if (umap.count(n))
            return umap[n];
        int d2 = n % 2, d3 = n % 3;
        return umap[n] = min(d2 + minDays(n / 2), d3 + minDays(n / 3)) + 1;
    }
};
```