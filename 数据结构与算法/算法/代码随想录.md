- [1 数组](#1-数组)
  - [704. 二分查找](#704-二分查找)
  - [35. 搜索插入位置](#35-搜索插入位置)
  - [34. 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)
  - [69. x 的平方根](#69-x-的平方根)
  - [367. 有效的完全平方数](#367-有效的完全平方数)
  - [27. 移除元素](#27-移除元素)
  - [26. 删除排序数组中的重复项](#26-删除排序数组中的重复项)
  - [283. 移动零](#283-移动零)
  - [844. 比较含退格的字符串](#844-比较含退格的字符串)
  - [977. 有序数组的平方](#977-有序数组的平方)
  - [209. 长度最小的子数组](#209-长度最小的子数组)
  - [904. 水果成篮](#904-水果成篮)
  - [76. 最小覆盖子串](#76-最小覆盖子串)
  - [59. 螺旋矩阵 II](#59-螺旋矩阵-ii)
  - [54. 螺旋矩阵](#54-螺旋矩阵)
  - [剑指 Offer 29. 顺时针打印矩阵](#剑指-offer-29-顺时针打印矩阵)
- [2 链表](#2-链表)
  - [203.移除链表元素](#203移除链表元素)
  - [707. 设计链表](#707-设计链表)
  - [206.反转链表](#206反转链表)
  - [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
  - [19.删除链表的倒数第 N 个节点](#19删除链表的倒数第-n-个节点)
  - [面试题 02.07. 链表相交](#面试题-0207-链表相交)
  - [142.环形链表 II](#142环形链表-ii)
- [3 哈希表](#3-哈希表)
  - [242.有效的字母异位词](#242有效的字母异位词)
  - [383. 赎金信](#383-赎金信)
  - [49. 字母异位词分组](#49-字母异位词分组)
  - [438. 找到字符串中所有字母异位词](#438-找到字符串中所有字母异位词)
  - [349. 两个数组的交集](#349-两个数组的交集)
  - [350. 两个数组的交集 II](#350-两个数组的交集-ii)
  - [202. 快乐数](#202-快乐数)
  - [1. 两数之和](#1-两数之和)
  - [454. 四数相加 II](#454-四数相加-ii)
  - [15. 三数之和](#15-三数之和)
  - [18. 四数之和](#18-四数之和)
- [4 字符串](#4-字符串)
  - [344. 反转字符串](#344-反转字符串)
  - [541. 反转字符串 II](#541-反转字符串-ii)
  - [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试)
  - [151. 翻转字符串里的单词](#151-翻转字符串里的单词)
  - [55. 右旋字符串（第八期模拟笔试）](#55-右旋字符串第八期模拟笔试)
  - [28. 找出字符串中第一个匹配项的下标](#28-找出字符串中第一个匹配项的下标)
    - [KMP](#kmp)
  - [459.重复的子字符串](#459重复的子字符串)
- [5 双指针](#5-双指针)
  - [27. 移除元素](#27-移除元素-1)
  - [344. 反转字符串](#344-反转字符串-1)
  - [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试-1)
  - [151. 翻转字符串里的单词](#151-翻转字符串里的单词-1)
  - [206.反转链表](#206反转链表-1)
  - [19.删除链表的倒数第 N 个节点](#19删除链表的倒数第-n-个节点-1)
  - [面试题 02.07. 链表相交](#面试题-0207-链表相交-1)
  - [142.环形链表 II](#142环形链表-ii-1)
  - [15. 三数之和](#15-三数之和-1)
  - [18. 四数之和](#18-四数之和-1)
- [6 栈与队列](#6-栈与队列)
  - [232. 用栈实现队列](#232-用栈实现队列)
  - [225. 用队列实现栈](#225-用队列实现栈)
  - [20. 有效的括号](#20-有效的括号)
  - [1047. 删除字符串中的所有相邻重复项](#1047-删除字符串中的所有相邻重复项)
  - [150. 逆波兰表达式求值](#150-逆波兰表达式求值)
  - [239. 滑动窗口最大值](#239-滑动窗口最大值)
  - [347.前 K 个高频元素](#347前-k-个高频元素)
- [7 二叉树](#7-二叉树)
  - [144. 二叉树的前序遍历](#144-二叉树的前序遍历)
  - [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
  - [145. 二叉树的后序遍历](#145-二叉树的后序遍历)
  - [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
  - [107. 二叉树的层序遍历 II](#107-二叉树的层序遍历-ii)
  - [199. 二叉树的右视图](#199-二叉树的右视图)
  - [637. 二叉树的层平均值](#637-二叉树的层平均值)
  - [429. N 叉树的层序遍历](#429-n-叉树的层序遍历)
  - [515. 在每个树行中找最大值](#515-在每个树行中找最大值)
  - [116. 填充每个节点的下一个右侧节点指针](#116-填充每个节点的下一个右侧节点指针)
  - [117. 填充每个节点的下一个右侧节点指针 II](#117-填充每个节点的下一个右侧节点指针-ii)
  - [104. 二叉树的最大深度](#104-二叉树的最大深度)
  - [111. 二叉树的最小深度](#111-二叉树的最小深度)
  - [226. 翻转二叉树](#226-翻转二叉树)
  - [101. 对称二叉树](#101-对称二叉树)
  - [100. 相同的树](#100-相同的树)
  - [572. 另一棵树的子树](#572-另一棵树的子树)
  - [559. n 叉树的最大深度](#559-n-叉树的最大深度)
  - [222. 完全二叉树的节点个数](#222-完全二叉树的节点个数)
  - [110. 平衡二叉树](#110-平衡二叉树)
  - [257. 二叉树的所有路径](#257-二叉树的所有路径)
  - [404. 左叶子之和](#404-左叶子之和)
  - [513. 找树左下角的值](#513-找树左下角的值)
  - [112. 路径总和](#112-路径总和)
  - [113. 路径总和 ii](#113-路径总和-ii)
  - [106. 从中序与后序遍历序列构造二叉树](#106-从中序与后序遍历序列构造二叉树)
  - [105.从前序与中序遍历序列构造二叉树](#105从前序与中序遍历序列构造二叉树)
  - [654. 最大二叉树](#654-最大二叉树)
  - [617. 合并二叉树](#617-合并二叉树)
  - [700. 二叉搜索树中的搜索](#700-二叉搜索树中的搜索)
  - [98. 验证二叉搜索树](#98-验证二叉搜索树)
  - [530. 二叉搜索树的最小绝对差](#530-二叉搜索树的最小绝对差)
  - [501.二叉搜索树中的众数](#501二叉搜索树中的众数)
  - [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)
  - [235. 二叉搜索树的最近公共祖先](#235-二叉搜索树的最近公共祖先)
  - [701. 二叉搜索树中的插入操作](#701-二叉搜索树中的插入操作)
  - [450. 删除二叉搜索树中的节点](#450-删除二叉搜索树中的节点)
  - [669. 修剪二叉搜索树](#669-修剪二叉搜索树)
  - [108.将有序数组转换为二叉搜索树](#108将有序数组转换为二叉搜索树)
  - [538.把二叉搜索树转换为累加树](#538把二叉搜索树转换为累加树)
- [8 回溯算法](#8-回溯算法)
  - [77. 组合](#77-组合)
  - [216. 组合总和 III](#216-组合总和-iii)
  - [17. 电话号码的字母组合](#17-电话号码的字母组合)
  - [39. 组合总和](#39-组合总和)
  - [40. 组合总和 II](#40-组合总和-ii)
  - [131. 分割回文串](#131-分割回文串)
  - [93. 复原 IP 地址](#93-复原-ip-地址)
  - [78. 子集](#78-子集)
  - [90. 子集 II](#90-子集-ii)
  - [491. 非递减子序列](#491-非递减子序列)
  - [46. 全排列](#46-全排列)
  - [47. 全排列 II](#47-全排列-ii)
  - [332. 重新安排行程](#332-重新安排行程)
  - [51. N 皇后](#51-n-皇后)
  - [37. 解数独](#37-解数独)
- [9 贪心算法](#9-贪心算法)
  - [455. 分发饼干](#455-分发饼干)
  - [376. 摆动序列](#376-摆动序列)
  - [53. 最大子序和](#53-最大子序和)
  - [122. 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii)
  - [55. 跳跃游戏](#55-跳跃游戏)
  - [45. 跳跃游戏 II](#45-跳跃游戏-ii)
  - [1005. K 次取反后最大化的数组和](#1005-k-次取反后最大化的数组和)
  - [134. 加油站](#134-加油站)
  - [135. 分发糖果](#135-分发糖果)
  - [860. 柠檬水找零](#860-柠檬水找零)
  - [406. 根据身高重建队列](#406-根据身高重建队列)
  - [452. 用最少数量的箭引爆气球](#452-用最少数量的箭引爆气球)
  - [435. 无重叠区间](#435-无重叠区间)
  - [763. 划分字母区间](#763-划分字母区间)
  - [56. 合并区间](#56-合并区间)
  - [738. 单调递增的数字](#738-单调递增的数字)
  - [968. 监控二叉树](#968-监控二叉树)
- [10 动态规划](#10-动态规划)
  - [509. 斐波那契数](#509-斐波那契数)
  - [70. 爬楼梯](#70-爬楼梯)
  - [746. 使用最小花费爬楼梯](#746-使用最小花费爬楼梯)
  - [62. 不同路径](#62-不同路径)
  - [63. 不同路径 II](#63-不同路径-ii)
  - [343. 整数拆分](#343-整数拆分)
  - [96. 不同的二叉搜索树](#96-不同的二叉搜索树)
  - [0-1 背包理论基础](#0-1-背包理论基础)
  - [416. 分割等和子集](#416-分割等和子集)
  - [1049. 最后一块石头的重量 II](#1049-最后一块石头的重量-ii)
  - [494. 目标和](#494-目标和)
  - [474. 一和零](#474-一和零)
  - [完全背包理论基础](#完全背包理论基础)
  - [518. 零钱兑换 II](#518-零钱兑换-ii)
  - [377. 组合总和 Ⅳ](#377-组合总和-ⅳ)
  - [70. 爬楼梯（进阶版）](#70-爬楼梯进阶版)
  - [322. 零钱兑换](#322-零钱兑换)
  - [279. 完全平方数](#279-完全平方数)
  - [139. 单词拆分](#139-单词拆分)
  - [多重背包](#多重背包)
  - [198. 打家劫舍](#198-打家劫舍)
  - [213. 打家劫舍 II](#213-打家劫舍-ii)
  - [337. 打家劫舍 III](#337-打家劫舍-iii)
  - [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
  - [122. 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii-1)
  - [123. 买卖股票的最佳时机 III](#123-买卖股票的最佳时机-iii)
  - [188. 买卖股票的最佳时机 IV](#188-买卖股票的最佳时机-iv)
  - [309. 最佳买卖股票时机含冷冻期](#309-最佳买卖股票时机含冷冻期)
  - [714. 买卖股票的最佳时机含手续费](#714-买卖股票的最佳时机含手续费)
  - [300. 最长递增子序列](#300-最长递增子序列)
  - [674. 最长连续递增序列](#674-最长连续递增序列)
  - [718. 最长重复子数组](#718-最长重复子数组)
  - [1143. 最长公共子序列](#1143-最长公共子序列)
  - [1035. 不相交的线](#1035-不相交的线)
  - [53. 最大子序和](#53-最大子序和-1)
  - [392. 判断子序列](#392-判断子序列)
  - [115. 不同的子序列](#115-不同的子序列)
  - [583. 两个字符串的删除操作](#583-两个字符串的删除操作)
  - [72. 编辑距离](#72-编辑距离)
  - [647. 回文子串](#647-回文子串)
  - [516. 最长回文子序列](#516-最长回文子序列)
- [11 单调栈](#11-单调栈)
  - [739. 每日温度](#739-每日温度)
  - [496. 下一个更大元素 I](#496-下一个更大元素-i)
  - [503. 下一个更大元素 II](#503-下一个更大元素-ii)
  - [42. 接雨水](#42-接雨水)
  - [84. 柱状图中最大的矩形](#84-柱状图中最大的矩形)
- [12 图论](#12-图论)
  - [98. 所有可达路径](#98-所有可达路径)
  - [797. 所有可能的路径](#797-所有可能的路径)
  - [99. 岛屿数量](#99-岛屿数量)
  - [100. 岛屿的最大面积](#100-岛屿的最大面积)
  - [101. 孤岛的总面积](#101-孤岛的总面积)
  - [102. 沉没孤岛](#102-沉没孤岛)
  - [103. 水流问题](#103-水流问题)
  - [104.建造最大岛屿](#104建造最大岛屿)
  - [110. 字符串接龙](#110-字符串接龙)
  - [105.有向图的完全可达性](#105有向图的完全可达性)
  - [106. 岛屿的周长](#106-岛屿的周长)
  - [107. 寻找存在的路径](#107-寻找存在的路径)
  - [108. 冗余连接](#108-冗余连接)
  - [109. 冗余连接 II](#109-冗余连接-ii)
  - [prim 算法](#prim-算法)
  - [kruskal 算法](#kruskal-算法)
  - [拓扑排序](#拓扑排序)
  - [dijkstra](#dijkstra)
  - [Bellman\_ford 算法](#bellman_ford-算法)
  - [Bellman\_ford 队列优化算法（又名 SPFA）](#bellman_ford-队列优化算法又名-spfa)
  - [bellman\_ford 之判断负权回路](#bellman_ford-之判断负权回路)
  - [bellman\_ford 之单源有限最短路](#bellman_ford-之单源有限最短路)
  - [Floyd 算法](#floyd-算法)
  - [A \* 算法 （A star 算法）](#a--算法-a-star-算法)

## 1 数组

### 704. 二分查找

[704. 二分查找](https://leetcode.cn/problems/binary-search/description/)

**_python_**

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1  # []
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

**_cpp_**

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // []
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return -1;
    }
};
```

**_js_**

```js
var search = function (nums, target) {
  let l = 0,
    r = nums.length - 1; // []
  while (l <= r) {
    let mid = (r + l) >> 1;
    if (nums[mid] === target) return mid;
    else if (nums[mid] < target) l = mid + 1;
    else r = mid - 1;
  }
  return -1;
};
```

### 35. 搜索插入位置

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

**_python_**

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid - 1
            else :
                left = mid + 1
        return left
```

**_cpp_**

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // []
        while(left <= right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] > target)
                right = mid - 1;
            else
                left = mid + 1;
        }
        return left;
    }
};
```

**_js_**

```js
var searchInsert = function (nums, target) {
  let left = 0,
    right = nums.length - 1;
  while (left <= right) {
    let mid = (left + right) >> 1;
    if (nums[mid] === target) return mid;
    else if (nums[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return left;
};
```

### 34. 在排序数组中查找元素的第一个和最后一个位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

**_python_**

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1  # []

        def getLeftBound(nums, target):
            nonlocal left, right
            while left <= right:
                mid = left + (right - left) // 2
                if nums[mid] >= target:
                    right = mid - 1
                else:
                    left = mid + 1
            if left < len(nums) and nums[left] == target:
                return left
            return -1

        def getRightBound(nums, target):
            nonlocal left, right
            right = len(nums) - 1
            while left <= right:
                mid = left + (right - left) // 2
                if nums[mid] <= target:
                    left = mid + 1
                else:
                    right = mid - 1
            return right

        leftBound = getLeftBound(nums, target)
        if leftBound == -1:
            return [-1, -1]
        return [leftBound, getRightBound(nums, target)]
```

**_cpp_**

```cpp
class Solution {
public:
    int left = 0, right;
    int findLeftBound(const vector<int>& nums, const int& target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target)
                right = mid - 1;
            else
                left = mid + 1;
        }
        if (left < nums.size() && nums[left] == target)
            return left;
        return -1;
    }

    int findRightBound(const vector<int>& nums, const int& target) {
        right = nums.size() - 1; // []
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        right = nums.size() - 1; // []
        int leftBound = findLeftBound(nums, target);
        if (leftBound == -1)
            return {-1, -1};
        return {leftBound, findRightBound(nums, target)};
    }
};
```

**_js_**

```js
var searchLeftBound = function (nums, target) {
  while (left <= right) {
    let mid = (left + right) >> 1;
    if (nums[mid] >= target) right = mid - 1;
    else left = mid + 1;
  }
  if (left < nums.length && nums[left] === target) return left;
  return -1;
};

var searchRightBound = function (nums, target) {
  right = nums.length - 1;
  while (left <= right) {
    let mid = (left + right) >> 1;
    if (nums[mid] <= target) left = mid + 1;
    else right = mid - 1;
  }
  return right;
};

var searchRange = function (nums, target) {
  left = 0;
  right = nums.length - 1;
  let leftBound = searchLeftBound(nums, target);
  if (leftBound === -1) return [-1, -1];
  return [leftBound, searchRightBound(nums, target)];
};
```

### 69. x 的平方根

[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/description/)

**_python_**

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return x
        left, right = 1, x
        while left <= right:
            mid = left + (right - left) // 2
            if x // mid == mid:
                return mid
            elif x // mid > mid:
                left = mid + 1
            else :
                right = mid - 1
        return right
```

**_cpp_**

```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0)
            return 0;
        int left = 1, right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (x / mid == mid) // 防止数值溢出
                return mid;
            else if (x / mid > mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return right;
    }
};
```

**_js_**

```js
var mySqrt = function (x) {
  if (x === 0) return x;
  let left = 1,
    right = x;
  while (left <= right) {
    let mid = left + ((right - left) >> 1);
    if (mid === Math.floor(x / mid)) return mid;
    else if (mid < Math.floor(x / mid)) left = mid + 1;
    else right = mid - 1;
  }
  return right;
};
```

### 367. 有效的完全平方数

[367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/description/)

**_python_**

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 1, num
        while left <= right:
            mid = left + (right - left) // 2
            if mid * mid == num:
                return True
            elif mid * mid < num:
                left = mid + 1
            else:
                right = mid - 1
        return False
```

**_cpp_**

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 1, right = num;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if ((long)mid * mid == num)
                return true;
            else if (mid < num / mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return false;
    }
};
```

**_js_**

```js
var isPerfectSquare = function (num) {
  let left = 1,
    right = num;
  while (left <= right) {
    let mid = left + ((right - left) >> 1);
    if (mid * mid == num) return true;
    else if (mid * mid < num) left = mid + 1;
    else right = mid - 1;
  }
  return false;
};
```

### 27. 移除元素

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/description/)

**_python_**

```python
class Solution(object):
    def removeElement(self, nums, val):
        left, right  = 0, len(nums) - 1
        while left <= right:
            while left <= right and nums[left] != val:
                left += 1
            while left <= right and nums[right] == val:
                right -= 1
            if left <= right:
                nums[left] = nums[right]
                left += 1
                right -= 1
        return left
```

**_cpp_**

```cpp
// 左右指针
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            while (left <= right && nums[left] != val) ++left;
            while (left <= right && nums[right] == val) --right;
            if (left <= right) nums[left++] = nums[right--];
        }
        return left;
    }
};

// 快慢指针
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0, fast = 0;
        while (fast < nums.size()) {
            if (nums[fast] != val) nums[slow++] = nums[fast];
            ++fast;
        }
        return slow;
    }
};
```

**_js_**

```js
var removeElement = function (nums, val) {
  let slow = 0,
    fast = 0;
  for (; fast < nums.length; fast++)
    if (nums[fast] != val) nums[slow++] = nums[fast];
  return slow;
};
```

### 26. 删除排序数组中的重复项

[26. 删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

**_python_**

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 0
        while fast < len(nums):
            if fast < len(nums) - 1 and nums[fast] == nums[fast + 1]:
                fast += 1
                continue
            else:
                nums[slow] = nums[fast]
                slow += 1
                fast += 1
        return slow
```

**_cpp_**

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 0, fast = 0;
        while (fast < nums.size() - 1) {
            if (nums[fast] != nums[fast + 1]) nums[slow++] = nums[fast];
            ++fast;
        }
        nums[slow++] = nums[fast];
        return slow;
    }
};
```

**_js_**

```js
var removeDuplicates = function (nums) {
  let slow = 1,
    fast = 0;
  while (fast < nums.length) {
    if (fast > 0 && nums[fast] != nums[fast - 1]) nums[slow++] = nums[fast];
    fast++;
  }
  return slow;
};
```

### 283. 移动零

[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/description/)

**_python_**

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow, fast = 0, 0
        while fast < len(nums):
            if nums[fast]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        while slow < len(nums):
            nums[slow] = 0
            slow += 1
```

**_cpp_**

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0, fast = 0;
        for(; fast < nums.size(); fast++)
            if(nums[fast])
                nums[slow++] = nums[fast];

        while(slow < nums.size())
            nums[slow++] = 0;
    }
};
```

**_js_**

```js
var moveZeroes = function (nums) {
  let slow = 0,
    fast = 0;
  for (; fast < nums.length; fast++)
    if (nums[fast] != 0) nums[slow++] = nums[fast];

  while (slow < nums.length) nums[slow++] = 0;
};
```

### 844. 比较含退格的字符串

[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/description/)

**_python_**

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def modify(S):
            stack = []
            for char in S:
                if char != '#':
                    stack.append(char)
                elif stack:
                    stack.pop()
            return ''.join(stack)

        return modify(s) == modify(t)


# ----------------------------
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        return self.modifyString(s) == self.modifyString(t)

    def modifyString(self, s: str) -> str:
        slow, fast = 0, 0
        s_list = list(s)
        while fast < len(s_list):
            if s_list[fast] != '#':
                s_list[slow] = s_list[fast]
                slow += 1
            elif slow > 0:
                slow -= 1

            fast += 1
        return ''.join(s_list[:slow])
```

**_cpp_**

```cpp
class Solution {
private:
    void help(string& s) {
        int slow = 0, fast = 0;
        while (fast < s.size()) {
            if (s[fast] == '#') {
                if (slow > 0)
                    --slow;
            } else
                s[slow++] = s[fast];
            ++fast;
        }
        s.resize(slow);
    }

public:
    bool backspaceCompare(string s, string t) {
        help(s);
        help(t);
        return s == t;
    }
}
```

**_js_**

```js
var backspaceCompare = function (s, t) {
  modify = function (s) {
    let slow = 0,
      sArr = s.split("");
    for (let fast = 0; fast < sArr.length; fast++) {
      if (sArr[fast] != "#") sArr[slow++] = sArr[fast];
      else if (slow > 0) slow--;
    }
    sArr.length = slow;
    return sArr.join("");
  };
  s = modify(s);
  t = modify(t);
  return s == t;
};
```

### 977. 有序数组的平方

[977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/description/)

**_python_**

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        res = [0] * len(nums)
        nums = [num * num for num in nums]
        i, j, k = 0, len(nums) - 1, len(nums) - 1
        while k >= 0:
            if nums[i] >= nums[j]:
                res[k] = nums[i]
                i += 1
            else:
                res[k] = nums[j]
                j -= 1
            k -= 1
        return res
```

**_cpp_**

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for (int& num : nums)
            num = num * num;

        vector<int> res(nums.size());
        int i = nums.size() - 1, left = 0, right = nums.size() - 1;
        while (i >= 0)
            res[i--] = nums[right] >= nums[left] ? nums[right--] : nums[left++];
        return res;
    }
};
```

**_js_**

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function (nums) {
  // 将 nums 数组中的每个元素取平方，并生成一个新的数组
  nums = nums.map((num) => num * num);
  let res = new Array(nums.length);
  let i = 0,
    j = nums.length - 1,
    k = nums.length - 1;
  while (k >= 0) {
    if (nums[i] >= nums[j]) {
      res[k] = nums[i];
      i++;
    } else {
      res[k] = nums[j];
      j--;
    }
    k--;
  }
  return res;
};
```

### 209. 长度最小的子数组

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/)

**_python_**

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left, right = 0, 0  # [)
        sum = 0
        res = len(nums) + 1
        while right < len(nums):
            while right < len(nums) and sum < target:
                sum += nums[right]
                right += 1
            while sum >= target:
                res = min(res, right - left)
                sum -= nums[left]
                left += 1
        return 0 if res == len(nums) + 1 else res
```

**_cpp_**

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum = 0, res = INT32_MAX;
        for (int slow = 0, fast = 0; fast < nums.size(); ++fast) {
            sum += nums[fast];
            while (sum >= target) {
                res = min(res, fast - slow + 1);
                sum -= nums[slow++];
            }
        }
        return res == INT32_MAX ? 0 : res;
    }
};
```

**_js_**

```js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
  let left = 0,
    right = 0; // [)
  let sum = 0;
  let res = nums.length + 1;
  while (right < nums.length) {
    sum += nums[right];
    right++;
    while (sum >= target) {
      res = Math.min(res, right - left); // 注意是Math.min()
      sum -= nums[left++];
    }
  }
  return res === nums.length + 1 ? 0 : res;
};
```

### 904. 水果成篮

[904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/description/)

**_python_**

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        fruit_map = {}
        left, right = 0, 0
        temp_res, res = 0, 0
        for fruit in fruits:
            if fruit in fruit_map:
                fruit_map[fruit] += 1
            else:
                fruit_map[fruit] = 1

            if len(fruit_map) <= 2:
                temp_res += 1
                res = max(res, temp_res)
            else:
                while len(fruit_map) > 2:
                    fruit_map[fruits[left]] -= 1
                    if fruit_map[fruits[left]] == 0:
                        del fruit_map[fruits[left]]
                    left += 1
                temp_res = right - left + 1
            right += 1
        return res
```

**_cpp_**

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> umap;
        int res = 0;
        int slow = 0, fast = 0;
        while (fast < fruits.size()) {
            ++umap[fruits[fast++]];
            if (umap.size() <= 2) res = max(res, fast - slow);
            else
                while (umap.size() > 2) {
                    if (umap[fruits[slow]] == 1) umap.erase(fruits[slow]);
                    else --umap[fruits[slow]];
                    ++slow;
                }
        }
        return res;
    }
}
```

**_js_**

```js
/**
 * @param {number[]} fruits
 * @return {number}
 */
var totalFruit = function (fruits) {
  const fruitMap = new Map();
  let res = 0,
    tempRes = 0;
  let slow = 0,
    fast = 0;
  for (const fruit of fruits) {
    fruitMap.set(fruit, (fruitMap.get(fruit) || 0) + 1);

    if (fruitMap.size <= 2) {
      tempRes += 1;
      res = Math.max(res, tempRes);
    } else {
      while (fruitMap.size > 2) {
        fruitMap.set(fruits[slow], fruitMap.get(fruits[slow]) - 1);
        if (fruitMap.get(fruits[slow]) === 0) {
          fruitMap.delete(fruits[slow]);
        }
        slow += 1;
      }
      tempRes = fast - slow + 1;
    }
    fast += 1;
  }
  return res;
};
```

### 76. 最小覆盖子串

[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/description/)

**_python_**

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = {}
        for c in t:
            if c in need:
                need[c] += 1
            else:
                need[c] = 1
        left, right, start_index = 0, 0, 0
        length = 100001
        invalid = len(need)

        while right < len(s):
            # 扩大窗口
            if s[right] in need:
                need[s[right]] -= 1
                if need[s[right]] == 0:
                    invalid -= 1
            right += 1

            while invalid == 0:
                # 缩小窗口
                if s[left] in need:
                    need[s[left]] += 1
                    if need[s[left]] > 0:
                        invalid += 1
                        if right - left < length: # 收获结果
                            start_index = left
                            length = right - left
                left += 1
        return "" if length == 100001 else s[start_index:start_index + length]

```

**_cpp_**

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> umap;
        for (const char& c : t)
            ++umap[c];
        int invalid = umap.size();
        int start_index = 0, length = 100001;
        int slow = 0, fast = 0;
        while (fast < s.size()) {
            // 扩大窗口
            auto it = umap.find(s[fast++]);
            if (it != umap.end()) {
                --it->second;
                if (it->second == 0)
                    --invalid;
            }

            // 收缩窗口
            while (invalid == 0) {
                if (fast - slow < length) { // 收获结果
                    start_index = slow;
                    length = fast - slow;
                }
                auto it = umap.find(s[slow++]);
                if (it != umap.end()) {
                    ++it->second;
                    if (it->second == 1)
                        ++invalid;
                }
            }
        }
        return length == 100001 ? "" : s.substr(start_index, length);
    }
};
```

**_js_**

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
  let umap = new Map();
  for (let c of t) {
    umap.set(c, (umap.get(c) || 0) + 1);
  }
  let left = 0,
    right = 0;
  let invalid = umap.size;
  let start_index = 0,
    length = 100001;

  while (right < s.length) {
    // 扩大窗口
    let char = s[right++];
    if (umap.has(char)) {
      umap.set(char, umap.get(char) - 1);
      if (umap.get(char) === 0) {
        invalid--;
      }
    }

    // 收缩窗口
    while (invalid === 0) {
      let charLeft = s[left];
      if (umap.has(charLeft)) {
        umap.set(charLeft, umap.get(charLeft) + 1);
        if (umap.get(charLeft) > 0) {
          invalid++;
          if (right - left < length) {
            // 收获结果
            start_index = left;
            length = right - left;
          }
        }
      }
      left++;
    }
  }
  return length === 100001 ? "" : s.substr(start_index, length);
};
```

### 59. 螺旋矩阵 II

[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/description/)

**_python_**

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0] * n for _ in range(n)] # 二维数组
        left_bound, right_bound = 0, n - 1
        up_bound, down_bound = 0, n - 1
        count = 1

        while count <= n * n:
            # 上边
            for j in range(left_bound, right_bound + 1):
                res[up_bound][j] = count
                count += 1
            up_bound += 1

            # 右边
            for i in range(up_bound, down_bound + 1):
                res[i][right_bound] = count
                count += 1
            right_bound -= 1

            # 下边
            for j in range(right_bound, left_bound - 1, - 1):
                res[down_bound][j] = count
                count += 1
            down_bound -= 1

            # 左边
            for i in range(down_bound, up_bound - 1, -1):
                res[i][left_bound] = count
                count += 1
            left_bound += 1

        return res
```

**_cpp_**

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n));
        int leftBound = 0, rightBound = n - 1;
        int upBound = 0, downBound = n - 1;
        int count = 1;
        while (count <= n * n) {
            // 上边
            for (int j = leftBound; j <= rightBound; ++j)
                res[upBound][j] = count++;
            upBound++;

            // 右边
            for (int i = upBound; i <= downBound; ++i)
                res[i][rightBound] = count++;
            rightBound--;

            // 下边
            for (int j = rightBound; j >= leftBound; --j)
                res[downBound][j] = count++;
            downBound--;

            // 左边
            for (int i = downBound; i >= upBound; --i)
                res[i][leftBound] = count++;
            leftBound++;
        }
        return res;
    }
};
```

**_js_**

```js
/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function (n) {
  let res = new Array(n).fill().map(() => new Array(n).fill(0));
  let leftBound = 0,
    rightBound = n - 1;
  let upBound = 0,
    downBound = n - 1;
  let count = 1;

  while (count <= n * n) {
    // 上边
    for (let j = leftBound; j <= rightBound; j++) res[upBound][j] = count++;
    upBound++;

    // 右边
    for (let i = upBound; i <= downBound; i++) res[i][rightBound] = count++;
    rightBound--;

    // 下边
    for (let j = rightBound; j >= leftBound; j--) res[downBound][j] = count++;
    downBound--;

    // 左边
    for (let i = downBound; i >= upBound; i--) res[i][leftBound] = count++;
    leftBound++;
  }
  return res;
};
```

### 54. 螺旋矩阵

[54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/description/)

**_python_**

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        m, n = len(matrix), len(matrix[0])
        up_bound, down_bound = 0, m - 1
        left_bound, right_bound = 0, n - 1

        while up_bound <= down_bound and left_bound <= right_bound:
            # 上边
            for j in range(left_bound, right_bound + 1):
                res.append(matrix[up_bound][j])
            up_bound += 1
            if up_bound > down_bound:
                break

            # 右边
            for i in range(up_bound, down_bound + 1):
                res.append(matrix[i][right_bound])
            right_bound -= 1
            if left_bound > right_bound:
                break

            # 下边
            for j in range(right_bound, left_bound - 1, -1):
                res.append(matrix[down_bound][j])
            down_bound -= 1

            # 左边
            for i in range(down_bound, up_bound - 1, -1):
                res.append(matrix[i][left_bound])
            left_bound += 1
        return res
```

**_cpp_**

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int m = matrix.size(), n = matrix[0].size();
        res.reserve(m * n);
        int leftBound = 0, rightBound = n - 1;
        int upBound = 0, downBound = m - 1;
        int count = m * n;
        while (count) {
            for (int j = leftBound; j <= rightBound; ++j)
                res.push_back(matrix[upBound][j]);
            count -= (rightBound - leftBound + 1);
            if (count == 0) break;
            ++upBound;

            for (int i = upBound; i <= downBound; ++i)
                res.push_back(matrix[i][rightBound]);
            count -= (downBound - upBound + 1);
            if (count == 0) break;
            --rightBound;

            for (int j = rightBound; j >= leftBound; --j)
                res.push_back(matrix[downBound][j]);
            count -= (rightBound - leftBound + 1);
            --downBound;

            for (int i = downBound; i >= upBound; --i)
                res.push_back(matrix[i][leftBound]);
            count -= (downBound - upBound + 1);
            ++leftBound;
        }
        return res;
    }
}
```

**_js_**

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function (matrix) {
  let res = [];
  let m = matrix.length,
    n = matrix[0].length;
  let upBound = 0,
    downBound = m - 1;
  let leftBound = 0,
    rightBound = n - 1;

  while (upBound <= downBound && leftBound <= rightBound) {
    // 上
    for (let j = leftBound; j <= rightBound; j++) {
      res.push(matrix[upBound][j]);
    }
    upBound++;
    if (upBound > downBound) break;

    // 右
    for (let i = upBound; i <= downBound; i++) {
      res.push(matrix[i][rightBound]);
    }
    rightBound--;
    if (leftBound > rightBound) break;

    // 下
    for (let j = rightBound; j >= leftBound; j--) {
      res.push(matrix[downBound][j]);
    }
    downBound--;

    // 左
    for (let i = downBound; i >= upBound; i--) {
      res.push(matrix[i][leftBound]);
    }
    leftBound++;
  }
  return res;
};
```

### 剑指 Offer 29. 顺时针打印矩阵

[剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/)

同 [54. 螺旋矩阵](#54-螺旋矩阵)

---

## 2 链表

### 203.移除链表元素

[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

**_python_**

```python
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        dummyHead = ListNode(0, head);
        p = dummyHead;
        while p.next:
            if p.next.val == val:
                p.next = p.next.next
            else:
                p = p.next
        return dummyHead.next
```

**_cpp_**

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next) {
            if (p->next->val == val) {
                ListNode* temp = p->next;
                p->next = temp->next;
                delete temp;
            } else
                p = p->next;
        }
        return dummyHead->next;
    }
};
```

**_js_**

```js
var removeElements = function (head, val) {
  const dummyHead = new ListNode(0, head);
  let p = dummyHead;
  while (p.next) {
    if (p.next.val === val) {
      const temp = p.next;
      p.next = temp.next;
      temp.next = null; // Optional: Helps in garbage collection
    } else {
      p = p.next;
    }
  }
  return dummyHead.next;
};
```

### 707. 设计链表

[707. 设计链表](https://leetcode.cn/problems/design-linked-list/description/)

**_python_**

```python
class ListNode:
    def __init__(self, val = 0,next = None):
        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):
        self.head = None
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        p = self.head
        for _ in range(index):
            p = p.next
        return p.val

    def addAtHead(self, val: int) -> None:
        self.head = ListNode(val, self.head)
        self.size += 1

    def addAtTail(self, val: int) -> None:
        p = self.head
        while p.next:
            p = p.next
        p.next = ListNode(val)
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        p = self.head
        for _ in range(index - 1):
            p = p.next
        p.next = ListNode(val, p.next)
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        p = self.head
        for _ in range(index - 1):
            p = p.next
        p.next = p.next.next
        self.size -= 1



# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

**_cpp_**

```cpp
class MyLinkedList {
private:
    struct ListNode {
        int val;
        ListNode* next;
        ListNode(int val = 0, ListNode* next = nullptr)
            : val(val), next(next) {}
    };
    ListNode* dummyHead;
    int _size;

public:
    MyLinkedList() {
        dummyHead = new ListNode();
        _size = 0;
    }

    int get(int index) {
        if (index < 0 || index >= _size)
            return -1;
        ListNode* p = dummyHead->next;
        while (index--)
            p = p->next;
        return p->val;
    }

    void addAtHead(int val) {
        dummyHead->next = new ListNode(val, dummyHead->next);
        ++_size;
    }

    void addAtTail(int val) {
        ListNode* p = dummyHead;
        while (p->next)
            p = p->next;
        p->next = new ListNode(val);
        ++_size;
    }

    void addAtIndex(int index, int val) {
        if (index < 0 || index > _size)
            return;
        ListNode* p = dummyHead;
        while (index--)
            p = p->next;
        p->next = new ListNode(val, p->next);
        ++_size;
    }

    void deleteAtIndex(int index) {
        if (index < 0 || index >= _size)
            return;
        ListNode* p = dummyHead;
        while (index--)
            p = p->next;
        ListNode* temp = p->next;
        p->next = temp->next;
        delete temp;
        temp = nullptr;
        --_size;
    }
};

```

**_js_**

```js
var ListNode = function (val = 0, next = null) {
  this.val = val;
  this.next = next;
};

var MyLinkedList = function () {
  this._dummyHead = new ListNode();
  this._size = 0;
};

/**
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.get = function (index) {
  if (index < 0 || index >= this._size) return -1;
  let p = this._dummyHead.next;
  while (index--) p = p.next;
  return p.val;
};

/**
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function (val) {
  const p = new ListNode(val, this._dummyHead.next);
  this._dummyHead.next = p;
  this._size++;
};

/**
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function (val) {
  let p = this._dummyHead;
  while (p.next) p = p.next;
  p.next = new ListNode(val);
  this._size++;
};

/**
 * @param {number} index
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function (index, val) {
  if (index < 0 || index > this._size) return;
  let p = this._dummyHead;
  while (index--) p = p.next;
  const temp = new ListNode(val, p.next);
  p.next = temp;
  this._size++;
};

/**
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function (index) {
  if (index < 0 || index >= this._size) return;
  let p = this._dummyHead;
  while (index--) p = p.next;
  p.next = p.next.next;
  this._size--;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * var obj = new MyLinkedList()
 * var param_1 = obj.get(index)
 * obj.addAtHead(val)
 * obj.addAtTail(val)
 * obj.addAtIndex(index,val)
 * obj.deleteAtIndex(index)
 */
```

### 206.反转链表

[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

**_python_**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# 逐个节点反转
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre, cur = None, head
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre

# 递归
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head

        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```

**_cpp_**

```cpp
// 逐个翻转每个节点的指向
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr, cur = head;
        while (cur) {
            ListNode *temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};

// 递归
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || head->next == nullptr) return head;
        ListNode *last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};
```

**_js_**

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
// 逐个节点反转
var reverseList = function (head) {
  let pre = null;
  let cur = head;
  while (cur) {
    const temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};

// 递归
var reverseList = function (head) {
  if (head === null || head.next === null) return head;

  const last = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  return last;
};
```

### 24. 两两交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

**_python_**

```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummyHead = ListNode(0, head)
        p = dummyHead
        while p.next and p.next.next:
            temp = p.next
            p.next = temp.next
            temp.next = temp.next.next
            p.next.next = temp
            p = temp
        return dummyHead.next
```

**_cpp_**

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* p = dummyHead;
        while (p->next && p->next->next) {
            ListNode* temp = p->next;
            p->next = temp->next;
            temp->next = p->next->next;
            p->next->next = temp;
            p = temp;
        }
        return dummyHead->next;
    }
};
```

### 19.删除链表的倒数第 N 个节点

[19.删除链表的倒数第 N 个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

**_python_**

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummyHead = ListNode(0, head)
        slow, fast = dummyHead, head
        for _ in range(n):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummyHead.next
```

**_cpp_**

```cpp
class Solution {
public:
  ListNode *removeNthFromEnd(ListNode *head, int n) {
    ListNode *dummyHead = new ListNode(0, head);
    ListNode *fast = dummyHead;
    ListNode *slow = dummyHead;
    while (n-- >= 0) // 走 n + 1 步
      fast = fast->next;

    while (fast) {
      fast = fast->next;
      slow = slow->next;
    }

    ListNode *del = slow->next;
    slow->next = del->next;
    delete del;
    return dummyHead->next;
  }
};
```

### 面试题 02.07. 链表相交

[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

**_python_**

```python
# 方法一：提前记载各自长度
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p = headA
        countA = countB = 0
        while p:
            p = p.next
            countA += 1

        p = headB
        while p:
            p = p.next
            countB += 1

        if countA == 0 or countB == 0:
            return None
        p, q = headA, headB

        if countA < countB:
            p, q = q, p
        # 此时 p 指向长链表
        for _ in range(abs(countA - countB)):
            p = p.next
        while p != q:
            p = p.next
            q = q.next

        return p

# 优雅解法，尾连接
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p, q = headA, headB
        while p != q:
            if p == None:
                p = headB
            else:
                p = p.next

            if q == None:
                q = headA
            else:
                q = q.next

        return q
```

**_cpp_**

```cpp
// 方法一：提前记载各自长度
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode* p = headA;
        int countA = 0, countB = 0;
        while (p) {
            p = p->next;
            ++countA;
        }
        p = headB;
        while (p) {
            p = p->next;
            ++countB;
        }
        if (countA == 0 || countB == 0)
            return nullptr;
        p = headA;
        ListNode* q = headB;
        if (countA < countB)
            swap(q, p);
        // 此时 p 指向长链表
        int temp = abs(countA - countB);
        while (temp--)
            p = p->next;
        while (p != q) {
            p = p->next;
            q = q->next;
        }
        return q;
    }
};

// 巧妙，尾连接
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode *p = headA, *q = headB;
        while (p != q) {
            if (p == nullptr) p = headB;
            else p = p->next;

            if (q == nullptr) q = headA;
            else q = q->next;
        }
        return q;
    }
};
```

### 142.环形链表 II

[142.环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

**_python_**

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

            if fast == slow:
                p, q = fast, head
                while p != q:
                    p = p.next
                    q = q.next
                return q
        return None
```

**_cpp_**

```cpp
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode *fast = head, *slow = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) break;
        }
        if (!fast || fast->next == nullptr)
            return nullptr;
        slow = head;
        while (slow != fast) {
            slow = slow->next;
            fast = fast->next;
        }
        return fast;
    }
}
```

---

## 3 哈希表

### 242.有效的字母异位词

[242.有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/)

**_python_**

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        arr = [0] * 26
        for c in s:
            arr[ord(c) - ord('a')] += 1     # ord() 用来获取字符的 ASCII 码

        for c in t:
            arr[ord(c) - ord('a')] -= 1

        for num in arr:
            if num:
                return False

        return True
```

**_cpp_**

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size())
            return false;
        int a[26] = {0};
        for (const char &ch : s)
            ++a[ch - 'a'];
        for (const char &ch : t)
            --a[ch - 'a'];

        for (int i = 0; i < 26; ++i)
            if (a[i])
                return false;

        return true;
    }
};
```

### 383. 赎金信

[383. 赎金信](https://leetcode.cn/problems/ransom-note/description/)

**_python_**

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        arr = [0] * 26
        for c in magazine:
            arr[ord(c) - ord("a")] += 1

        for c in ransomNote:
            arr[ord(c) - ord("a")] -= 1

        for num in arr:
            if num < 0:
                return False

        return True
```

**_cpp_**

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        if (magazine.size() < ransomNote.size()) return false
        int record[26] = {0};
        for (const char &ch : magazine)
            ++record[ch - 'a'];

        for (const char &ch : ransomNote)
            --record[ch - 'a'];

        for (int i = 0; i < 26; ++i)
            if (record[i] < 0)
                return false;

        return true;
    }
};
```

### 49. 字母异位词分组

[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)

**_python_**

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        umap = {}
        for string in strs:
            sorted_str = "".join(sorted(string))    # 排序后的字符串作为 key
            if sorted_str not in umap:
                umap[sorted_str] = []
            umap[sorted_str].append(string)

        return list(umap.values())  # 返回字典的值, 并转换为列表
```

**_cpp_**

```cpp
class Solution {
public:
  vector<vector<string>> groupAnagrams(vector<string> &strs) {
    unordered_map<string, vector<string>> umap;
    vector<vector<string>> res;
    for (const string &str : strs) {
      string key = str;
      sort(key.begin(), key.end());
      umap[key].emplace_back(str);
    }
    for (auto it = umap.begin(); it != umap.end(); ++it)
      res.emplace_back(it->second);
    return res;
  }
};
```

### 438. 找到字符串中所有字母异位词

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

**_python_**

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        umap = {}
        res = []
        for c in p:
            if c not in umap:
                umap[c] = 0
            umap[c] += 1

        invalid = len(umap)
        left = right = 0  # [)
        while right < len(s):
            c = s[right]  # 扩大窗口
            right += 1
            if c in umap:
                umap[c] -= 1
                if umap[c] == 0:
                    invalid -= 1

            if right - left == len(p):
                if invalid == 0:
                    res.append(left)  # 收结果
                d = s[left]
                left += 1  # 收缩窗口
                if d in umap:
                    if umap[d] == 0:
                        invalid += 1
                    umap[d] += 1

        return res
```

**_cpp_**

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        if (s.size() < p.size()) return res;
        unordered_map<char, int> umap;
        for (const char& c : p)
            ++umap[c];

        int invalid = umap.size();
        int left = 0, right = 0;
        while (right < s.size()) {
            auto it = umap.find(s[right++]);    // 扩大窗口
            if (it != umap.end()) {
                --it->second;
                if (it->second == 0)
                    --invalid;
            }
            if (right - left == p.size()) {
                if (invalid == 0)
                    res.emplace_back(left); // 收获结果
                auto it = umap.find(s[left++]); // 缩小窗口
                if (it != umap.end()) {
                    if (it->second == 0)
                        ++invalid;
                    ++it->second;
                }
            }
        }
        return res;
    }
}
```

### 349. 两个数组的交集

[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

**_python_**

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        my_set = set(nums1)
        res = []

        for num in nums2:
            if num in my_set:
                res.append(num)
                my_set.remove(num)

        return res
```

**_cpp_**

```cpp
class Solution{
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2){
        unordered_set<int> uset;
        vector<int> res;

        for (const int &num1 : nums1)
            uset.insert(num1);
        for (const int &num2 : nums2)
            if (uset.find(num2) != uset.end()){
                res.emplace_back(num2);
                uset.erase(num2);
            }

        return res;
    }
};
```

### 350. 两个数组的交集 II

[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/)

**_python_**

```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        umap = {}
        res = []
        for num in nums1:
            if num not in umap:
                umap[num] = 0
            umap[num] += 1

        for num in nums2:
            if num in umap and umap[num]:
                res.append(num)
                umap[num] -= 1

        return res
```

**_cpp_**

```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> umap;
        vector<int> res;
        for (const int &num : nums1)
            ++umap[num];

        for (const int &num : nums2) {
            auto it = umap.find(num);
            if (it != umap.end() && it->second) {
                res.push_back(num);
                --(it->second);
            }
        }
        return res;
    }
};
```

### 202. 快乐数

[202. 快乐数](https://leetcode.cn/problems/happy-number/description/)

**_python_**

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        num_set = set()
        while n != 1:
            num_set.add(n)
            sum_of_digits = 0
            while n:
                sum_of_digits += (n % 10) * (n % 10)
                n //= 10
            if sum_of_digits in num_set:
                return False
            n = sum_of_digits
        return True
```

**_cpp_**

```cpp
class Solution {
public:
  bool isHappy(int n) {
    unordered_set<int> uset;

    while (n != 1) {
      if (uset.find(n) != uset.end()) return false;
      uset.insert(n);

      int temp = n;
      n = 0;
      while (temp) {
        n += (temp % 10) * (temp % 10);
        temp /= 10;
      }
    }
    return true;
  }
};
```

### 1. 两数之和

[1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

**_python_**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        umap = {}
        for idx, num in enumerate(nums):
            if target - num in umap:
                return [umap[target - num], idx]
            umap[num] = idx
```

**_cpp_**

```cpp
class Solution {
public:
  vector<int> twoSum(vector<int> &nums, int target) {
    unordered_map<int, int> umap;
    for (int i = 0; i < nums.size(); i++) {
      auto it = umap.find(target - nums[i]);
      if (it != umap.end()) return {it->second, i};
      umap.insert({nums[i], i});
    }
    return {-1, -1};
  }
};
```

### 454. 四数相加 II

[454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/description/)

**_python_**

```python
class Solution:
    def fourSumCount(
        self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]
    ) -> int:
        umap = {}
        res = 0
        for n1 in nums1:
            for n2 in nums2:
                temp = n1 + n2
                if temp not in umap:
                    umap[temp] = 0
                umap[temp] += 1

        for n3 in nums3:
            for n4 in nums4:
                temp = -n3 -n4
                if temp in umap:
                    res += umap[temp]

        return res
```

**_cpp_**

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3,
                     vector<int>& nums4) {
        unordered_map<int, int> umap;
        int res = 0;
        for (const int &num1 : nums1)
            for (const int &num2 : nums2)
                ++umap[num1 + num2];

        for (const int &num3 : nums3)
            for (const int &num4 : nums4) {
                auto it = umap.find(-num3 - num4);
                if (it != umap.end())
                    res += it->second;
            }

        return res;
    }
};
```

### 15. 三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/description/)

**_python_**

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        i = 0
        while i < len(nums):
            if nums[i] > 0:
                break
            left, right = i + 1, len(nums) - 1
            while left < right:
                if nums[i] + nums[left] == -nums[right]:
                    res.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif nums[i] + nums[left] < -nums[right]:
                    left += 1
                else:
                    right -= 1
            while i < len(nums) - 1 and nums[i] == nums[i + 1]:
                i += 1
            i += 1
        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<vector<int>> threeSum(vector<int> &nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> res;
    for (int i = 0; i < nums.size(); ++i) {
      if (nums[i] > 0)
        return res; // 去重
      if (i > 0 && nums[i] == nums[i - 1])
        continue; // 去重

      int left = i + 1, right = nums.size() - 1;
      while (left < right) {
        if (nums[i] + nums[left] == -nums[right]) {
          res.emplace_back(vector<int>{nums[i], nums[left], nums[right]});
          ++left;
          --right;
          while (left < right && nums[left] == nums[left - 1]) // 去重
            ++left;
          while (left < right && nums[right] == nums[right + 1]) // 去重
            --right;
        } else if (nums[i] + nums[left] < -nums[right]) ++left;
        else --right;
      }
    }
    return res;
  }
};
```

### 18. 四数之和

[18. 四数之和](https://leetcode.cn/problems/4sum/description/)

**_python_**

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        res = []
        nums.sort()
        i, j = 0, 1
        while i < len(nums):
            sum = nums[i]
            if sum > 0 and sum > target:    # 剪枝
                return res
            j = i + 1
            while j < len(nums):
                sum = nums[i] + nums[j]
                if sum > 0 and sum > target:    # 剪枝
                    break
                left, right = j + 1, len(nums) - 1
                while left < right:
                    if nums[i] + nums[j] == target - nums[left] - nums[right]:
                        res.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        left += 1
                        right -= 1
                    elif nums[i] + nums[j] < target - nums[left] - nums[right]:
                        left += 1
                    else:
                        right -= 1
                while j < len(nums) - 1 and nums[j] == nums[j + 1]:
                    j += 1
                j += 1
            while i < len(nums) - 1 and nums[i] == nums[i + 1]:
                i += 1
            i += 1
        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<vector<int>> fourSum(vector<int> &nums, int target) {
    vector<vector<int>> res;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); ++i) {
      int sum = nums[i];
      if (sum > 0 && sum > target) break;
      if (i && nums[i] == nums[i - 1]) continue;

      for (int j = i + 1; j < nums.size(); ++j) {
        sum = nums[i] + nums[j];
        if (sum > 0 && sum > target) break;
        if (j != i + 1 && nums[j] == nums[j - 1]) continue;

        int left = j + 1, right = nums.size() - 1;
        while (left < right) {
          if ((long)target - sum > nums[left] + nums[right]) ++left;
          else if ((long)target - sum < nums[left] + nums[right]) --right;
          else {
            res.emplace_back(
                vector<int>{nums[i], nums[j], nums[left], nums[right]});
            ++left;
            --right;
            while (left < right && nums[left] == nums[left - 1])
              ++left;
            while (left < right && nums[right] == nums[right + 1])
              --right;
          }
        }
      }
    }
    return res;
  }
};
```

---

## 4 字符串

### 344. 反转字符串

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)

**_python_**

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

**_cpp_**

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0, right = s.size() - 1;
        while (left < right) swap(s[left++], s[right--]);
    }
};
```

### 541. 反转字符串 II

[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/description/)

**_python_**

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        def reverseString(s: str, left, right) -> str:
            s_list = list(s)
            while left < right:
                s_list[left], s_list[right] = s_list[right], s_list[left]
                left += 1
                right -= 1
            return "".join(s_list)

        left, right = 0, k  # [)
        for _ in range(len(s) // (2 * k)):
            s = reverseString(s, left, right - 1)
            left += 2 * k
            right += 2 * k

        if right >= len(s):
            s = reverseString(s, left, len(s) - 1)
        else:
            s = reverseString(s, left, right - 1)
        return s
```

**_cpp_**

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        int count = s.size() / (2 * k);
        int left, right;
        for (left = 0, right = k; count; --count) {
            reverse(s.begin() + left, s.begin() + right);
            left += (2 * k);
            right = left + k;
        }
        right > s.size() ? reverse(s.begin() + left, s.end())
                         : reverse(s.begin() + left, s.begin() + right);
        return s;
    }
};
```

### 替换数字（第八期模拟笔试）

[替换数字（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1064)

**_python_**

```python
s = input()

res = ""
for ch in s:
    if ch.isdigit():
        res += "number"
    else:
        res += ch

print(res)
```

**_cpp_**

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
  string s, res;
  cin >> s;
  for_each(s.begin(), s.end(), [&res](const char &c) {
    if (isdigit(c)) res += "number";
    else res.push_back(c);
  });
  cout << res;
  return 0;
}
```

### 151. 翻转字符串里的单词

[151. 翻转字符串里的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

**_python_**

```python

```

**_cpp_**

```cpp
class Solution {
public:
  string reverseWords(string s) {
    int slow = 0;
    for (int right = 0; right < s.size(); ++right) {
      if (s[right] != ' ') {
        if (slow != 0)
          s[slow++] = ' ';
        while (right < s.size() && s[right] != ' ')
          s[slow++] = s[right++];
      }
    }
    s.resize(slow);

    reverse(s.begin(), s.end());
    auto pleft = s.begin(), pright = s.begin();
    for (; pright != s.end(); ++pright)
      if (*pright == ' ') {
        reverse(pleft, pright);
        pleft = pright + 1;
      }

    reverse(pleft, s.end());
    return s;
  }
};
```

### 55. 右旋字符串（第八期模拟笔试）

[55. 右旋字符串（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1065)

**_python_**

```python
def rotate_string(s, k):
    k %= len(s)  # Ensure k is within the bounds of the string length
    s = s[::-1]  # Reverse the entire string
    s = s[:k][::-1] + s[k:][::-1]  # Reverse the first k characters and the remaining characters separately
    return s

# Input
k = int(input())
s = input()

# Output the rotated string
print(rotate_string(s, k))

```

**_cpp_**

```cpp
#include <algorithm>
#include <iostream>
#include <string>

using namespace std;

int main() {
  int k;
  string s;
  cin >> k >> s;
  k %= s.size();
  reverse(s.begin(), s.end());
  reverse(s.begin(), s.begin() + k);
  reverse(s.begin() + k, s.end());
  cout << s << endl;
  return 0;
}
```

### 28. 找出字符串中第一个匹配项的下标

#### KMP

`search(char pat[], char txt[])` 函数用于在字符串 `txt` 中查找字符串 `pat`，假设 `txt.size() > pat.size()`

KMP 算法对 `pat[]` 进行预处理，得到 `next[]` 数组，`next[i]` 表示 `pat[0..i]` 的**最长真前缀后缀匹配长度**，所谓**真**是指不允许包含整个字符串的前缀

**预处理（求 `next[]` 数组）算法**

- 计算 `next[]` 中的值。为此，跟踪前一个索引的最长前缀后缀值得长度（使用 `len` 变量）
- `next[0]` 和 `len` 都初始化为 `0`
- 如果 `pat[len]` 和 `pat[i]` 匹配，将 `len` 加 `1`，并将增加后的值赋给 `lps[i]`
- 如果 `pat[i]` 和 `pat[len]` 不匹配并且 `len` 不为 `0`，我们将 `len` 更新为 `lps[len-1]`

**KMP 算法的实现**

使用 `next[]` 中的值来决定下一个要匹配的字符，不匹配那些我们知道无论如何都会匹配的字符

- `txt[i]` 和 `pat[j]` 做匹配
- 如果**匹配**，`i` 和 `j` 都加 `1`
- 如果 `j = pat.size()`，说明找到了匹配项，重置 `j = next[j - 1]` 继续匹配
- 如果**不匹配**，`j = next[j - 1]`

```cpp
class KMP {
public:
  vector<int> KMPSearch(string txt, string pat) {
    vector<int> res;
    vector<int> next = getNext(pat);
    int i = 0, j = 0;
    while (txt.size() - i >= pat.size() - j) {
      if (pat[j] == txt[i]) {
        ++i;
        ++j;
      }
      if (j == pat.size()) {
        res.push_back(i - j);
        j = next[j - 1];
      } else if (i < txt.size() && pat[j] != txt[i]) {
        if (j)
          j = next[j - 1];
        else
          ++i;
      }
    }
    return res;
  }

private:
  vector<int> getNext(const string &pat) {
    vector<int> next(pat.size());
    next[0] = 0;
    int len = 0, i = 1;

    while (i < pat.size())
      if (pat[i] == pat[len])
        next[i++] = ++len;
      else if (len) // if (pat[i] != pat[len] && len != 0)
        len = next[len - 1];
      else // if (pat[i] != pat[len] && len == 0)
        next[i++] = 0;
    return next;
  }
};
```

---

[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

**_python_**

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def getNext(pat: str):
            next = [0] * len(pat)
            length, i = 0, 1
            while i < len(pat):
                if pat[i] == pat[length]:
                    length += 1
                    next[i] = length
                    i += 1
                else:
                    if length:
                        length = next[length - 1]
                    else:
                        next[i] = 0
                        i += 1
            return next

        next = getNext(needle)
        i, j = 0, 0
        while i < len(haystack):
            if haystack[i] == needle[j]:
                i += 1
                j += 1
            if j == len(needle):
                return i - j
            elif i < len(haystack) and haystack[i] != needle[j]:
                if j:
                    j = next[j - 1]
                else:
                    i += 1
        return -1
```

**_cpp_**

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        vector<int> next(needle.size());
        getNext(needle, next);
        int i = 0, j = 0;
        while (haystack.size() - i >= needle.size() - j) {
            if (haystack[i] == needle[j]) {
                ++i;
                ++j;
            }
            if (needle.size() == j)
                return i - j;
            else if (i < haystack.size() && haystack[i] != needle[j]) {
                if (j)
                    j = next[j - 1];
                else
                    ++i;
            }
        }
        return -1;
    }

private:
    void getNext(const string& pat, vector<int>& next) {
        next[0] = 0;
        int len = 0, i = 1;
        while (i < pat.size())
            if (pat[i] == pat[len])
                next[i++] = ++len;
            else if (len)
                len = next[len - 1];
            else
                next[i++] = len;
    }
};
```

### 459.重复的子字符串

[459.重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)

`s` repeated => `s` in `s + s`
`s` no in `s + s` => `s` not repeated

**_python_**

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        return (s + s).find(s, 1) != len(s)
```

**_cpp_**

```cpp
class Solution {
public:
  bool repeatedSubstringPattern(string s) {
    return (s + s).find(s, 1) != s.size();
  }
};
```

## 5 双指针

### [27. 移除元素](#27-移除元素)

### [344. 反转字符串](#344-反转字符串-1)

### [替换数字（第八期模拟笔试）](#替换数字第八期模拟笔试)

### [151. 翻转字符串里的单词](#151-翻转字符串里的单词)

### [206.反转链表](#206反转链表)

### [19.删除链表的倒数第 N 个节点](#19删除链表的倒数第n个节点)

### [面试题 02.07. 链表相交](#面试题-0207-链表相交)

### [142.环形链表 II](#142环形链表ii)

### [15. 三数之和](#15-三数之和)

### [18. 四数之和](#18-四数之和)

## 6 栈与队列

### 232. 用栈实现队列

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

**_python_**

```python
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def transfer(self):
        while self.s1:
            self.s2.append(self.s1.pop())

    def push(self, x: int) -> None:
        self.s1.append(x)

    def pop(self) -> int:
        if not self.s2:
            self.transfer()
        return self.s2.pop()

    def peek(self) -> int:
        if not self.s2:
            self.transfer()
        return self.s2[-1]

    def empty(self) -> bool:
        return not self.s1 and not self.s2
```

**_cpp_**

```cpp
class MyQueue {
private:
    stack<int> s1;
    stack<int> s2;

    void transfer() {
        while (!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
    }

public:
    MyQueue() {}

    void push(int x) { s1.push(x); }

    int pop() {
        if (s2.empty())
            transfer();
        int temp = s2.top();
        s2.pop();
        return temp;
    }

    int peek() {
        if (s2.empty())
            transfer();
        return s2.top();
    }

    bool empty() { return s1.empty() && s2.empty(); }
};
```

### 225. 用队列实现栈

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

**_python_**

```python
class MyStack:

    def __init__(self):
        self.q = deque()

    def push(self, x: int) -> None:
        self.q.append(x)

    def pop(self) -> int:
        for _ in range(len(self.q) - 1):
            self.q.append(self.q.popleft())
        return self.q.popleft()

    def top(self) -> int:
        return self.q[-1]

    def empty(self) -> bool:
        return len(self.q) == 0
```

**_cpp_**

```cpp
class MyStack {
private:
    queue<int> q;

public:
    MyStack() {}

    void push(int x) { q.push(x); }

    int pop() {
        int size = q.size() - 1;
        while (size--) {
            q.push(q.front());
            q.pop();
        }
        int temp = q.front();
        q.pop();
        return temp;
    }

    int top() { return q.back(); }

    bool empty() { return q.empty(); }
};
```

### 20. 有效的括号

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

**_python_**

```python
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) % 2:
            return False
        stack = []
        for c in s:
            if c in "([{":
                stack.append(c)
            else:
                if not stack:
                    return False

                top = stack.pop()
                if c == ")" and top != "(":
                    return False
                if c == "]" and top != "[":
                    return False
                if c == "}" and top != "{":
                    return False
        return not stack
```

**_cpp_**

```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2) return false;
        stack<char> st;
        for (const char &c : s)
            if (c == '(' || c == '[' || c == '{') st.push(c);
            else {
                if (st.empty()) return false;
                char temp = st.top();
                st.pop();
                if ((c == ')' && temp != '(') || (c == ']' && temp != '[') ||
                    (c == '}' && temp != '{'))
                    return false;
            }
        return st.empty();
    }
};
```

### 1047. 删除字符串中的所有相邻重复项

[1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

**_python_**

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        res = []
        for c in s:
            if not res or res[-1] != c:
                res.append(c)
            else:
                res.pop()
        return ''.join(res)
```

**_cpp_**

```cpp
class Solution {
public:
  string removeDuplicates(string s) {
    string res;
    for (const char &c : s)
      (res.empty() || res.back() != c) ? res.push_back(c) : res.pop_back();
    return res;
  }
};
```

### 150. 逆波兰表达式求值

[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

**_python_**

```py
class Solution:
    def string_to_int(self, s: str) -> int:
        i, res, neg = 0, 0, False
        if s[0] == "-":
            neg = True
            i = 1
        while i < len(s):
            res = res * 10 + ord(s[i]) - ord("0")
            i += 1
        return -res if neg else res

    def evalRPN(self, tokens: List[str]) -> int:
        st = []
        for s in tokens:
            if len(s) > 1 or (s >= "0" and s <= "9"):
                st.append(self.string_to_int(s))
            else:
                y = st.pop()
                x = st.pop()
                if s == "+":
                    st.append(x + y)
                elif s == "-":
                    st.append(x - y)
                elif s == "*":
                    st.append(x * y)
                elif s == "/":
                    st.append(int(x / y))
        return st.pop()
```

**_cpp_**

```cpp
class Solution {
public:
  int evalRPN(vector<string> &tokens) {
    stack<int> st;
    for_each(tokens.begin(), tokens.end(), [&st](const string &str) {
      if (isdigit(str.back())) st.push(stoi(str));
      else {
        int y = st.top(); st.pop();
        int x = st.top(); st.pop();

        switch (str[0]) {
        case '+': st.push(x + y); break;
        case '-': st.push(x - y); break;
        case '*': st.push(x * y); break;
        case '/': st.push(x / y);
        }
      }
    });
    return st.top();
  }
};
```

### 239. 滑动窗口最大值

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

**_python_**

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        res = []
        dq = deque()

        for i in range(k):
            while dq and nums[i] > dq[-1]:
                dq.pop()
            dq.append(nums[i])

        left, right = 0, k  # [left, right)

        while right < len(nums):
            res.append(dq[0])  # Collect result

            # Remove element from deque if it's out of the window
            if nums[left] == dq[0]:
                dq.popleft()
            left += 1

            # Add new element to deque
            while dq and nums[right] > dq[-1]:
                dq.pop()
            dq.append(nums[right])
            right += 1

        res.append(dq[0])  # Collect result for the last window
        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<int> maxSlidingWindow(vector<int> &nums, int k) {
    vector<int> res; deque<int> dq;

    for_each(nums.begin(), nums.begin() + k, [&dq](const int &num) {
      while (!dq.empty() && dq.back() < num) dq.pop_back();
      dq.emplace_back(num);
    });

    int left = 0, right = k; // [)
    while (right < nums.size()) {
      res.emplace_back(dq.front()); // 收获结果
      if (dq.front() == nums[left++]) dq.pop_front(); // 出队
      // 入队
      while (!dq.empty() && dq.back() < nums[right]) dq.pop_back();
      dq.emplace_back(nums[right++]);
    }
    res.emplace_back(dq.front());
    return res;
  }
};
```

### 347.前 K 个高频元素

[347.前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

**_python_**

```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 使用Counter统计每个数字的出现频率
        count = Counter(nums)

        # 创建一个优先队列（最小堆）
        # 需要频率最高的k个元素，因此使用负频率来创建最大堆
        pq = []
        for num, freq in count.items():
            heapq.heappush(pq, (freq, num))
            if len(pq) > k:
                heapq.heappop(pq)

        # 从堆中取出前k个频率最高的元素
        res = []
        while pq:
            res.append(heapq.heappop(pq)[1])

        # 由于使用的是最小堆，因此需要将结果反转
        return res[::-1]
```

**_cpp_**

```cpp
class Solution {
private:
  struct compare {
    bool operator()(const pair<int, int> &lhs, const pair<int, int> &rhs) {
      return lhs.second > rhs.second;
    }
  };

public:
  vector<int> topKFrequent(vector<int> &nums, int k) {
    unordered_map<int, int> umap;
    for (const int &num : nums) ++umap[num];

    priority_queue<pair<int, int>, vector<pair<int, int>>, compare>
        pq; // 小顶堆
    for_each(umap.begin(), umap.end(), [&](const pair<int, int> &elem) {
      pq.push(elem);
      if (pq.size() > k) pq.pop();
    });
    umap.clear();
    vector<int> res;
    res.reserve(k);
    while (!pq.empty()) {
      res.emplace_back(pq.top().first);
      pq.pop();
    }
    return res;
  }
};
```

## 7 二叉树

### 144. 二叉树的前序遍历

[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: List[int]) -> None:
        if cur is None:
            return
        res.append(cur.val)
        self.traversal(cur.left, res)
        self.traversal(cur.right, res)

    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root is None:
            return res
        st = [root]
        while st:
            cur = st.pop()
            res.append(cur.val)
            if cur.right:
                st.append(cur.right)
            if cur.left:
                st.append(cur.left)
        return res

class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if root is None:
            return res
        res.append(root.val)
        left = self.preorderTraversal(root.left)
        right = self.preorderTraversal(root.right)
        res.extend(left)
        res.extend(right)
        return res
```

```cpp
// 递归
class Solution {
private:
  void traversal(vector<int> &res, TreeNode *cur) {
    if (!cur) return;
    res.emplace_back(cur->val);
    traversal(res, cur->left);
    traversal(res, cur->right);
  }

public:
  vector<int> preorderTraversal(TreeNode *root) {
    vector<int> res;
    traversal(res, root);
    return res;
  }
};

// 迭代
class Solution {
public:
  vector<int> preorderTraversal(TreeNode *root) {
    stack<TreeNode *> st;
    vector<int> res;
    if (root) st.emplace(root);
    while (!st.empty()) {
      TreeNode *cur = st.top();
      st.pop();
      res.emplace_back(cur->val);
      if (cur->right) st.emplace(cur->right);
      if (cur->left) st.emplace(cur->left);
    }
    return res;
  }
};


// 花式递归
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root) return res;

        res.push_back(root->val);
        vector<int> left = preorderTraversal(root->left);
        vector<int> right = preorderTraversal(root->right);
        res.insert(res.end(), left.begin(), left.end());
        res.insert(res.end(), right.begin(), right.end());
        return res;
    }
};
```

### 94. 二叉树的中序遍历

[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

**_python_**

```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: list):
        if not cur:
            return
        self.traversal(cur.left, res)
        res.append(cur.val)
        self.traversal(cur.right, res)

    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def inorderTraversal(self, root: TreeNode) -> list:
        res = []
        stack = []
        cur = root
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left  # 一直向左走
            else:
                cur = stack.pop()
                res.append(cur.val)  # 根
                cur = cur.right  # 右
        return res
```

**_cpp_**

```cpp
// 递归
class Solution {
private:
  void traversal(TreeNode *cur, vector<int> &res) {
    if (!cur) return;
    traversal(cur->left, res);
    res.emplace_back(cur->val);
    traversal(cur->right, res);
  }

public:
  vector<int> inorderTraversal(TreeNode *root) {
    vector<int> res;
    traversal(root, res);
    return res;
  }
};

// 迭代
class Solution {
public:
  vector<int> inorderTraversal(TreeNode *root) {
    vector<int> res;
    stack<TreeNode *> st;
    TreeNode *cur = root;
    while (cur || !st.empty()) {
      if (cur) {
        st.emplace(cur);
        cur = cur->left; // 左
      } else {
        cur = st.top();
        st.pop();
        res.emplace_back(cur->val); // 收结果（根）
        cur = cur->right;           // 右
      }
    }
    return res;
  }
};
```

### 145. 二叉树的后序遍历

[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

**_python_**

```python
# 递归
class Solution:
    def traversal(self, cur: TreeNode, res: list):
        if not cur:
            return
        self.traversal(cur.left, res)
        self.traversal(cur.right, res)
        res.append(cur.val)

    def postorderTraversal(self, root: TreeNode) -> list:
        res = []
        self.traversal(root, res)
        return res

# 迭代
class Solution:
    def postorderTraversal(self, root: TreeNode) -> list:
        res = []
        if not root:
            return res
        stack = [root]
        while stack:
            cur = stack.pop()
            res.append(cur.val)
            if cur.left:
                stack.append(cur.left)
            if cur.right:
                stack.append(cur.right)
        res.reverse()
        return res
```

**_cpp_**

```cpp
// 递归
class Solution {
public:
  void traversal(TreeNode *cur, vector<int> &res) {
    if (cur == nullptr) return;
    traversal(cur->left, res);
    traversal(cur->right, res);
    res.push_back(cur->val);
  }

  vector<int> postorderTraversal(TreeNode *root) {
    vector<int> res;
    traversal(root, res);
    return res;
  }
};

// 迭代
class Solution {
public:
  vector<int> postorderTraversal(TreeNode *root) {
    stack<TreeNode *> st;
    vector<int> res;
    if (!root) return res;
    st.emplace(root);

    while (!st.empty()) {
      TreeNode *cur = st.top();
      st.pop();
      res.emplace_back(cur->val);
      if (cur->left) st.emplace(cur->left);
      if (cur->right) st.emplace(cur->right);
    }
    reverse(res.begin(), res.end());
    return res;
  }
};
```

### 102. 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**_python_**

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> list:
        res = []
        if not root:
            return res
        que = deque([root])
        while que:
            level_size = len(que)
            level = []
            for _ in range(level_size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
                level.append(cur.val)
            res.append(level)
        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<vector<int>> levelOrder(TreeNode *root) {
    vector<vector<int>> res;
    queue<TreeNode *> que;
    if (root) que.emplace(root);
    while (!que.empty()) {
      int size = que.size();
      vector<int> vec;
      while (size--) {
        TreeNode *cur = que.front();
        que.pop();
        vec.emplace_back(cur->val);
        if (cur->left) que.emplace(cur->left);
        if (cur->right) que.emplace(cur->right);
      }
      res.emplace_back(vec);
    }
    return res;
  }
};
```

### 107. 二叉树的层序遍历 II

[107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

**_python_**

```python
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        if not root:
            return res
        que = deque([root])
        while que:
            level_size = len(que)
            level = []
            for _ in range(level_size):
                cur = que.popleft()
                level.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(level)
        res.reverse()
        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<vector<int>> levelOrderBottom(TreeNode *root) {
    vector<vector<int>> res;
    queue<TreeNode *> que;
    if (root) que.emplace(root);
    while (!que.empty()) {
      int size = que.size();
      vector<int> vec;
      while (size--) {
        TreeNode *cur = que.front();
        que.pop();
        vec.emplace_back(cur->val);
        if (cur->left) que.emplace(cur->left);
        if (cur->right) que.emplace(cur->right);
      }
      res.emplace_back(vec);
    }
    reverse(res.begin(), res.end());
    return res;
  }
};
```

### 199. 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

**_python_**

```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        que = deque([root]) if root else deque()

        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
                if i == size - 1:  # last node in this level
                    res.append(cur.val)

        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<int> rightSideView(TreeNode *root) {
    vector<int> res;
    queue<TreeNode *> que;
    if (root) que.emplace(root);
    while (!que.empty()) {
      int size = que.size();
      while (size--) {
        TreeNode *cur = que.front();
        que.pop();
        if (cur->left) que.emplace(cur->left);
        if (cur->right) que.emplace(cur->right);
        if (size == 0) res.emplace_back(cur->val);
      }
    }
    return res;
  }
};
```

### 637. 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

**_python_**

```python
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        res = []
        que = deque([root]) if root else deque()

        while que:
            size = len(que)
            sum_val = 0
            for _ in range(size):
                cur = que.popleft()
                sum_val += cur.val
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(sum_val / size)

        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<double> averageOfLevels(TreeNode *root) {
    vector<double> res;
    queue<TreeNode *> que;
    if (root) que.emplace(root);
    while (!que.empty()) {
      int size = que.size();
      int back_size = size;
      double sum = 0;
      while (size--) {
        TreeNode *cur = que.front();
        que.pop();
        sum += cur->val;
        if (cur->left) que.emplace(cur->left);
        if (cur->right) que.emplace(cur->right);
      }
      res.emplace_back(sum / back_size);
    }
    return res;
  }
};
```

### 429. N 叉树的层序遍历

[429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

**_python_**

```python
class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        res = []
        que = deque([root]) if root else deque()

        while que:
            size = len(que)
            level = []
            for _ in range(size):
                cur = que.popleft()
                level.append(cur.val)
                for child in cur.children:
                    que.append(child)
            res.append(level)

        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<vector<int>> levelOrder(Node *root) {
    vector<vector<int>> res;
    queue<Node *> que;
    if (root) que.emplace(root);
    while (!que.empty()) {
      int size = que.size();
      vector<int> vec;
      while (size--) {
        Node *cur = que.front();
        que.pop();
        vec.emplace_back(cur->val);
        for (Node *const &node : cur->children)
          que.emplace(node);
      }
      res.emplace_back(vec);
    }
    return res;
  }
};
```

### 515. 在每个树行中找最大值

[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

**_python_**

```python
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        que = deque([root]) if root else deque()

        while que:
            size = len(que)
            max_val = float('-inf')
            for _ in range(size):
                cur = que.popleft()
                max_val = max(max_val, cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            res.append(max_val)

        return res
```

**_cpp_**

```cpp
class Solution {
public:
  vector<int> largestValues(TreeNode *root) {
    vector<int> res;
    queue<TreeNode *> que;
    if (root) que.emplace(root);
    while (!que.empty()) {
      int size = que.size();
      res.emplace_back(que.front()->val);
      while (size--) {
        TreeNode *cur = que.front();
        que.pop();
        res.back() = max(cur->val, res.back());
        if (cur->left) que.emplace(cur->left);
        if (cur->right) que.emplace(cur->right);
      }
    }
    return res;
  }
};
```

### 116. 填充每个节点的下一个右侧节点指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

**_python_**

```python
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        que = deque([root]) if root else deque()

        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if i < size - 1:
                    cur.next = que[0]
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)

        return root
```

**_cpp_**

```cpp
class Solution {
public:
  Node *connect(Node *root) {
    queue<Node *> que;
    if (root) que.emplace(root);
    while (!que.empty()) {
      int size = que.size();
      while (size--) {
        Node *cur = que.front();
        que.pop();
        if (size) cur->next = que.front();
        if (cur->left) que.emplace(cur->left);
        if (cur->right) que.emplace(cur->right);
      }
    }
    return root;
  }
};
```

### 117. 填充每个节点的下一个右侧节点指针 II

[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

**_python_**

```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root

        que = deque([root])

        while que:
            size = len(que)
            for i in range(size):
                cur = que.popleft()
                if i < size - 1:  # If it's not the last node in the current level
                    cur.next = que[0]
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)

        return root
```

**_cpp_**

```cpp
class Solution {
public:
  Node *connect(Node *root) {
    queue<Node *> que;
    if (root) que.push(root);
    while (!que.empty()) {
      int size = que.size();
      while (size--) {
        Node *cur = que.front();
        que.pop();
        if (size) cur->next = que.front();
        if (cur->left) que.push(cur->left);
        if (cur->right) que.push(cur->right);
      }
    }
    return root;
  }
};
```

### 104. 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**_python_**

```python
# 层序
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        res = 0
        que = deque([root])

        while que:
            res += 1
            size = len(que)
            for _ in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)

        return res

# 回溯
class Solution:
    def __init__(self):
        self.res = 0
        self.depth = 0

    def traverse(self, root: TreeNode):
        if not root:
            return
        self.depth += 1
        self.traverse(root.left)
        self.traverse(root.right)
        self.res = max(self.res, self.depth)
        self.depth -= 1

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        self.traverse(root)
        return self.res

# dfs, 带返回值
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

**_cpp_**

```cpp
// 层序遍历
class Solution {
public:
  int maxDepth(TreeNode *root) {
    int res = 0;
    queue<TreeNode *> que;
    if (root) que.push(root);
    while (!que.empty()) {
      ++res;
      int size = que.size();
      while (size--) {
        TreeNode *cur = que.front();
        que.pop();
        if (cur->left) que.push(cur->left);
        if (cur->right) que.push(cur->right);
      }
    }
    return res;
  }
};

// 回溯
class Solution {
private:
    int res = 0, depth = 0;
    void traverse(TreeNode* root) {
        if (!root) return;
        ++depth;
        res = max(res, depth);
        traverse(root->left);
        traverse(root->right);
        --depth;
    }

public:
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
}

// dfs，带返回值
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

### 111. 二叉树的最小深度

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

**_python_**

```python
# 层序遍历
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        depth = 0
        que = deque([root])

        while que:
            depth += 1
            size = len(que)
            for _ in range(size):
                cur = que.popleft()
                if not cur.left and not cur.right:
                    return depth
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)

        return depth

# dfs, 带返回值
class Solution:
    def dfs(self, root: TreeNode) -> int:
        if not root:
            return float('inf')
        if not root.left and not root.right:
            return 1
        return min(self.dfs(root.left), self.dfs(root.right)) + 1

    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return self.dfs(root)

# dfs, 分情况讨论
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        if root.left and not root.right:
            return self.minDepth(root.left) + 1
        elif not root.left and root.right:
            return self.minDepth(root.right) + 1
        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
```

**_cpp_**

```cpp
// 层序遍历
class Solution {
public:
    int minDepth(TreeNode* root) {
        int depth = 0;
        queue<TreeNode*> que;
        if (root) que.push(root);
        while (!que.empty()) {
            ++depth;
            int size = que.size();
            while (size--) {
                TreeNode* cur = que.front();
                que.pop();
                if (!cur->left && !cur->right) return depth;
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }
        return depth;
    }
};

// dfs, 带返回值
class Solution {
private:
    int dfs(TreeNode* root) {
        if (!root) return 10001;
        if (!root->left && !root->right) return 1;
        return min(dfs(root->left), dfs(root->right)) + 1;
    }

public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        return dfs(root);
    }
};

// dfs, 分情况讨论
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (!root) return 0;
        if (root->left && root->right == nullptr)
            return minDepth(root->left) + 1;
        else if (root->left == nullptr && root->right)
            return minDepth(root->right) + 1;
        return min(minDepth(root->left), minDepth(root->right)) + 1;
    }
};
```

### 226. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

**_python_**

```python
# dfs
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        self.invertTree(root.left)
        self.invertTree(root.right)
        root.left, root.right = root.right, root.left
        return root

# bfs
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root

        stack = [root]
        while stack:
            cur = stack.pop()
            cur.left, cur.right = cur.right, cur.left
            if cur.left:
                stack.append(cur.left)
            if cur.right:
                stack.append(cur.right)

        return root
```

**_cpp_**

```cpp
// dfs
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return root;
        invertTree(root->left);
        invertTree(root->right);
        swap(root->left, root->right);
        return root;
    }
};

// bfs
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            swap(cur->left,cur->right);
            if (cur->left) st.push(cur->left);
            if (cur->right) st.push(cur->right);
        }
        return root;
    }
};
```

### 101. 对称二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

**_python_**

```python
# 递归
class Solution:
    def compare(self, left: TreeNode, right: TreeNode) -> bool:
        if (left is None and right is not None) or (left is not None and right is None):
            return False
        elif left is None and right is None:
            return True
        elif left.val != right.val:
            return False
        else:
            return self.compare(left.left, right.right) and self.compare(
                left.right, right.left
            )

    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        return self.compare(root.left, root.right)

# 迭代
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        stack = []
        stack.append(root.right)
        stack.append(root.left)

        while stack:
            left = stack.pop()
            right = stack.pop()

            if not left and not right:
                continue
            if not left or not right:
                return False
            if left.val != right.val:
                return False

            stack.append(left.left)
            stack.append(right.right)
            stack.append(left.right)
            stack.append(right.left)

        return True
```

**_cpp_**

```cpp
// 递归
class Solution {
public:
    bool compare(TreeNode *left, TreeNode *right) {
        if ((left == nullptr && right != nullptr) || (left != nullptr && right == nullptr))
            return false;
        else if(left == nullptr && right == nullptr) return true;
        else if (left->val != right->val) return false;
        else return compare(left->left, right->right) && compare(left->right, right->left);
    }

    bool isSymmetric(TreeNode *root) {
        return compare(root->left, root->right);
    }
};


// 迭代
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        stack<TreeNode*> st;
        st.push(root->right);
        st.push(root->left);
        while (!st.empty()) {
            TreeNode* left = st.top();
            st.pop();
            TreeNode* right = st.top();
            st.pop();
            if (!left && !right) continue;
            if (!left && right) return false;
            if (left && !right) return false;
            if (left->val != right->val) return false;
            st.push(left->left);
            st.push(right->right);
            st.push(left->right);
            st.push(right->left);
        }
        return true;
    }
};
```

### 100. 相同的树

[100. 相同的树](https://leetcode.cn/problems/same-tree/description/)

**_python_**

```python
# 递归
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None and q is None:
            return True
        elif p is None and q is not None:
            return False
        elif p is not None and q is None:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

# 迭代
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        queue = deque()
        queue.append(p)
        queue.append(q)

        while queue:
            left = queue.popleft()
            right = queue.popleft()

            if not left and not right:
                continue
            if left and not right:
                return False
            if not left and right:
                return False
            if left.val != right.val:
                return False

            queue.append(left.left)
            queue.append(right.left)
            queue.append(left.right)
            queue.append(right.right)

        return True
```

**_cpp_**

```cpp
// 递归
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (!p && !q ) return true;
        else if (!p && q) return false;
        else if (p && !q) return false;
        else if (p->val != q->val) return false;
        else return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));
    }
};

// 迭代
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode *> que;
        que.push(p);
        que.push(q);
        while (!que.empty()){
            TreeNode *left = que.front();
            que.pop();
            TreeNode *right = que.front();
            que.pop();
            if (!left && !right) continue;
            if (left && !right) return false;
            if (!left && right) return false;
            if (left->val != right->val) return false;
            que.push(left->left);
            que.push(right->left);
            que.push(left->right);
            que.push(right->right);
        }
        return true;
    }
};
```

### 572. 另一棵树的子树

[572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)

**_python_**

```python
# 层序 + 逐棵子树对比
class Solution:
    def compare(self, p: TreeNode, q: TreeNode) -> bool:
        stack = []
        stack.append(p)
        stack.append(q)

        while stack:
            qNode = stack.pop()
            pNode = stack.pop()

            if not qNode and not pNode:
                continue
            elif qNode is None and pNode is not None:
                return False
            elif qNode is not None and pNode is None:
                return False
            elif qNode.val != pNode.val:
                return False

            stack.append(pNode.left)
            stack.append(qNode.left)
            stack.append(pNode.right)
            stack.append(qNode.right)

        return True

    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        if not root:
            return False

        queue = deque()
        queue.append(root)

        while queue:
            cur = queue.popleft()
            if self.compare(cur, subRoot):
                return True
            if cur.left:
                queue.append(cur.left)
            if cur.right:
                queue.append(cur.right)

        return False


# KMP + 先序遍历
class KMP:
    def getNext(self, vec):
        res = [0] * len(vec)
        length = 0
        i = 1
        while i < len(vec):
            if vec[i].val == vec[length].val:
                length += 1
                res[i] = length
                i += 1
            elif length:
                length = res[length - 1]
            else:
                res[i] = 0
                i += 1
        return res

    def findStart(self, vec, vecsub):
        res = []
        next_arr = self.getNext(vecsub)
        i = 0
        j = 0
        while len(vec) - i >= len(vecsub) - j:
            if vec[i].val == vecsub[j].val:
                i += 1
                j += 1

            if j == len(vecsub):
                res.append(vec[i - j])
                j = next_arr[j - 1]
            elif i < len(vec) and vec[i].val != vecsub[j].val:
                if j != 0:
                    j = next_arr[j - 1]
                else:
                    i += 1
        return res

class Solution:
    def compare(self, p: TreeNode, q: TreeNode) -> bool:
        stack = []
        stack.append(p)
        stack.append(q)

        while stack:
            qNode = stack.pop()
            pNode = stack.pop()

            if not qNode and not pNode:
                continue
            elif not qNode or not pNode:
                return False
            elif qNode.val != pNode.val:
                return False

            stack.append(pNode.left)
            stack.append(qNode.left)
            stack.append(pNode.right)
            stack.append(qNode.right)

        return True

    def preorder(self, cur: TreeNode, res: list):
        if cur is None:
            return
        res.append(cur)
        self.preorder(cur.left, res)
        self.preorder(cur.right, res)

    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        vec = []
        vecsub = []
        self.preorder(root, vec)
        self.preorder(subRoot, vecsub)

        kmp = KMP()
        res = kmp.findStart(vec, vecsub)

        for cur in res:
            if self.compare(cur, subRoot):
                return True

        return False
```

**_cpp_**

```cpp
// 层序 + 逐棵子树对比
class Solution {
public:
    bool compare(TreeNode *p, TreeNode *q) { // 比较 p 和 q是否为同一棵树
        stack<TreeNode *> st;
        st.push(p);
        st.push(q);
        while (!st.empty()) {
            TreeNode *qNode = st.top();
            st.pop();
            TreeNode *pNode = st.top();
            st.pop();
            if (!qNode && !pNode) continue;
            else if (!qNode && pNode) return false;
            else if (qNode && !pNode) return false;
            else if (qNode->val != pNode->val) return false;

            st.push(pNode->left);
            st.push(qNode->left);
            st.push(pNode->right);
            st.push(qNode->right);
        }
        return true;
    }

    bool isSubtree(TreeNode *root, TreeNode *subRoot) {
        queue<TreeNode *> que;
        que.push(root);
        while (!que.empty()) {
            TreeNode *cur = que.front();
            if (compare(cur, subRoot)) return true;
            que.pop();
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
        return false;
    }
};

// 先序遍历 + KMP
class Solution {
public:
    class KMP {
    public:
        vector<int> getNext(vector<TreeNode*> vec) {
            vector<int> res(vec.size(), 0);
            int len = 0; // len 跟踪最长公共前缀
            int i = 1;
            while (i < vec.size()) {
                if (vec[i]->val == vec[len]->val) {
                    ++len;
                    res[i++] = len;
                } else if (len) len = res[len - 1];
                else res[i++] = 0;
            }
            return res;
        }

        vector<TreeNode*> findStart(vector<TreeNode*> vec,
                                    vector<TreeNode*> vecsub) {
            vector<TreeNode*> res;
            vector<int> next = getNext(vecsub);
            int i = 0, j = 0; // i 追踪 vec，j 追踪 vecsub
            while (vec.size() - i >= vecsub.size() - j) {
                if (vec[i]->val == vecsub[j]->val) {
                    i++;
                    j++;
                }

                if (j == vecsub.size()) {
                    res.push_back(vec[i - j]);
                    j = next[j - 1];
                } else if (i < vec.size() && vec[i]->val != vecsub[j]->val) {
                    if (j != 0) j = next[j - 1];
                    else i++;
                }
            }
            return res;
        }
    };

    bool compare(TreeNode* p, TreeNode* q) { // 比较 p 和 q是否为同一棵树
        stack<TreeNode*> st;
        st.push(p);
        st.push(q);
        while (!st.empty()) {
            TreeNode* qNode = st.top(); st.pop();
            TreeNode* pNode = st.top(); st.pop();
            if (!qNode && !pNode) continue;
            else if (!qNode && pNode) return false;
            else if (qNode && !pNode) return false;
            else if (qNode->val != pNode->val) return false;

            st.push(pNode->left);
            st.push(qNode->left);
            st.push(pNode->right);
            st.push(qNode->right);
        }
        return true;
    }

    void preorder(TreeNode* cur, vector<TreeNode*>& res) {
        if (cur == nullptr) return;
        res.push_back(cur);
        preorder(cur->left, res);
        preorder(cur->right, res);
    }

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        vector<TreeNode*> vec;
        vector<TreeNode*> vecsub;
        preorder(root, vec);       // vec 为 root 的先序遍历结果
        preorder(subRoot, vecsub); // vecsub 为 subRoot 的先序遍历结果
        KMP kmp;
        vector<TreeNode*> res = kmp.findStart(vec, vecsub);
        for (TreeNode* cur : res)
            if (compare(cur, subRoot)) return true;
        return false;
    }
};
```

### 559. n 叉树的最大深度

[559. n 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/)

**_python_**

```python
# bfs
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0

        queue = deque([root])
        depth = 0

        while queue:
            depth += 1
            level_size = len(queue)
            for _ in range(level_size):
                current = queue.popleft()
                for child in current.children:
                    queue.append(child)

        return depth

# dfs
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0

        depth = 0
        for child in root.children:
            depth = max(depth, self.maxDepth(child))

        return depth + 1
```

**_cpp_**

```cpp
// bfs

class Solution {
public:
    int maxDepth(Node *root) {
        queue<Node *> que;
        int res = 0;
        if (root) que.push(root);
        while (!que.empty()) {
            res++;
            int size = que.size();
            while (size--) {
                Node *cur = que.front();
                que.pop();
                for (Node *const &node : cur->children)
                    que.push(node);
            }
        }
        return res;
    }
};

// dfs
class Solution {
public:
    int maxDepth(Node* root) {
        if (!root) return 0;
        int depth = 0;
        for (Node *const &cur : root->children)
            depth = max(depth, maxDepth(cur));
        return depth + 1;
    }
};
```

### 222. 完全二叉树的节点个数

[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

**_python_**

```python
# 层序
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        queue = deque([root])
        count = 0

        while queue:
            count += 1
            current = queue.popleft()
            if current.left:
                queue.append(current.left)
            if current.right:
                queue.append(current.right)

        return count

# 递归
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        return self.countNodes(root.left) + self.countNodes(root.right) + 1


# 利用完全二叉树性质
class Solution:
    def isCompleteBinaryTree(self, root: Optional[TreeNode]) -> int:
        left, right = 0, 0
        cur = root
        while cur:
            left += 1
            cur = cur.left
        cur = root
        while cur:
            right += 1
            cur = cur.right

        if left == right:
            return 2**left - 1
        else:
            return -1

    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        temp = self.isCompleteBinaryTree(root)
        if temp != -1:
            return temp

        return self.countNodes(root.left) + self.countNodes(root.right) + 1
```

**_cpp_**

```cpp
// 层序
class Solution {
public:
    int countNodes(TreeNode* root) {
        queue<TreeNode*> que;
        int res = 0;
        if (root) que.push(root);
        while (!que.empty()) {
            ++res;
            TreeNode* cur = que.front();
            que.pop();
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }
        return res;
    }
};

// 递归
class Solution {
public:
  int countNodes(TreeNode *root) {
    if (!root) return 0;
    return countNodes(root->left) + countNodes(root->right) + 1;
  }
};

// 利用完全二叉树性质
class Solution {
private:
  int isCompleteBinaryTree(TreeNode *root) {
    int left = 1, right = 1;
    TreeNode *cur = root;
    while (cur = cur->left) ++left;
    cur = root;
    while (cur = cur->right) ++right;
    return left == right ? pow(2, left) - 1 : -1;
  }

public:
  int countNodes(TreeNode *root) {
    if (!root) return 0;
    int temp = isCompleteBinaryTree(root);
    if (-1 != temp) return temp;
    return countNodes(root->left) + countNodes(root->right) + 1;
  }
};
```

### 110. 平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/description/)

**_python_**

```python
# bfs 进行逐个判断
class Solution:
    def getHeight(self, root: TreeNode) -> int:
        if not root:
            return 0
        left_height = self.getHeight(root.left)
        right_height = self.getHeight(root.right)
        return max(left_height, right_height) + 1

    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def checkBalance(node: TreeNode) -> int:
            if not node:
                return 0
            left_height = checkBalance(node.left)
            right_height = checkBalance(node.right)
            if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1

        return checkBalance(root) != -1

# dfs
class Solution:
    def dfs(self, root: TreeNode) -> tuple[bool, int]:
        if not root:
            return True, 0

        left = self.dfs(root.left)
        right = self.dfs(root.right)

        if not left[0] or not right[0] or abs(left[1] - right[1]) > 1:
            return False, 0

        return True, max(left[1], right[1]) + 1

    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        return self.dfs(root)[0]

# dfs
class Solution:
    def dfs(self, root: TreeNode, flag: list[bool]) -> int:
        if not root or not flag[0]:
            return 0
        left = self.dfs(root.left, flag)
        right = self.dfs(root.right, flag)
        if abs(left - right) > 1:
            flag[0] = False
        return max(left, right) + 1

    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        flag = [True]
        self.dfs(root, flag)
        return flag[0]
```

**_cpp_**

```cpp
// bfs 进行逐个判断
class Solution {
private:
  int getHeight(TreeNode *root) {
    if (!root) return 0;
    return max(getHeight(root->left), getHeight(root->right)) + 1;
  }

public:
  bool isBalanced(TreeNode *root) {
    queue<TreeNode *> que;
    if (root) que.push(root);
    while (!que.empty()) {
      TreeNode *cur = que.front();
      que.pop();
      if (abs(getHeight(cur->left) - getHeight(cur->right)) > 1) return false;
      if (cur->left) que.push(cur->left);
      if (cur->right) que.push(cur->right);
    }
    return true;
  }
};


// dfs
class Solution {
private:
  pair<bool, int> dfs(TreeNode *root) {
    if (!root) return {true, 0};

    auto left = dfs(root->left);
    auto right = dfs(root->right);

    if (!left.first || !right.first || abs(left.second - right.second) > 1)
      return {false, 0};

    return {true, max(left.second, right.second) + 1};
  }

public:
  bool isBalanced(TreeNode *root) { return dfs(root).first; }
};

// dfs
class Solution {
private:
  int dfs(TreeNode *root, bool &flag) {
    if (!root || !flag) return 0;
    int left = dfs(root->left, flag);
    int right = dfs(root->right, flag);
    if (abs(left - right) > 1) flag = false;
    return max(left, right) + 1;
  }

public:
  bool isBalanced(TreeNode *root) {
    bool flag = true;
    dfs(root, flag);
    return flag;
  }
};
```

### 257. 二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/description/)

**_python_**

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        def backtracking(node, path=""):
            if not node:
                return
            if not node.left and not node.right:
                res.append(path + str(node.val))
                return
            backtracking(node.left, path + str(node.val) + "->")
            backtracking(node.right, path + str(node.val) + "->")

        backtracking(root)
        return res
```

**_cpp_**

```cpp
class Solution {
private:
  vector<string> res;
  void backtracking(TreeNode *root, string path) {
    if (!root) return;
    if (!root->left && !root->right) {
      res.emplace_back(path + to_string(root->val));
      return;
    }
    backtracking(root->left, path + to_string(root->val) + "->");
    backtracking(root->right, path + to_string(root->val) + "->");
  }

public:
  vector<string> binaryTreePaths(TreeNode *root) {
    backtracking(root, "");
    return res;
  }
};
```

### 404. 左叶子之和

[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/description/)

**_python_**

```python
# bfs 逐个判断
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        que = deque([root])
        sum = 0

        while que:
            cur = que.popleft()
            if cur.left and not cur.left.left and not cur.left.right:
                sum += cur.left.val
            if cur.left:
                que.append(cur.left)
            if cur.right:
                que.append(cur.right)

        return sum

# dfs
class Solution:
    def dfs(self, root: TreeNode, isLeft: bool) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return root.val if isLeft else 0  # 只有左叶子节点才累加其值
        return self.dfs(root.left, True) + self.dfs(root.right, False)

    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return self.dfs(root, False)
```

**_cpp_**

```cpp
// bfs 逐个判断
class Solution {
public:
  int sumOfLeftLeaves(TreeNode *root) {
    queue<TreeNode *> que;
    int sum = 0;
    if (root) que.emplace(root);
    while (!que.empty()) {
      TreeNode *cur = que.front();
      que.pop();
      if (cur->left && !cur->left->left && !cur->left->right) sum += cur->left->val;
      if (cur->left) que.push(cur->left);
      if (cur->right) que.push(cur->right);
    }
    return sum;
  }
};


// dfs
class Solution {
private:
  int dfs(TreeNode *root, bool isLeft) {
    if (!root) return 0;
    if (!root->left && !root->right)
      return isLeft ? root->val : 0;
    return dfs(root->left, true) + dfs(root->right, false);
  }

public:
  int sumOfLeftLeaves(TreeNode *root) { return dfs(root, false); }
};
```

### 513. 找树左下角的值

[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/description/)

**_python_**

```python
# bfs
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        que = deque([root])
        ans = root.val

        while que:
            size = len(que)
            ans = que[0].val  # 第一个节点是当前层的最左边节点

            for _ in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)

        return ans
```

**_cpp_**

```cpp
// bfs
class Solution {
public:
  int findBottomLeftValue(TreeNode *root) {
    queue<TreeNode *> que;
    int ans = root->val;
    if (root) que.push(root);
    while (!que.empty()) {
      int size = que.size();
      ans = que.front()->val;
      while (size--) {
        TreeNode *cur = que.front();
        que.pop();
        if (cur->left) que.push(cur->left);
        if (cur->right) que.push(cur->right);
      }
    }
    return ans;
  }
};
```

### 112. 路径总和

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/description/)

**_python_**

```python
# dfs, 回溯
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False

        if not root.left and not root.right and targetSum == root.val:
            return True

        return (self.hasPathSum(root.left, targetSum - root.val) or
                self.hasPathSum(root.right, targetSum - root.val))
```

**_cpp_**

```cpp
// dfs, 回溯
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root) return false;

        if (!root->left && !root->right && targetSum == root->val)
            return true;
        return hasPathSum(root->left, targetSum - root->val) ||
               hasPathSum(root->right, targetSum - root->val);
    }
};
```

### 113. 路径总和 ii

[113. 路径总和 ii](https://leetcode-cn.com/problems/path-sum-ii/description/)

**_python_**

```python
class Solution:
    def backtracking(self, root: TreeNode, targetSum: int):
        if not root:
            return
        targetSum -= root.val
        self.path.append(root.val)

        if not root.left and not root.right and targetSum == 0:
            self.res.append(list(self.path))  # make a copy of the current path

        self.backtracking(root.left, targetSum)
        self.backtracking(root.right, targetSum)
        self.path.pop()

    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.res = []
        self.path = []
        self.backtracking(root, targetSum)
        return self.res
```

**_cpp_**

```cpp
class Solution {
private:
  vector<vector<int>> res;
  vector<int> path;
  void backtracking(TreeNode *root, int targetSum) {
    if (!root) return;
    targetSum -= root->val;
    path.emplace_back(root->val);

    if (!root->left && !root->right && !targetSum)
      res.emplace_back(path);

    backtracking(root->left, targetSum);
    backtracking(root->right, targetSum);
    path.pop_back();
  }

public:
  vector<vector<int>> pathSum(TreeNode *root, int targetSum) {
    backtracking(root, targetSum);
    return res;
  }
};
```

### 106. 从中序与后序遍历序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

**_python_**

```python
class Solution:
    def __init__(self):
        self.umap = {}

    def build(self, inorder, il, ir, postorder, pl, pr):
        if pl > pr:
            return None
        root = TreeNode(postorder[pr])  # 创建根节点
        if pl == pr:
            return root  # 仅有一个节点
        index = self.umap[postorder[pr]]
        root.right = self.build(inorder, index + 1, ir, postorder, pr - ir + index, pr - 1)
        root.left = self.build(inorder, il, index - 1, postorder, pl, pr - ir + index - 1)
        return root

    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        for i, val in enumerate(inorder):
            self.umap[val] = i
        return self.build(inorder, 0, len(inorder) - 1, postorder, 0, len(postorder) - 1)
```

**_cpp_**

```cpp
class Solution {
private:
  unordered_map<int, int> umap;
  TreeNode *build(const vector<int> &inorder, int il, int ir,
                  const vector<int> &postorder, int pl, int pr) {
    if (pl > pr) return nullptr;
    TreeNode *root = new TreeNode(postorder[pr]);
    if (pl == pr) return root;
    int index = umap[postorder[pr]];
    root->left =
        build(inorder, il, index - 1, postorder, pl, pr - ir + index - 1);
    root->right =
        build(inorder, index + 1, ir, postorder, pr - ir + index, pr - 1);
    return root;
  }

public:
  TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
    for (int i = 0; i < inorder.size(); ++i) umap[inorder[i]] = i;
    return build(inorder, 0, inorder.size() - 1, postorder, 0,
                 postorder.size() - 1);
  }
};
```

### 105.从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

**_python_**

```python
class Solution:
    def __init__(self):
        self.umap = {}

    def build(self, preorder, pl, pr, inorder, il, ir):
        if pl > pr:
            return None
        root = TreeNode(preorder[pl])
        if pl == pr:
            return root
        index = self.umap[preorder[pl]]
        root.left = self.build(preorder, pl + 1, pl + index - il, inorder, il, index - 1)
        root.right = self.build(preorder, pl + index - il + 1, pr, inorder, index + 1, ir)
        return root

    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        self.umap = {val: i for i, val in enumerate(inorder)}
        return self.build(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1)
```

**_cpp_**

```cpp
class Solution {
private:
  unordered_map<int, int> umap;
  TreeNode *build(const vector<int> &preorder, int pl, int pr,
                  const vector<int> &inorder, int il, int ir) {
    if (pl > pr) return nullptr;
    TreeNode *root = new TreeNode(preorder[pl]);
    if (pl == pr) return root;
    int index = umap[preorder[pl]];
    root->left =
        build(preorder, pl + 1, pl + index - il, inorder, il, index - 1);
    root->right =
        build(preorder, pl + index - il + 1, pr, inorder, index + 1, ir);
    return root;
  }

public:
  TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
    for (int i = 0; i < inorder.size(); ++i) umap[inorder[i]] = i;
    return build(preorder, 0, preorder.size() - 1, inorder, 0,
                 inorder.size() - 1);
  }
};
```

### 654. 最大二叉树

[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/description/)

**_python_**

```python
class Solution:
    def build(self, nums, l, r):
        if l > r:
            return None
        index = l
        for i in range(l, r + 1):
            if nums[i] > nums[index]:
                index = i
        root = TreeNode(nums[index])
        root.left = self.build(nums, l, index - 1)
        root.right = self.build(nums, index + 1, r)
        return root

    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        return self.build(nums, 0, len(nums) - 1)
```

**_cpp_**

```cpp
class Solution {
private:
  TreeNode *build(const vector<int> &nums, int left, int right) {
    if (left > right) return nullptr;
    int index = left;
    for (int i = left; i <= right; ++i)
      if (nums[index] < nums[i]) index = i;
    TreeNode *root = new TreeNode(nums[index]);
    root->left = build(nums, left, index - 1);
    root->right = build(nums, index + 1, right);
    return root;
  }

public:
  TreeNode *constructMaximumBinaryTree(vector<int> &nums) {
    return build(nums, 0, nums.size() - 1);
  }
};
```

### 617. 合并二叉树

[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)

**_python_**

```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1:
            return root2
        if root1 and root2:
            root1.val += root2.val
            root1.left = self.mergeTrees(root1.left, root2.left)
            root1.right = self.mergeTrees(root1.right, root2.right)
        return root1
```

**_cpp_**

```cpp
class Solution {
public:
  TreeNode *mergeTrees(TreeNode *root1, TreeNode *root2) {
    if (!root1) return root2;
    if (root1 && root2) {
      root1->val += root2->val;
      root1->left = mergeTrees(root1->left, root2->left);
      root1->right = mergeTrees(root1->right, root2->right);
    }
    return root1;
  }
};
```

### 700. 二叉搜索树中的搜索

[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/description/)

**_python_**

```python
# 递归
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root or val == root.val:
            return root
        elif val > root.val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)

# 迭代
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        p = root
        while p:
            if p.val == val:
                return p
            elif p.val < val:
                p = p.right
            else:
                p = p.left
        return None
```

**_cpp_**

```cpp
// 递归
class Solution {
public:
  TreeNode *searchBST(TreeNode *root, int val) {
    if (!root || val == root->val) return root;
    else if (val > root->val) return searchBST(root->right, val);
    else return searchBST(root->left, val);
  }
};


// 迭代
class Solution {
public:
  TreeNode *searchBST(TreeNode *root, int val) {
    TreeNode *p = root;
    while (p) {
      if (p->val == val) return p;
      else if (p->val < val) p = p->right;
      else p = p->left;
    }
    return nullptr;
  }
};
```

### 98. 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/description/)

**_python_**

```python
class Solution:
    def __init__(self):
        self.pre = None

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        if not self.isValidBST(root.left):
            return False

        # 每一个节点，都问一下它的上一个节点是否比他小
        if self.pre and self.pre.val >= root.val:
            return False
        self.pre = root

        return self.isValidBST(root.right)
```

**_cpp_**

```cpp
class Solution {
public:
  TreeNode *pre = nullptr;
  bool isValidBST(TreeNode *root) {
    if (!root) return true;

    bool left = isValidBST(root->left);
    // 每一个节点，都问一下它的上一个节点是否比它小
    if (pre && pre->val >= root->val) return false;
    pre = root;
    // cout << pre->val << " "; 调试代码

    bool right = isValidBST(root->right);
    return left && right;
  }
};
```

### 530. 二叉搜索树的最小绝对差

[530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/description/)

**_python_**

```python
class Solution:
    def __init__(self):
        self.pre = None
        self.res = float('inf')

    def dfs(self, root: TreeNode):
        if not root:
            return
        self.dfs(root.left)
        if self.pre is not None:
            self.res = min(self.res, root.val - self.pre.val)
        self.pre = root
        self.dfs(root.right)

    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        self.dfs(root)
        return self.res
```

**_cpp_**

```cpp
class Solution {
private:
    TreeNode *pre = nullptr;
    int res = 100000;
    void dfs(TreeNode *root){
        if (!root) return;
        dfs(root->left);
        if (pre) res = min(res, root->val - pre->val);
        pre = root;
        dfs(root->right);
    }


public:
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

### 501.二叉搜索树中的众数

[501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/description/)

**_python_**

```python
class Solution:
    def __init__(self):
        self.res = []
        self.fre = 0
        self.max_fre = 0
        self.pre = None

    def dfs(self, root):
        if not root:
            return

        self.dfs(root.left)  # 左

        if not self.pre or self.pre.val == root.val:
            self.fre += 1
        else:
            if self.fre == self.max_fre:
                self.res.append(self.pre.val)
            elif self.fre > self.max_fre:
                self.res.clear()
                self.res.append(self.pre.val)
                self.max_fre = self.fre
            self.fre = 1

        self.pre = root
        self.dfs(root.right)  # 右

    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        self.dfs(root)
        if self.fre == self.max_fre:
            self.res.append(self.pre.val)
        elif self.fre > self.max_fre:
            self.res.clear()
            self.res.append(self.pre.val)
        return self.res
```

**_cpp_**

```cpp
class Solution {
private:
  vector<int> res;
  int cur_fre = 0, max_fre = 0;
  TreeNode *pre = nullptr;
  void dfs(TreeNode *root) {
    if (!root) return;
    dfs(root->left);

    if (pre && pre->val == root->val) ++cur_fre;
    else cur_fre = 1;
    if (cur_fre >= max_fre) {
      if (cur_fre > max_fre) {
        res.clear();
        max_fre = cur_fre;
      }
      res.emplace_back(root->val);
    }

    pre = root;
    dfs(root->right);
  }

public:
  vector<int> findMode(TreeNode *root) {
    dfs(root);
    return res;
  }
};
```

### 236. 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

**_python_**

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root is None or root == p or root == q:
            return root

        left = self.lowestCommonAncestor(root.left, p, q)  # 左
        right = self.lowestCommonAncestor(root.right, p, q)  # 右

        if left and right:
            return root
        elif left:
            return left
        else:
            return right
```

**_cpp_**

```cpp
class Solution {
public:
  TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
    if (!root || root == p || root == q) return root;
    TreeNode *left = lowestCommonAncestor(root->left, p, q);
    TreeNode *right = lowestCommonAncestor(root->right, p, q);
    if (left && right) return root;
    else if (left) return left;
    else return right;
  }
};
```

### 235. 二叉搜索树的最近公共祖先

[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

**_python_**

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            if p.val < root.val and q.val < root.val:  # 在左侧
                root = root.left
            elif p.val > root.val and q.val > root.val:  # 在右侧
                root = root.right
            else:
                return root
        return None
```

**_cpp_**

```cpp
class Solution {
public:
  TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
    while (root) {
      if (p->val < root->val && q->val < root->val) root = root->left;
      else if (p->val > root->val && q->val > root->val) root = root->right;
      else return root;
    }
    return nullptr;
  }
};
```

### 701. 二叉搜索树中的插入操作

[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/description/)

**_python_**

```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)

        cur = root
        while cur:
            if val < cur.val:
                if not cur.left:
                    cur.left = TreeNode(val)
                    break
                else:
                    cur = cur.left
            else:
                if not cur.right:
                    cur.right = TreeNode(val)
                    break
                else:
                    cur = cur.right
        return root
```

**_cpp_**

```cpp
class Solution {
public:
  TreeNode *insertIntoBST(TreeNode *root, int val) {
    if (!root) return new TreeNode(val);

    TreeNode *cur = root, *pre = nullptr;
    while (cur) {
      pre = cur;
      cur = val < cur->val ? cur->left : cur->right;
    }
    val < pre->val ? pre->left = new TreeNode(val)
                   : pre->right = new TreeNode(val);
    return root;
  }
};
```

### 450. 删除二叉搜索树中的节点

[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/description/)

**_python_**

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None

        if root.val == key:
            if root.left and root.right:
                p = root.right
                while p.left:
                    p = p.left
                p.left = root.left
                return root.right
            elif root.left:
                return root.left
            else:
                return root.right

        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        if root.val < key:
            root.right = self.deleteNode(root.right, key)
        return root
```

**_cpp_**

```cpp
class Solution {
public:
  TreeNode *deleteNode(TreeNode *root, int key) {
    if (!root) return nullptr;
    if (root->val == key) {
      if (root->right) {
        TreeNode *p = root->right;
        while (p->left) p = p->left;
        p->left = root->left;
        return root->right;
      }
      else return root->left;
    }
    if (root->val > key) root->left = deleteNode(root->left, key);
    if (root->val < key) root->right = deleteNode(root->right, key);
    return root;
  }
};
```

### 669. 修剪二叉搜索树

[669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/)

**_python_**

```python
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if not root:
            return None
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        if root.val < low:
            return root.right
        if root.val > high:
            return root.left
        return root
```

**_cpp_**

```cpp
class Solution {
public:
  TreeNode *trimBST(TreeNode *root, int low, int high) {
    if (!root) return nullptr;
    root->left = trimBST(root->left, low, high);
    root->right = trimBST(root->right, low, high);
    if (root->val < low) return root->right;
    if (root->val > high) return root->left;
    return root;
  }
};
```

### 108.将有序数组转换为二叉搜索树

[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/)

**_python_**

```python
class Solution:
    def build(self, nums, l, r):
        if l > r:
            return None
        mid = (l + r) // 2
        root = TreeNode(nums[mid])
        root.left = self.build(nums, l, mid - 1)
        root.right = self.build(nums, mid + 1, r)
        return root

    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        return self.build(nums, 0, len(nums) - 1)
```

**_cpp_**

```cpp
class Solution {
private:
  TreeNode *build(const vector<int> &nums, int l, int r) {
    if (l > r) return nullptr;
    int mid = l + (r - l) / 2;
    TreeNode *root = new TreeNode(nums[mid]);
    root->left = build(nums, l, mid - 1);
    root->right = build(nums, mid + 1, r);
    return root;
  }

public:
  TreeNode *sortedArrayToBST(vector<int> &nums) {
    return build(nums, 0, nums.size() - 1);
  }
};
```

### 538.把二叉搜索树转换为累加树

[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/description/)

**_python_**

```python
class Solution:
    def __init__(self):
        self.pre = None

    def dfs(self, root):
        if not root:
            return
        self.dfs(root.right)

        if self.pre:
            root.val += self.pre.val
        self.pre = root

        self.dfs(root.left)

    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.dfs(root)
        return root
```

**_cpp_**

```cpp
class Solution {
private:
  TreeNode *pre = nullptr;
  void dfs(TreeNode *root) {
    if (!root) return;
    dfs(root->right);

    if (pre) root->val += pre->val;
    pre = root;

    dfs(root->left);
  }

public:
  TreeNode *convertBST(TreeNode *root) {
    dfs(root);
    return root;
  }
};
```

## 8 回溯算法

### 77. 组合

[77. 组合](https://leetcode-cn.com/problems/combinations/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, n, k, start):
        if len(self.path) == k:
            self.res.append(self.path[:])
            return
        for i in range(start, n - (k - len(self.path)) + 2):
            self.path.append(i)
            self.backtracking(n, k, i + 1)
            self.path.pop()

    def combine(self, n: int, k: int) -> List[List[int]]:
        self.backtracking(n, k, 1)
        return self.res
```

```cpp
class Solution {
private:
  vector<int> path;
  vector<vector<int>> res;
  void bracktracking(const int &n, const int &k, const int startIndex) {
    if (path.size() == k) {
      res.emplace_back(path);
      return;
    }
    for (int i = startIndex; i <= n - (k - path.size()) + 1; ++i) {
      path.emplace_back(i);
      bracktracking(n, k, i + 1);
      path.pop_back();
    }
  }

public:
  vector<vector<int>> combine(int n, int k) {
    bracktracking(n, k, 1);
    return res;
  }
};
```

### 216. 组合总和 III

[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, k, n, start):
        if n == 0 and len(self.path) == k:
            self.res.append(self.path[:])
            return
        for i in range(start, 10):
            if n - i < 0 or 10 - i < k - len(self.path):
                return
            self.path.append(i)
            self.backtracking(k, n - i, i + 1)
            self.path.pop()

    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        self.backtracking(k, n, 1)
        return self.res
```

```cpp
class Solution {
private:
  vector<int> path;
  vector<vector<int>> res;
  void backtracking(const int &k, int n, const int startIndex) {
    if (path.size() == k) {
      if (n == 0) res.emplace_back(path);
      return;
    }
    for (int i = startIndex; i <= 9; ++i) {
      if (n < i || 10 - i < k - path.size()) return;
      path.emplace_back(i);
      backtracking(k, n - i, i + 1);
      path.pop_back();
    }
  }

public:
  vector<vector<int>> combinationSum3(int k, int n) {
    backtracking(k, n, 1);
    return res;
  }
};
```

### 17. 电话号码的字母组合

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/)

```python
class Solution:
    def __init__(self):
        self.letterMap = [
            "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
        ]
        self.path = []
        self.res = []

    def backtracking(self, digits, start):
        if len(self.path) == len(digits):
            self.res.append("".join(self.path))
            return
        for i in range(start, len(digits)):
            for c in self.letterMap[int(digits[i])]:
                self.path.append(c)
                self.backtracking(digits, i + 1)
                self.path.pop()

    def letterCombinations(self, digits: str) -> List[str]:
        if digits:
            self.backtracking(digits, 0)
        return self.res
```

```cpp
class Solution {
private:
  const string letterMap[10] = {"",    "",    "abc",  "def", "ghi",
                                "jkl", "mno", "pqrs", "tuv", "wxyz"};

  string path;
  vector<string> res;
  void backtracking(const string &digits, int startIndex = 0) {
    if (path.size() == digits.size()) {
      res.emplace_back(path);
      return;
    }
    for (int i = startIndex; i < digits.size(); ++i)
      for (const char &c : letterMap[digits[i] - '0']) {
        path.push_back(c);
        backtracking(digits, i + 1);
        path.pop_back();
      }
  }

public:
  vector<string> letterCombinations(string digits) {
    if(!digits.empty()) backtracking(digits);
    return res;
  }
};
```

### 39. 组合总和

[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, candidates, target, start):
        if target == 0:
            self.res.append(list(self.path))
            return
        for i in range(start, len(candidates)):
            if target < candidates[i]:
                continue
            self.path.append(candidates[i])
            self.backtracking(candidates, target - candidates[i], i)
            self.path.pop()

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self.res = []
        self.path = []
        self.backtracking(candidates, target, 0)
        return self.res
```

```cpp
class Solution {
private:
  vector<int> path;
  vector<vector<int>> res;
  void backtracking(vector<int> &candidates, int target, const int startIndex) {
    if (!target) {
      res.emplace_back(path);
      return;
    }
    for (int i = startIndex; i < candidates.size(); ++i) {
      if (target < candidates[i]) continue;
      path.emplace_back(candidates[i]);
      backtracking(candidates, target - candidates[i], i);
      path.pop_back();
    }
  }

public:
  vector<vector<int>> combinationSum(vector<int> &candidates, int target) {
    backtracking(candidates, target, 0);
    return res;
  }
};
```

### 40. 组合总和 II

[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/description/)

```python
# used 数组去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, candidates, target, used, start):
        if target == 0:
            self.res.append(list(self.path))
            return
        for i in range(start, len(candidates)):
            if candidates[i] > target:
                break
            if i > start and candidates[i] == candidates[i - 1] and not used[i - 1]:
                continue
            self.path.append(candidates[i])
            used[i] = True
            self.backtracking(candidates, target - candidates[i], used, i + 1)
            used[i] = False
            self.path.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        used = [False] * len(candidates)
        self.res = []
        self.path = []
        self.backtracking(candidates, target, used, 0)
        return self.res


# set 去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, candidates, target, start):
        if target == 0:
            self.res.append(list(self.path))
            return
        uset = [False] * 51
        for i in range(start, len(candidates)):
            if candidates[i] > target:
                break
            if uset[candidates[i]]:
                continue
            else:
                uset[candidates[i]] = True
                self.path.append(candidates[i])
                self.backtracking(candidates, target - candidates[i], i + 1)
                self.path.pop()

    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        self.res = []
        self.path = []
        self.backtracking(candidates, target, 0)
        return self.res
```

```cpp
// used 数组去重
class Solution {
  vector<int> path;
  vector<vector<int>> res;
  void backtracking(const vector<int> &candidates, int target,
                    const int startIndex, vector<bool> &used) {
    if (target == 0) {
      res.emplace_back(path);
      return;
    }
    for (int i = startIndex; i < candidates.size() && candidates[i] <= target;
         ++i) {
      if (i && candidates[i] == candidates[i - 1] && !used[i - 1]) continue;
      path.emplace_back(candidates[i]);
      used[i] = true;
      backtracking(candidates, target - candidates[i], i + 1, used);
      used[i] = false;
      path.pop_back();
    }
  }

public:
  vector<vector<int>> combinationSum2(vector<int> &candidates, int target) {
    sort(candidates.begin(), candidates.end());
    vector<bool> used(candidates.size(), false);
    backtracking(candidates, target, 0, used);
    return res;
  }
};

// set 去重
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;

    void backtracking(vector<int>& candidates, int target, int start) {
        if (!target) {
            res.push_back(path);
            return;
        }
        bool uset[51] = {false};
        for (int i = start; i < candidates.size() && candidates[i] <= target;
             ++i) {
            if (uset[candidates[i]]) continue;
            else {
                uset[candidates[i]] = true;
                path.push_back(candidates[i]);
                backtracking(candidates, target - candidates[i], i + 1);
                path.pop_back();
            }
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0);
        return res;
    }
};
```

### 131. 分割回文串

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def isPalindrome(self, s, left, right):
        while left < right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True

    def backtracking(self, s, startIndex):
        if startIndex == len(s):
            self.res.append(list(self.path))
            return
        for i in range(startIndex, len(s)):
            if self.isPalindrome(s, startIndex, i):
                self.path.append(s[startIndex:i+1])
                self.backtracking(s, i + 1)
                self.path.pop()

    def partition(self, s: str) -> List[List[str]]:
        self.res = []
        self.path = []
        self.backtracking(s, 0)
        return self.res
```

```cpp
class Solution {
private:
  vector<string> path;
  vector<vector<string>> res;
  bool isPalinrome(const string &s, int left, int right) {
    while (left < right)
      if (s[left++] != s[right--])
        return false;
    return true;
  }
  void backtracking(const string &s, int startIndex) {
    if (startIndex == s.size()) {
      res.emplace_back(path);
      return;
    }
    for (int i = startIndex; i < s.size(); ++i) {
      if (isPalinrome(s, startIndex, i)) {
        path.emplace_back(s.substr(startIndex, i - startIndex + 1));
        backtracking(s, i + 1);
        path.pop_back();
      }
    }
  }

public:
  vector<vector<string>> partition(string s) {
    backtracking(s, 0);
    return res;
  }
};
```

### 93. 复原 IP 地址

[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/description/)

```python
class Solution:
    def __init__(self):
        self.res = []

    def isValid(self, s, left, right):
        if left == right:
            return True
        elif s[left] == '0':
            return False
        num = 0
        while left <= right:
            num = num * 10 + (ord(s[left]) - ord('0'))
            left += 1
        return num >= 1 and num <= 255

    def backtracking(self, s, path, startIndex, layer):
        if layer == 4:
            if startIndex == len(s):
                self.res.append(path[:-1])
            return
        for i in range(startIndex, len(s)):
            if i - startIndex < 3 and len(s) - startIndex <= (4 - layer) * 3 and self.isValid(s, startIndex, i):
                self.backtracking(s, path + s[startIndex:i+1] + ".", i + 1, layer + 1)

    def restoreIpAddresses(self, s: str) -> List[str]:
        self.res = []
        self.backtracking(s, "", 0, 0)
        return self.res
```

```cpp
class Solution {
private:
  vector<string> res;
  bool isValid(const string &s, int left, int right) {
    if (left == right)
      return true;
    else if (s[left] == '0')
      return false;
    int num = stoi(s.substr(left, right - left + 1));
    return num >= 1 && num <= 255;
  }

  void backtracking(const string &s, string path, int startIndex, int layer) {
    if (4 == layer) {
      if (startIndex == s.size()) {
        res.emplace_back(path);
        res.back().resize(path.size() - 1);
      }
      return;
    }
    for (int i = startIndex; i < s.size(); ++i)
      if (i - startIndex < 3 && s.size() - i <= (4 - layer) * 3 &&
          isValid(s, startIndex, i))    // 保证 ip 位数合法，且剩余位数不要太多
        backtracking(s, path + s.substr(startIndex, i - startIndex + 1) + ".",
                     i + 1, layer + 1);
  }

public:
  vector<string> restoreIpAddresses(string s) {
    backtracking(s, "", 0, 0);
    return res;
  }
};
```

### 78. 子集

[78. 子集](https://leetcode-cn.com/problems/subsets/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, startIndex):
        self.res.append(list(self.path))
        for i in range(startIndex, len(nums)):
            self.path.append(nums[i])
            self.backtracking(nums, i + 1)
            self.path.pop()

    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        self.path = []
        self.backtracking(nums, 0)
        return self.res
```

```cpp
class Solution {
private:
  vector<int> path;
  vector<vector<int>> res;
  void backtracking(const vector<int> &nums, int startIndex) {
    res.emplace_back(path);
    for (int i = startIndex; i < nums.size(); ++i) {
      path.emplace_back(nums[i]);
      backtracking(nums, i + 1);
      path.pop_back();
    }
  }

public:
  vector<vector<int>> subsets(vector<int> &nums) {
    backtracking(nums, 0);
    return res;
  }
};
```

### 90. 子集 II

[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/description/)

```python
# used 数组去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, used, startIndex):
        self.res.append(list(self.path))
        for i in range(startIndex, len(nums)):
            if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                continue
            self.path.append(nums[i])
            used[i] = True
            self.backtracking(nums, used, i + 1)
            used[i] = False
            self.path.pop()

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        used = [False] * len(nums)
        self.res = []
        self.path = []
        self.backtracking(nums, used, 0)
        return self.res


# set 去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, startIndex):
        self.res.append(list(self.path))
        used = [False] * 21  # Python doesn't have fixed-size arrays, so we use a list
        for i in range(startIndex, len(nums)):
            if not used[nums[i] + 10]:
                used[nums[i] + 10] = True
                self.path.append(nums[i])
                self.backtracking(nums, i + 1)
                self.path.pop()

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        self.res = []
        self.path = []
        self.backtracking(nums, 0)
        return self.res
```

```cpp
// used 数组去重
class Solution {
private:
  vector<int> path;
  vector<vector<int>> res;
  void backtracking(const vector<int> &nums, vector<bool> &used,
                    int startIndex) {
    res.emplace_back(path);
    for (int i = startIndex; i < nums.size(); ++i) {
      if (i && nums[i] == nums[i - 1] && !used[i - 1]) continue;
      path.emplace_back(nums[i]);
      used[i] = true;
      backtracking(nums, used, i + 1);
      used[i] = false;
      path.pop_back();
    }
  }

public:
  vector<vector<int>> subsetsWithDup(vector<int> &nums) {
    sort(nums.begin(), nums.end());
    vector<bool> uesd(nums.size(), false);
    backtracking(nums, uesd, 0);
    return res;
  }
};

// set 去重
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& nums, int startIndex) {
        res.push_back(path);
        bool arr[21] = {false};
        for (int i = startIndex; i < nums.size(); ++i) {
            if (!arr[nums[i] + 10]) {
                arr[nums[i] + 10] = true;
                path.push_back(nums[i]);
                backtracking(nums, i + 1);
                path.pop_back();
            }
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        backtracking(nums, 0);
        return res;
    }
};
```

### 491. 非递减子序列

[491. 非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

```python
# 没有说有序，使用 set 去重
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, startIndex):
        if len(self.path) > 1:
            self.res.append(list(self.path))

        uset = set()
        for i in range(startIndex, len(nums)):
            if nums[i] in uset:
                continue
            if not self.path or nums[i] >= self.path[-1]:
                self.path.append(nums[i])
                uset.add(nums[i])
                self.backtracking(nums, i + 1)
                self.path.pop()

    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        self.path = []
        self.backtracking(nums, 0)
        return self.res
```

```cpp
// 没有说有序，使用 set 去重
class Solution {
  vector<int> path;
  vector<vector<int>> res;
  void backtracking(const vector<int> &nums, int startIndex) {
    if (path.size() > 1) res.emplace_back(path);

    unordered_set<int> uset;
    for (int i = startIndex; i < nums.size(); ++i) {
      if (uset.find(nums[i]) != uset.end()) continue;
      if (path.empty() || nums[i] >= path.back()) {
        path.emplace_back(nums[i]);
        uset.insert(nums[i]);
        backtracking(nums, i + 1);
        path.pop_back();
      }
    }
  }

public:
  vector<vector<int>> findSubsequences(vector<int> &nums) {
    backtracking(nums, 0);
    return res;
  }
};
```

### 46. 全排列

[46. 全排列](https://leetcode-cn.com/problems/permutations/description/)

```python
class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, used):
        if len(self.path) == len(nums):
            self.res.append(list(self.path))
            return
        for i in range(len(nums)):
            if not used[i]:
                self.path.append(nums[i])
                used[i] = True
                self.backtracking(nums, used)
                self.path.pop()
                used[i] = False

    def permute(self, nums: List[int]) -> List[List[int]]:
        used = [False] * len(nums)
        self.res = []
        self.path = []
        self.backtracking(nums, used)
        return self.res
```

```cpp
class Solution {
  vector<int> path;
  vector<vector<int>> res;
  void backtracking(const vector<int> &nums, vector<bool> &used) {
    if (path.size() == nums.size()) {
      res.emplace_back(path);
      return;
    }
    for (int i = 0; i < nums.size(); ++i) {
      if (used[i]) continue;
      path.emplace_back(nums[i]);
      used[i] = true;
      backtracking(nums, used);
      used[i] = false;
      path.pop_back();
    }
  }

public:
  vector<vector<int>> permute(vector<int> &nums) {
    vector<bool> used(nums.size(), false);
    backtracking(nums, used);
    return res;
  }
};
```

### 47. 全排列 II

[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/description/)

```python
# 也可以使用 set 控制节点内去重， used 控制路径去重

class Solution:
    def __init__(self):
        self.path = []
        self.res = []

    def backtracking(self, nums, used):
        if len(self.path) == len(nums):
            self.res.append(list(self.path))
            return
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                continue
            if not used[i]:
                used[i] = True
                self.path.append(nums[i])
                self.backtracking(nums, used)
                self.path.pop()
                used[i] = False

    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        used = [False] * len(nums)
        self.res = []
        self.path = []
        self.backtracking(nums, used)
        return self.res
```

```cpp
// 也可以使用 set 控制节点内去重， used 控制路径去重

class Solution {
private:
  vector<int> path;
  vector<vector<int>> res;
  void backtracking(const vector<int> &nums, vector<bool> &used) {
    if (path.size() == nums.size()) {
      res.emplace_back(path);
      return;
    }
    for (int i = 0; i < nums.size(); ++i) {
      if (i && nums[i] == nums[i - 1] && !used[i - 1]) continue;
      if (!used[i]) {
        used[i] = true;
        path.emplace_back(nums[i]);
        backtracking(nums, used);
        path.pop_back();
        used[i] = false;
      }
    }
  }

public:
  vector<vector<int>> permuteUnique(vector<int> &nums) {
    sort(nums.begin(), nums.end());
    vector<bool> used(nums.size(), false);
    backtracking(nums, used);
    return res;
  }
};
```

### 332. 重新安排行程

[332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/description/)

```python
class Solution:
    def __init__(self):
        self.graph = defaultdict(lambda: defaultdict(int))
        self.res = []

    def backtracking(self, num):
        if len(self.res) == num:
            return True
        for to, count in sorted(self.graph[self.res[-1]].items()):
            if count > 0:
                self.res.append(to)
                self.graph[self.res[-2]][to] -= 1
                if self.backtracking(num):
                    return True
                self.res.pop()
                self.graph[self.res[-1]][to] += 1
        return False

    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        for ticket in tickets:
            self.graph[ticket[0]][ticket[1]] += 1
        self.res.append("JFK")
        self.backtracking(len(tickets) + 1)
        return self.res
```

```cpp
class Solution {
  unordered_map<string, map<string, int>> graph; // [from, [to, 次数]]
  vector<string> res;

private:
  void backtracking(const int &num) {
    if (res.size() == num) return;
    for (auto &[to, count] : graph[res.back()]) {
      if (count) {
        res.emplace_back(to);
        --count;
        backtracking(num);
        // 防止 res.size() == num 时回溯，导致结果被 pop_back
        if (res.size() == num) return;
        ++count;
        res.pop_back();
      }
    }
  }

public:
  vector<string> findItinerary(vector<vector<string>> &tickets) {
    for (auto &ticket : tickets)
      ++graph[ticket[0]][ticket[1]];
    res.emplace_back("JFK");
    backtracking(tickets.size() + 1);
    return res;
  }
};
```

### 51. N 皇后

[51. N 皇后](https://leetcode-cn.com/problems/n-queens/description/)

```python
class Solution:
    def __init__(self):
        self.res = []

    def isValid(self, row, col, chessboard):
        # Check the column for a queen
        for i in range(row):
            if chessboard[i][col] == 'Q':
                return False

        # Check the 45 degree diagonal
        i, j = row - 1, col + 1
        while i >= 0 and j < len(chessboard):
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j += 1

        # Check the 135 degree diagonal
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if chessboard[i][j] == 'Q':
                return False
            i -= 1
            j -= 1

        return True

    def backtracking(self, row, chessboard):
        if row == len(chessboard):
            self.res.append([''.join(row) for row in chessboard])
            return

        for col in range(len(chessboard)):
            if self.isValid(row, col, chessboard):
                chessboard[row][col] = 'Q'
                self.backtracking(row + 1, chessboard)
                chessboard[row][col] = '.'

    def solveNQueens(self, n: int) -> List[List[str]]:
        chessboard = [['.' for _ in range(n)] for _ in range(n)]
        self.backtracking(0, chessboard)
        return self.res
```

```cpp
class Solution {
private:
  vector<vector<string>> res;

  bool isValid(const vector<string> &chessboard, int row, int col) {
    for (int i = 0; i < row; ++i)
      if (chessboard[i][col] == 'Q') return false;

    for (int i = row - 1, j = col + 1; i >= 0 && j < chessboard.size();
         --i, ++j)
      if (chessboard[i][j] == 'Q') return false;

    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)
      if (chessboard[i][j] == 'Q') return false;

    return true;
  }

  void backtracking(vector<string> &chessboard, int row) {
    if (row == chessboard.size()) {
      res.emplace_back(chessboard);
      return;
    }
    for (int col = 0; col < chessboard.size(); ++col) {
      if (isValid(chessboard, row, col)) {
        chessboard[row][col] = 'Q';
        backtracking(chessboard, row + 1);
        chessboard[row][col] = '.';
      }
    }
  }

public:
  vector<vector<string>> solveNQueens(int n) {
    vector<string> chessboard(n, string(n, '.'));
    backtracking(chessboard, 0);
    return res;
  }
};
```

### 37. 解数独

[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/description/)

```python
class Solution:
    def isValid(self, row, col, k, board):
        for j in range(9):
            if board[row][j] == k:
                return False

        for i in range(9):
            if board[i][col] == k:
                return False

        startrow, startcol = (row // 3) * 3, (col // 3) * 3
        for i in range(startrow, startrow + 3):
            for j in range(startcol, startcol + 3):
                if board[i][j] == k:
                    return False

        return True

    def backtracking(self, board, row, col):
        if row == 9:
            return True

        if col == 9:
            return self.backtracking(board, row + 1, 0)

        if board[row][col] != '.':
            return self.backtracking(board, row, col + 1)

        for k in '123456789':
            if self.isValid(row, col, k, board):
                board[row][col] = k
                if self.backtracking(board, row, col + 1):
                    return True
                board[row][col] = '.'

        return False

    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        self.backtracking(board, 0, 0)
```

```cpp
class Solution {
  bool isValid(const vector<vector<char>> &board, const int &row,
               const int &col, const char &k) {
    for (int j = 0; j < 9; ++j)
      if (board[row][j] == k) return false;

    for (int i = 0; i < 9; ++i)
      if (board[i][col] == k) return false;

    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; ++i)
      for (int j = startCol; j < startCol + 3; ++j)
        if (board[i][j] == k) return false;

    return true;
  }

  bool backtracking(vector<vector<char>> &board) {
    for (int i = 0; i < 9; ++i)
      for (int j = 0; j < 9; ++j)
        if (board[i][j] == '.') {
          for (char k = '1'; k <= '9'; ++k)
            if (isValid(board, i, j, k)) {
              board[i][j] = k;
              if (backtracking(board)) return true;
              board[i][j] = '.';
            }
          return false; // 1 - 9 都不合适，这条路失败了
        }
    return true;  // 所有位置都有 非 '.' 元素
  }

public:
  void solveSudoku(vector<vector<char>> &board) { backtracking(board); }
};
```

---

## 9 贪心算法

### 455. 分发饼干

[455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/description/)

```python

```

```cpp
class Solution {
public:
  int findContentChildren(vector<int> &g, vector<int> &s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int i = 0, j = 0;
    while (i < g.size() && j < s.size()) {
      if (s[j] > g[i]) ++i;
      ++j;
    }
    return i;
  }
};
```

### 376. 摆动序列

[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/description/)

```python

```

```cpp
class Solution {
public:
  int wiggleMaxLength(vector<int> &nums) {
    int des = 1, incre = 1;
    for (int i = 1; i < nums.size(); ++i)
      if (nums[i] - nums[i - 1] > 0) incre = des + 1;
      else if (nums[i] - nums[i - 1] < 0) des = incre + 1;

    return max(des, incre);
  }
};
```

### 53. 最大子序和

[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/description/)

```python

```

```cpp
// 贪心算法
class Solution {
public:
  int maxSubArray(vector<int> &nums) {
    int res = nums[0], sum = 0;
    for (int i = 0; i< nums.size() ; ++i) {
      sum += nums[i];
      res = max(res, sum);
      if (sum < 0) sum = 0;
    }
    return res;
  }
};

// 动态规划
class Solution {
public:
  int maxSubArray(vector<int> &nums) {
    vector<int> dp(nums.size(), 0); // 以 nums[i] 结尾的最大子序和
    dp[0] = nums[0];
    int res = nums[0];
    for (int i = 1; i < nums.size(); i++) {
      dp[i] = dp[i - 1] > 0 ? dp[i - 1] + nums[i] : nums[i];
      res = max(dp[i], res);
    }
    return res;
  }
};
```

### 122. 买卖股票的最佳时机 II

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

```python

```

```cpp
// 贪心
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    int res = 0;
    for (int i = 1; i < prices.size(); ++i)
      res += max(prices[i] - prices[i - 1], 0);
    return res;
  }
};

// 动态规划（非滑动数组）
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    vector<pair<int, int>> dp(prices.size());
    dp[0] = {-prices[0], 0}; // 初始化第 0 天持股和不持股的最大收益
    for (int i = 1; i < prices.size(); ++i) {
      dp[i].first = max(dp[i - 1].first,
                        dp[i - 1].second - prices[i]); // 第 i 天持股的最大收益
      dp[i].second =
          max(dp[i - 1].second,
              dp[i - 1].first + prices[i]); // 第 i 天不持股的最大收益
    }
    return dp.back().second;
  }
};

// 动态规划（滑动数组）
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    pair<int, int> dp = {-prices[0], 0}; // 初始化第 0 天持股和不持股的最大收益
    // 逻辑巧妙，利用了可以当天买入当天卖出，所以才不需要利用临时变量保存 dp.first
    for (int i = 1; i < prices.size(); ++i) {
      dp.first = max(dp.first,
                     dp.second - prices[i]); // 第 i 天持股的最大收益
      dp.second = max(dp.second,
                      dp.first + prices[i]); // 第 i 天不持股的最大收益
    }
    return dp.second;
  }
};
```

### 55. 跳跃游戏

[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/description/)

```python

```

```cpp
class Solution {
public:
  bool canJump(vector<int> &nums) {
    int right = 0;
    if (nums.size() == 1) return true;
    for (int i = 0; i <= right; ++i) {
      right = max(right, i + nums[i]);
      if (right >= nums.size() - 1) return true;
    }
    return false;
  }
};
```

### 45. 跳跃游戏 II

[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/description/)

```python

```

```cpp
class Solution {
public:
  int jump(vector<int> &nums) {
    if (nums.size() == 1) return 0;
    int left = 0, right = 0;
    int res = 0;
    int nextRight = 0;
    while (left <= nextRight) {
      nextRight = max(left + nums[left], nextRight);
      ++left;
      if (left > right) {
        right = nextRight;
        res++;
      }
      if (right >= nums.size() - 1) return res;
    }
    return res;
  }
};
```

### 1005. K 次取反后最大化的数组和

[1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/description/)

```python

```

```cpp
class Solution {
public:
  int largestSumAfterKNegations(vector<int> &nums, int k) {
    sort(nums.begin(), nums.end(), [](const int &lhs, const int &rhs) {
      return abs(lhs) > abs(rhs);
    }); // 按照绝对值从大到小排序
    for_each(nums.begin(), nums.end(), [&](int &num) {
      if (num < 0 && k > 0) {
        num *= -1;
        --k;
      }
    });
    if (k % 2) nums.back() *= -1;
    return accumulate(nums.begin(), nums.end(), 0);
  }
};
```

### 134. 加油站

[134. 加油站](https://leetcode-cn.com/problems/gas-station/description/)

```python

```

```cpp
class Solution {
public:
  int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
    int curSum = 0, totalSum = 0;
    int startIndex = 0;
    for (int i = 0; i < gas.size(); ++i) {
      curSum += gas[i] - cost[i];
      totalSum += gas[i] - cost[i];
      if (curSum < 0) {
        curSum = 0;
        startIndex = i + 1;
      }
    }
    return totalSum < 0 ? -1 : startIndex;
  }
};
```

### 135. 分发糖果

[135. 分发糖果](https://leetcode-cn.com/problems/candy/description/)

```python

```

```cpp
class Solution {
public:
  int candy(vector<int> &ratings) {
    vector<int> vec(ratings.size(), 1);
    for (int i = 1; i < ratings.size(); ++i)    // 从左往右
      if (ratings[i] > ratings[i - 1])
        vec[i] = vec[i - 1] + 1;
    for (int i = ratings.size() - 2; i >= 0; --i)   // 从右往左
      if (ratings[i] > ratings[i + 1] && vec[i] <= vec[i + 1])
        vec[i] = vec[i + 1] + 1;
    return accumulate(vec.begin(), vec.end(), 0);
  }
};
```

### 860. 柠檬水找零

[860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/description/)

```python

```

```cpp
class Solution {
public:
  bool lemonadeChange(vector<int> &bills) {
    int arr[3] = {0}; // 5, 10, 20
    for (int i = 0; i < bills.size(); ++i) {
      switch (bills[i]) {
      case 5:
        ++arr[0];
        break;
      case 10:
        --arr[0];
        ++arr[1];
        break;
      case 20:
        if (arr[1]){
          --arr[1];
          --arr[0];
        }else arr[0] -= 3;
        break;
      default:
        break;
      }

      if (arr[0] < 0 || arr[1] < 0) return false;
    }
    return true;
  }
};
```

### 406. 根据身高重建队列

[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/)

```python

```

```cpp
class Solution {
public:
  vector<vector<int>> reconstructQueue(vector<vector<int>> &people) {
    sort(people.begin(), people.end(),
         [](const vector<int> &lhs, const vector<int> &rhs) {
           return lhs[0] == rhs[0] ? lhs[1] < rhs[1] : lhs[0] > rhs[0];
         });// 身高从大到小，次之 k 小优先
    list<vector<int>> que;
    for (int i = 0; i < people.size(); ++i) {
      int position = people[i][1];
      auto it = que.begin();
      while (position--) it++;
      que.insert(it, people[i]);
    }
    return vector<vector<int>>(que.begin(), que.end());
  }
};
```

### 452. 用最少数量的箭引爆气球

[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)

```python

```

```cpp
// 本质上还是区间合并
class Solution {
public:
  int findMinArrowShots(vector<vector<int>> &points) {
    sort(points.begin(), points.end(),
         [](const vector<int> &lhs, const vector<int> &rhs) {
           return lhs[0] == rhs[0] ? lhs[1] < rhs[1] : lhs[0] < rhs[0];
         });
    int res = 1;
    for (int i = 1; i < points.size(); ++i)
      if (points[i][0] > points[i - 1][1])
        ++res;
      else if (points[i][1] > points[i - 1][1])
        points[i][1] = points[i - 1][1];
    return res;
  }
};
```

### 435. 无重叠区间

[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/description/)

```python

```

```cpp
class Solution {
public:
  int eraseOverlapIntervals(vector<vector<int>> &intervals) {
    sort(intervals.begin(), intervals.end(),
         [](const vector<int> &lhs, const vector<int> &rhs) {
           return lhs[0] == rhs[0] ? lhs[1] < rhs[1] : lhs[0] < rhs[0];
         });
    int res = 0;
    for (int i = 1; i < intervals.size(); ++i)
      if (intervals[i][0] < intervals[i - 1][1]) {
        ++res;
        // intervals[i][1] = min(intervals[i][1], intervals[i - 1][1]);
        if (intervals[i][1] > intervals[i - 1][1])
          intervals[i][1] = intervals[i - 1][1];
      }
    // else
    //   intervals[i][1] = max(intervals[i][1], intervals[i-1][1]);
    return res;
  }
};
```

### 763. 划分字母区间

[763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/description/)

```python

```

```cpp
// 转换为 合并区间问题(笨)
class Solution {
public:
  vector<int> partitionLabels(string s) {
    vector<vector<int>> map(26, vector<int>(2, 520));
    for (int i = 0; i < s.size(); i++)
      if (map[s[i] - 'a'][0] != 520)
        map[s[i] - 'a'][1] = i;
      else
        map[s[i] - 'a'][0] = i;

    for (int i = 0; i < map.size(); i++)
      if (map[i][0] != 520 && map[i][1] == 520)
        map[i][1] = map[i][0];

    sort(map.begin(), map.end(),
         [](const vector<int> &lhs, const vector<int> &rhs) {
           return lhs[0] == rhs[0] ? lhs[1] < rhs[1] : lhs[0] < rhs[0];
         });

    vector<int> res;
    // 接下来就是重叠区间问题
    int count = 0;
    for (int i = 1; i < 26 && map[i][0] != 520; i++)
      if (map[i][0] < map[i - 1][1]) {
        map[i][1] = max(map[i - 1][1], map[i][1]);
        map[i][0] = min(map[i - 1][0], map[i][0]);
      } else {
        res.emplace_back(map[i - 1][1] - map[i - 1][0] + 1);
        count += res.back();
      }
    res.emplace_back(s.size() - count);
    return res;
  }
};


// 记录每个元素出现的最远位置
class Solution {
public:
  vector<int> partitionLabels(string s) {
    int map[26] = {0};
    for (int i = 0; i < s.size(); ++i)
      map[s[i] - 'a'] = i;

    int left = 0, right = 0;
    vector<int> res;
    for (int i = 0; i < s.size(); ++i) {
      right = max(right, map[s[i] - 'a']);
      if (i == right) {
        res.emplace_back(right - left + 1);
        left = right + 1;
      }
    }
    return res;
  }
};
```

### 56. 合并区间

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/description/)

```python

```

```cpp
class Solution {
public:
  vector<vector<int>> merge(vector<vector<int>> &intervals) {
    sort(intervals.begin(), intervals.end(),
         [](const vector<int> &lhs, const vector<int> &rhs) {
           return lhs[0] == rhs[0] ? lhs[1] < rhs[1] : lhs[0] < rhs[0];
         });
    vector<vector<int>> res;
    for (int i = 1; i < intervals.size(); ++i)
      if (intervals[i][0] <= intervals[i - 1][1]) {
        intervals[i][0] = intervals[i - 1][0];
        intervals[i][1] = max(intervals[i][1], intervals[i - 1][1]);
      } else
        res.emplace_back(intervals[i - 1]);
    res.emplace_back(intervals.back());
    return res;
  }
};
```

### 738. 单调递增的数字

[738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/description/)

```python

```

```cpp
class Solution {
public:
  int monotoneIncreasingDigits(int n) {
    string str = to_string(n);
    int startIndex = str.size();    // 记录 9 开始的位置
    for (int i = str.size() - 2; i >= 0; --i)
      if (str[i] > str[i + 1]) {
        startIndex = i + 1;
        --str[i];
      }
    for (int i = startIndex; i < str.size(); ++i)
      str[i] = '9';
    return stoi(str);
  }
};
```

### 968. 监控二叉树

[968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/description/)

```python

```

```cpp
class Solution {
private:
  // 0 代表 未监控， 1 代表 有监控但无摄像头，2 代表有摄像头
  int dfs(TreeNode *root, int &res) {
    if (!root) return 1;
    int left = dfs(root->left, res);
    int right = dfs(root->right, res);

    if (left == 1 && right == 1) return 0;
    else if (left == 0 || right == 0) { ++res; return 2;}
    else return 1;
  }

public:
  int minCameraCover(TreeNode *root) {
    int res = 0;
    return dfs(root, res) ? res : res + 1;
  }
};
```

---

## 10 动态规划

### 509. 斐波那契数

[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/description/)

```python

```

```cpp
// 动态规划，复用 dp
class Solution {
public:
  int fib(int n) {
    if (!n) return 0;

    vector<int> dp(2);
    dp[0] = 0;
    dp[1] = 1;
    int res;
    for (int i = 2; i <= n; i++) {
      res = dp[0] + dp[1];
      dp[0] = dp[1];
      dp[1] = res;
    }
    return dp[1];
  }
};

// 递归 + memo
class Solution {
private:
  int fibHelper(const int &n, vector<int> &memo) {
    if (memo[n] == -1)
      memo[n] = fibHelper(n - 1, memo) + fibHelper(n - 2, memo);
    return memo[n];
  }

public:
  int fib(int n) {
    vector<int> memo(31, -1);
    memo[0] = 0; memo[1] = 1;
    return fibHelper(n, memo);
  }
};
```

### 70. 爬楼梯

[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/description/)

```python

```

```cpp
// 原地 dp
class Solution {
public:
  int climbStairs(int n) {
    if (n <= 2) return n;
    vector<int> dp(2);
    dp[0] = 1; dp[1] = 2;

    for (int i = 3; i <= n; ++i) {
      int res = dp[0] + dp[1];
      dp[0] = dp[1];
      dp[1] = res;
    }
    return dp[1];
  }
};

// 递归 + memo
class Solution {
  int climbStairsHelper(const int &n, vector<int> &memo) {
    if (memo[n] == -1)
      memo[n] = climbStairsHelper(n - 1, memo) + climbStairsHelper(n - 2, memo);
    return memo[n];
  }

public:
  int climbStairs(int n) {
    vector<int> memo(46, -1);
    memo[1] = 1; memo[2] = 2;
    return n <= 2 ? n : climbStairsHelper(n, memo);
  }
};
```

### 746. 使用最小花费爬楼梯

[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/)

```python

```

```cpp
// 原地 dp
class Solution {
public:
  int minCostClimbingStairs(vector<int> &cost) {
    vector<int> dp(2, 0);
    for (int i = 2; i <= cost.size(); ++i) {
      int res = min(dp[0] + cost[i - 2], dp[1] + cost[i - 1]);
      dp[0] = dp[1]; dp[1] = res;
    }
    return dp[1];
  }
};
```

### 62. 不同路径

[62.不同路径](https://leetcode-cn.com/problems/unique-paths/description/)

```python

```

```cpp
// 组合数学
class Solution {
public:
  int uniquePaths(int m, int n) {
    if (m > n) swap(m, n);
    int count = m - 1;
    int t1 = n, t2 = 1;
    long long res = 1;
    while (count--)
      res = res * (t1++) / (t2++);
    return (int)res;
  }
};

// 动态规划（滚动数组）
class Solution {
public:
  int uniquePaths(int m, int n) {
    vector<int> dp(n, 1);
    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        dp[j] += dp[j - 1];
    return dp[n - 1];
  }
};
```

### 63. 不同路径 II

[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/description/)

```python

```

```cpp
class Solution {
public:
  int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid) {
    int m = obstacleGrid.size(), n = obstacleGrid[0].size();
    if (obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) return 0;

    vector<vector<int>> dp(m, vector<int>(n, 0));
    for (int i = 0; i < m && obstacleGrid[i][0] != 1; ++i)
      dp[i][0] = 1;
    for (int j = 0; j < n && obstacleGrid[0][j] != 1; ++j)
      dp[0][j] = 1;

    for (int i = 1; i < m; ++i)
      for (int j = 1; j < n; ++j)
        if (obstacleGrid[i][j] != 1)
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    return dp[m - 1][n - 1];
  }
};

// 滚动数组版本需要增添 if 来进行判断是否为障碍物
```

### 343. 整数拆分

[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/description/)

```python

```

```cpp
class Solution {
public:
  int integerBreak(int n) {
    vector<int> dp(n + 1, 1);
    for (int i = 2; i <= n; ++i)
      for (int j = 1; j <= i / 2; ++j)
        dp[i] = max(max(j * dp[i - j], j * (i - j)), dp[i]);
    return dp[n];
  }
};
```

### 96. 不同的二叉搜索树

[96.不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/description/)

```python

```

```cpp
class Solution {
public:
  int numTrees(int n) {
    vector<int> dp(n + 1, 0);
    dp[0] = 1;
    for (int i = 1; i <= n; ++i)
      for (int j = 0; j < i; ++j)
        dp[i] += dp[j] * dp[i - j - 1];
    return dp[n];
  }
};
```

### 0-1 背包理论基础

[46. 携带研究材料（第六期模拟笔试）](https://kamacoder.com/problempage.php?pid=1046)

```python

```

```cpp
// 滚动数组
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
  int KnapSack(const vector<int> &weights, const vector<int> &values,
               const int &W) {
    vector<int> dp(W + 1, 0);
    for (int i = 0; i < weights.size(); ++i)
      for (int j = W; j >= weights[i]; --j) // 从后往前
        dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);

    return dp[W];
  }
};

int main() {
  int M, N;
  cin >> M >> N;
  vector<int> weights(M);
  vector<int> values(M);

  for (int i = 0; i < M; ++i)
    cin >> weights[i];

  for (int i = 0; i < M; ++i)
    cin >> values[i];
  Solution sol;
  cout << sol.KnapSack(weights, values, N);
  return 0;
}
```

### 416. 分割等和子集

[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/description/)

```python

```

```cpp
class Solution {
public:
  bool canPartition(vector<int> &nums) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum % 2) return false;
    vector<int> dp(sum / 2 + 1, 0);
    for (int i = 0; i < nums.size(); ++i) {
      for (int j = sum / 2; j >= nums[i]; --j)
        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
      if (dp.back() == sum / 2) return true;
    }
    return false;
  }
};
```

### 1049. 最后一块石头的重量 II

[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/description/)

```python

```

```cpp
class Solution {
public:
  int lastStoneWeightII(vector<int> &stones) {
    int sum = accumulate(stones.begin(), stones.end(), 0);
    vector<int> dp(sum / 2 + 1, 0);
    for (int i = 0; i < stones.size(); ++i)
      for (int j = dp.size() - 1; j >= stones[i]; --j)
        dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
    return sum - 2 * dp.back();
  }
};
```

### 494. 目标和

[494. 目标和](https://leetcode-cn.com/problems/target-sum/description/)

```python

```

```cpp
// 回溯
class Solution {
private:
  int res = 0;
  void backtracking(const vector<int> &nums, int target, int startIndex) {
    if (target == 0) ++res;
    for (int i = startIndex; i < nums.size(); ++i)
      backtracking(nums, target - nums[i], i + 1);
  }

public:
  int findTargetSumWays(vector<int> &nums, int target) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if ((sum - target) % 2) return 0;
    if (sum < target) return 0;
    backtracking(nums, (sum - target) / 2, 0);
    return res;
  }
};

// 动态规划
class Solution {
public:
  int findTargetSumWays(vector<int> &nums, int target) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if ((sum - target) % 2) return 0;
    if (sum < target) return 0;

    vector<int> dp((sum - target) / 2 + 1, 0);
    dp[0] = 1;
    for (int i = 0; i < nums.size(); ++i)
      for (int j = dp.size() - 1; j >= nums[i]; --j)
        dp[j] += dp[j - nums[i]];   // 新物品 放或者不放 都算上
    return dp.back();
  }
};
```

### 474. 一和零

[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/description/)

```python

```

```cpp
// 矩阵(背包)复用 ：滚动矩阵
class Solution {
public:
  int findMaxForm(vector<string> &strs, int m, int n) {
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    for_each(strs.begin(), strs.end(), [&](const string &str) {
      int zeronum = 0, onenum = 0;
      for (const char &c : str) c == '0' ? ++zeronum : ++onenum;
      for (int i = m; i >= zeronum; --i)
        for (int j = n; j >= onenum; --j)
          dp[i][j] = max(dp[i][j], dp[i - zeronum][j - onenum] + 1);
    });
    return dp[m][n];
  }
};
```

### 完全背包理论基础

[52. 携带研究材料（第七期模拟笔试）](https://kamacoder.com/problempage.php?pid=1052)

```python

```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
  int N, V;
  cin >> N >> V;
  vector<int> weights(N);
  vector<int> values(N);
  for (int i = 0; i < N; ++i)
    cin >> weights[i] >> values[i];
  vector<int> dp(V + 1, 0);
  for (int i = 0; i < N; ++i)
    for (int j = weights[i]; j <= V; ++j)
      dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
  cout << dp[V];
  return 0;
}
```

### 518. 零钱兑换 II

[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/description/)

```python

```

```cpp
class Solution {
public:
  int change(int amount, vector<int> &coins) {
    vector<int> dp(amount + 1, 0);
    dp[0] = 1;
    for (int i = 0; i <= coins.size(); ++i)
      for (int j = coins[i]; j <= amount; ++j)
        dp[j] += dp[j - coins[i]];
    return dp[amount];
  }
};
```

### 377. 组合总和 Ⅳ

[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/description/)

```python

```

```cpp
// dp[i] 表示和为 i 的组合数
// 先遍历容量，再遍历物品：可以保证本次单独使用每一个物品的时候，加上之前的组合数，都可以遍历到
class Solution {
public:
  int combinationSum4(vector<int> &nums, int target) {
    vector<int> dp(target + 1, 0);
    dp[0] = 1;
    for (int i = 1; i <= target; i++) {       // 遍历容量
      for (int j = 0; j < nums.size(); j++) { // 遍历物品
        if (i >= nums[j] && dp[i] < INT32_MAX - dp[i - nums[j]])  // 有一些测试用例超出了 INT32_MAX
          dp[i] += dp[i - nums[j]];
      }
    }
    return dp[target];
  }
};
```

### 70. 爬楼梯（进阶版）

[57. 爬楼梯（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1067)

```python

```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
  int n, m;
  cin >> n >> m; // n 表示台阶数
  vector<int> dp(n + 1, 0);
  dp[0] = 1;
  for (int i = 1; i <= n; i++)   // 遍历背包（台阶数）
    for (int j = 1; j <= m; j++) // 遍历物品，每次爬几个台阶
      if (i >= j) dp[i] += dp[i - j];
  cout << dp[n];
  return 0;
}
```

### 322. 零钱兑换

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/description/)

```python

```

```cpp
// 先遍历容量，再遍历物品
class Solution {
public:
  int coinChange(vector<int> &coins, int amount) {
    vector<int> dp(amount + 1, INT32_MAX);
    dp[0] = 0;
    for (int i = 1; i <= amount; ++i)
      for (int j = 0; j < coins.size(); ++j)
        if (i >= coins[j] && dp[i - coins[j]] != INT32_MAX)
          dp[i] = min(dp[i], dp[i - coins[j]] + 1);
    return dp[amount] == INT32_MAX ? -1 : dp[amount];
  }
};

// 先遍历物品，再遍历容量
class Solution {
public:
  int coinChange(vector<int> &coins, int amount) {
    vector<int> dp(amount + 1, INT32_MAX);
    dp[0] = 0;
    for (int i = 0; i < coins.size(); i++)     // 遍历硬币
      for (int j = coins[i]; j <= amount; j++) // 遍历容量
        if (dp[j - coins[i]] != INT32_MAX)     // 原始值说明没有方案
          dp[j] = min(dp[j], dp[j - coins[i]] + 1);
    return dp[amount] == INT32_MAX ? -1 : dp[amount]; // 涵盖了 dp[0] = 0;
  }
};
```

### 279. 完全平方数

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/description/)

```python

```

```cpp
class Solution {
public:
  int numSquares(int n) {
    vector<int> dp(n + 1, INT32_MAX);
    dp[0] = 0;
    for (int i = 1; i * i <= n; ++i)
      for (int j = i * i; j <= n; ++j)
        dp[j] = min(dp[j], dp[j - i * i] + 1);
    return dp[n];
  }
};
```

### 139. 单词拆分

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/description/)

```python

```

```cpp
class Solution {
public:
  bool wordBreak(string s, vector<string> &wordDict) {
    vector<bool> dp(s.size() + 1, false);
    dp[0] = true;
    // 注意这个次序很重要，因为要保证不但能出现 apple pen，还要能出现 pen apple
    for (int j = 1; j < dp.size(); j++)         // 遍历背包
      for (int i = 0; i < wordDict.size(); i++) // 遍历物品
        if (wordDict[i].size() <= j)
          dp[j] = dp[j] || (dp[j - wordDict[i].size()] &&
                            wordDict[i] == s.substr(j - wordDict[i].size(),
                                                    wordDict[i].size()));
    return dp[s.size()];
  }
};
```

### 多重背包

[56. 携带矿石资源（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1066)

```python

```

```cpp
// 处理为 0-1 背包问题
#include <iostream>
#include <vector>
using namespace std;

int main() {
  int w, n; // w 表示背包容量，n 表示物品种类数量
  cin >> w >> n;
  vector<int> weights(n, 0); // n 种物品的重量
  vector<int> values(n, 0);  // n 种物品的价值
  vector<int> nums(n, 0);    // n 种物品各自的数量
  vector<int> dp(w + 1, 0);
  for (int i = 0; i < n; i++)
    cin >> weights[i];
  for (int i = 0; i < n; i++)
    cin >> values[i];
  for (int i = 0; i < n; i++)
    cin >> nums[i];

  for (int i = 0; i < n; i++) // 展开操作
    while (nums[i]-- > 1) {
      weights.push_back(weights[i]);
      values.push_back(values[i]);
    }

  // 0-1 背包问题，滚动数组优化
  for (int i = 0; i < weights.size(); i++) // 遍历物品
    for (int j = w; j >= weights[i]; j--)  // 遍历背包
      dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);

  cout << dp[w];
  return 0;
}

// 多重背包
#include <iostream>
#include <vector>
using namespace std;

int main() {
  int w, n;
  cin >> w >> n;
  vector<int> weights(n, 0);
  vector<int> values(n, 0);
  vector<int> nums(n, 0);
  vector<int> dp(w + 1, 0);
  for (int i = 0; i < n; i++)
    cin >> weights[i];
  for (int i = 0; i < n; i++)
    cin >> values[i];
  for (int i = 0; i < n; i++)
    cin >> nums[i];

  // 多重背包问题，滚动数组优化
  for (int i = 0; i < weights.size(); i++) // 遍历物品
    for (int j = w; j >= weights[i]; j--)  // 遍历背包
      for (int k = 1; k <= nums[i] && (k * weights[i] <= j); k++)
        dp[j] = max(dp[j], dp[j - k * weights[i]] + k * values[i]);

  cout << dp[w];
  return 0;
}
```

### 198. 打家劫舍

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/description/)

```python

```

```cpp
// 每个房间只有两种选择，偷或者不偷
class Solution {
public:
  int rob(vector<int> &nums) {
    if (nums.size() == 1) return nums[0];
    vector<int> dp(nums.size());
    dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]);
    for (int i = 2; i < dp.size(); ++i)
      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
    return dp.back();
  }
};
```

### 213. 打家劫舍 II

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/description/)

```python

```

```cpp
// 绝不偷第一个房间，或者绝不偷最后一个房间
class Solution {
private:
  int robHelper(vector<int> &nums, int startIndex, int endIndex) {
    // static vector<int> dp(endIndex - startIndex + 1); // static 并不知道应该初始化多大的空间（leetcode）
    vector<int> dp(endIndex - startIndex + 1);
    dp[0] = nums[startIndex];
    dp[1] = max(nums[startIndex], nums[startIndex + 1]);
    for (int i = 2; i < dp.size(); ++i)
      dp[i] = max(dp[i - 1], dp[i - 2] + nums[startIndex + i]);
    return dp.back();
  }

public:
  int rob(vector<int> &nums) {
    if (nums.size() == 1 || nums.size() == 2)
      return *max_element(nums.begin(), nums.end());
    return max(robHelper(nums, 0, nums.size() - 2),
               robHelper(nums, 1, nums.size() - 1));
  }
};
```

### 337. 打家劫舍 III

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/description/)

```python

```

```cpp
class Solution {
private:
  pair<int, int> dfs(TreeNode *root) { // first: rob, second: not rob
    if (!root) return {0, 0};
    auto left = dfs(root->left);
    auto right = dfs(root->right);
    return {root->val + left.second + right.second,
            max(left.first, left.second) + max(right.first, right.second)};
  }

public:
  int rob(TreeNode *root) {
    auto res = dfs(root);
    return max(res.first, res.second);
  }
};
```

### 121. 买卖股票的最佳时机

> 买卖股票只要不限制不能当天买卖，那么就可以滚动数组而不保存之前的状态

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/)

```python

```

```cpp
// 贪心（正向）
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    int res = 0, low = prices[0];
    for (int i = 1; i < prices.size(); ++i) {
      low = min(low, prices[i]);
      res = max(res, prices[i] - low);
    }
    return res;
  }
};

// 贪心（反向）
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    int res = 0, high = prices.back();  // 指向当前遍历过的最大元素
    for (int i = prices.size() - 2; i >= 0; --i) {
      high = max(high, prices[i]);
      res = max(res, high - prices[i]);
    }
    return res;
  }
};

// 动态规划（非滑动数组）
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    vector<pair<int, int>> dp(prices.size());
    dp[0] = {-prices[0], 0}; // 初始化第 0 天持股和不持股的最大收益
    for (int i = 1; i < dp.size(); ++i) {
      dp[i].second = max(dp[i - 1].second,
                         dp[i - 1].first + prices[i]); // 不持股的最大收益
      dp[i].first = max(dp[i - 1].first, -prices[i]); // 持股的最大收益
    }
    return dp.back().second;
  }
};

// 动态规划（滑动数组）
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    pair<int, int> dp = {-prices[0], 0}; // 初始化第 0 天持股和不持股的最大收益
    for (int i = 1; i < prices.size(); ++i) {
      dp.second = max(dp.second,
                      dp.first + prices[i]); // 不持股的最大收益
      dp.first = max(dp.first, -prices[i]);  // 持股的最大收益
    }
    return dp.second;
  }
};
```

### [122. 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii)

### 123. 买卖股票的最佳时机 III

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/description/)

```python

```

```cpp
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    vector<int> dp(4, 0);
    dp[0] = dp[2] = -prices[0]; // 考虑当天买入卖出再买入的情况
    for (int i = 1; i < prices.size(); ++i) {
      dp[0] = max(dp[0], -prices[i]);        // 第一次持股
      dp[1] = max(dp[1], dp[0] + prices[i]); // 第一次不持股
      dp[2] = max(dp[2], dp[1] - prices[i]); // 第二次持股
      dp[3] = max(dp[3], dp[2] + prices[i]); // 第二次不持股
    }
  }
};
```

### 188. 买卖股票的最佳时机 IV

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/description/)

```python

```

```cpp
class Solution {
public:
  int maxProfit(int k, vector<int> &prices) {
    vector<int> dp(2 * k + 1, 0); // 多初始化一位是为了下面 for 循环的统一操作
    for (int i = 1; i < dp.size(); i += 2)
      dp[i] = -prices[0];
    for (int i = 0; i < prices.size(); ++i)
      for (int j = 1; j < dp.size(); ++j)
        dp[j] = max(dp[j], dp[j - 1] + (j % 2 ? -1 : 1) * prices[i]);
    return dp.back();
  }
};
```

### 309. 最佳买卖股票时机含冷冻期

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

```python

```

```cpp
class Solution {
public:
  int maxProfit(vector<int> &prices) {
    vector<int> dp(3, 0);
    dp[0] = -prices[0];
    for (int i = 1; i < prices.size(); ++i) {
      dp[0] = max(dp[0], dp[1] - prices[i]); // 持有
      dp[1] = max(dp[1], dp[2]);             // 不持有
      dp[2] = dp[0] + prices[i];             // 不持有（冷冻期）
    }
    return max(dp[1], dp[2]);
  }
};
```

### 714. 买卖股票的最佳时机含手续费

[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

```python

```

```cpp
class Solution {
public:
  int maxProfit(vector<int> &prices, int fee) {
    pair<int, int> dp = {-prices[0] - fee,
                         0}; // 初始化第 0 天持股和不持股的收益
    for (int i = 1; i < prices.size(); ++i) {
      dp.first = max(dp.first, dp.second - prices[i] - fee);
      dp.second = max(dp.second, dp.first + prices[i]);
    }
    return dp.second;
  }
};
```

### 300. 最长递增子序列

[300.最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/)

```python

```

```cpp
class Solution {
public:
  int lengthOfLIS(vector<int> &nums) {
    vector<int> dp(nums.size(),
                   1); // dp[i] 表示以 nums[i] 为结尾的最长子序列的长度
    int res = 1;
    for (int i = 1; i < dp.size(); ++i) {
      for (int j = 0; j < i; ++j)
        if (nums[i] > nums[j])
          dp[i] = max(dp[i], dp[j] + 1);
      res = max(dp[i], res);
    }
    return res;
  }
};
```

### 674. 最长连续递增序列

[674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/description/)

```python

```

```cpp
// 一遍 for 循环，记录出现过的最大长度
class Solution {
public:
  int findLengthOfLCIS(vector<int> &nums) {
    int res = 1, count = 1;
    for (int i = 1; i < nums.size(); ++i) {
      if (nums[i] > nums[i - 1]) {
        count++;
        res = max(res, count);
      } else
        count = 1;
    }
    return res;
  }
};

// 动态规划
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int res = 1;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] > nums[i - 1])
                dp[i] = dp[i - 1] + 1;
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

### 718. 最长重复子数组

[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/description/)

```python

```

```cpp
// 动态规划
class Solution {
public:
  int findLength(vector<int> &nums1, vector<int> &nums2) {
    vector<vector<int>> dp(
        nums1.size() + 1,
        vector<int>(nums2.size() + 1, 0)); // + 1 是为了对于边界统一操作
    int res = 0;
    for (int i = 1; i <= nums1.size(); i++)
      for (int j = 1; j <= nums2.size(); j++)
        if (nums1[i - 1] == nums2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1] + 1;
          res = max(res, dp[i][j]);
        }
    return res;
  }
};

// 动态规划（滚动数组）
class Solution {
public:
  int findLength(vector<int> &nums1, vector<int> &nums2) {
    vector<int> dp(nums2.size() + 1, 0);
    int res = 0;
    for (int i = 0; i < nums1.size(); ++i)
      for (int j = nums2.size() - 1; j >= 0; --j)
        if (nums1[i] == nums2[j]) {
          dp[j + 1] = dp[j] + 1;
          res = max(res, dp[j + 1]);
        } else
          dp[j + 1] = 0;  // 重置
    return res;
  }
};
```

### 1143. 最长公共子序列

[1143.最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/description/)

```python

```

```cpp
// 动态规划
class Solution {
public:
  int longestCommonSubsequence(string text1, string text2) {
    // + 1 是为了对于边界统一操作
    vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
    for (int i = 0; i < text1.size(); ++i)
      for (int j = 0; j < text2.size(); ++j)
        dp[i + 1][j + 1] = text1[i] == text2[j]
                               ? dp[i][j] + 1
                               : max(dp[i + 1][j], dp[i][j + 1]);
    return dp.back().back();
  }
};

// 动态规划（滚动数组）
// 无法压到一维，因为要用当前轮次左侧的信息和上一轮次上侧的信息。
class Solution {
public:
  int longestCommonSubsequence(string text1, string text2) {
    vector<vector<int>> dp(2, vector<int>(text2.size() + 1, 0));
    for (int i = 0; i < text1.size(); ++i) {
      for (int j = 0; j < text2.size(); ++j)
        dp[1][j + 1] =
            text1[i] == text2[j] ? dp[0][j] + 1 : max(dp[1][j], dp[0][j + 1]);
      dp[0] = dp[1];
    }
    return dp[1].back();
  }
};
```

### 1035. 不相交的线

[1035.不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/description/)

```python

```

```cpp
// 最长公共子序列
class Solution {
public:
  int maxUncrossedLines(vector<int> &nums1, vector<int> &nums2) {
    vector<vector<int>> dp(2, vector<int>(nums2.size() + 1, 0));
    for (int i = 0; i < nums1.size(); ++i) {
      for (int j = 0; j < nums2.size(); ++j)
        dp[1][j + 1] =
            nums1[i] == nums2[j] ? dp[0][j] + 1 : max(dp[0][j + 1], dp[1][j]);
      dp[0] = dp[1];
    }
    return dp[1].back();
  }
};
```

### 53. [最大子序和](#53-最大子序和)

### 392. 判断子序列

[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/description/)

```python

```

```cpp
// 双指针
class Solution {
public:
  bool isSubsequence(string s, string t) {
    int i = 0, j = 0;
    while (i < s.size() && j < t.size())
      if (s[i] == t[j++]) ++i;
    return i == s.size();
  }
};

// 动态规划
class Solution {
public:
  bool isSubsequence(string s, string t) {
    vector<vector<int>> dp(2, vector<int>(t.size() + 1, 0));
    for (int i = 0; i < s.size(); ++i) {
      for (int j = 0; j < t.size(); ++j)
        dp[1][j + 1] =
            s[i] == t[j] ? dp[0][j] + 1 : max(dp[1][j], dp[0][j + 1]);
      if (dp[1].back() == s.size()) return true;  // 判断是否可以提前结束
      dp[0] = dp[1];
    }
    return dp[1].back() == s.size();
  }
};
```

### 115. 不同的子序列

[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/description/)

```python

```

```cpp
/*
1. 解决思路，是否使用当前s[i-1]进行匹配
2. 初始化，要保证不输出 0 ，所以如果第一次匹配成功，要想办法让它为 1
3. 注意使用 unsigned int
*/
class Solution {
public:
  int numDistinct(string s, string t) {
    vector<vector<unsigned int>> dp(2, vector<unsigned int>(s.size() + 1, 1));
    dp[1][0] = 0;
    for (int i = 0; i < t.size(); ++i) {
      for (int j = 0; j < s.size(); ++j)
        // 是否使用s[i-1]进行匹配
        dp[1][j + 1] = t[i] == s[j] ? dp[0][j] + dp[1][j] : dp[1][j];
      dp[0] = dp[1];
    }
    return dp[1].back();
  }
};
```

### 583. 两个字符串的删除操作

[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/)

```python

```

```cpp
// 删的只剩下最长公共子序列就好了
class Solution {
public:
  int minDistance(string word1, string word2) {
    vector<vector<int>> dp(2, vector<int>(word2.size() + 1, 0));
    for (int i = 0; i < word1.size(); ++i) {
      for (int j = 0; j < word2.size(); ++j)
        dp[1][j + 1] =
            word1[i] == word2[j] ? dp[0][j] + 1 : max(dp[1][j], dp[0][j + 1]);
      dp[0] = dp[1];
    }
    return word1.size() + word2.size() - 2 * dp[1].back();
  }
};

// 编辑距离（只能删除）
class Solution {
public:
  int minDistance(string word1, string word2) {
    vector<vector<int>> dp(2, vector<int>(word2.size() + 1));
    for (int i = 0; i < dp[0].size(); ++i)  // 初始化第一行
      dp[0][i] = i;

    for (int i = 0; i < word1.size(); ++i) {
      dp[1][0] = i + 1; // 滚动数组的第一列初始化
      for (int j = 0; j < word2.size(); ++j)
        dp[1][j + 1] =
            word1[i] == word2[j] ? dp[0][j] : min(dp[0][j + 1], dp[1][j]) + 1;
      dp[0] = dp[1];
    }
    return dp[1].back();
  }
};
```

### 72. 编辑距离

[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/description/)

```python

```

```cpp
class Solution {
public:
  int minDistance(string word1, string word2) {
    if (word2.empty()) return word1.size();  // 可以删除，下面的循环已经兼顾了这种情况
    vector<vector<int>> dp(2, vector<int>(word2.size() + 1));
    for (int i = 0; i < dp[0].size(); ++i)
      dp[0][i] = i;
    for (int i = 0; i < word1.size(); ++i) {
      dp[1][0] = i + 1;
      for (int j = 0; j < word2.size(); ++j)
        dp[1][j + 1] = word1[i] == word2[j]
                           ? dp[0][j]
                           : min({dp[0][j], dp[0][j + 1], dp[1][j]}) + 1;
      dp[0] = dp[1];
    }
    return dp[0].back();  // 兼顾 word1 为空的情况
  }
};
```

### 647. 回文子串

[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/description/)

```python

```

```cpp
// 动态规划 + 双指针
class Solution {
private:
  bool isPalindrome(const string &s, int left, int right) { // []
    while (left < right)
      if (s[left++] != s[right--])
        return false;
    return true;
  }

public:
  int countSubstrings(string s) {
    vector<int> dp(s.size() + 1, 0); // dp[i]表示以 s[i] 结尾的回文子串个数
    for (int i = 0; i < s.size(); ++i) {
      dp[i + 1] += dp[i];
      for (int j = 0; j <= i; ++j)
        if (isPalindrome(s, j, i))
          ++dp[i + 1];
    }
    return dp.back();
  }
};

// 巧妙动态规划
class Solution {
public:
  int countSubstrings(string s) {
    vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
    int res = 0;
    for (int i = s.size() - 1; i >= 0; --i) {
      for (int j = i; j < s.size(); j++)
        if (s[i] == s[j] && (j - i <= 1 || dp[i + 1][j - 1])) {
          dp[i][j] = true;
          res++;
        }
    }
    return res;
  }
};

// 巧妙动态规划（滚动数组）
class Solution {
public:
  int countSubstrings(string s) {
    vector<vector<bool>> dp(2, vector<bool>(s.size(), false));
    int res = 0;
    for (int i = s.size(); i >= 0; --i) {
      for (int j = i; j < s.size(); ++j)
        if (s[i] == s[j] && (j - i < 2 || dp[0][j - 1])) {
          dp[1][j] = true;
          ++res;
        } else
          dp[1][j] = false;
      swap(dp[0], dp[1]);
    }
    return res;
  }
};

// 双指针
// 计算以 i 为中心的回文子串个数
class Solution {
private:
  int extend(string &s, int i, int j) {
    int res = 0;
    while (i >= 0 && j < s.size() && s[i--] == s[j++])
      ++res;
    return res;
  }

public:
  int countSubstrings(string s) {
    int ans = 0;
    for (int i = 0; i < s.size(); ++i) {
      ans += extend(s, i, i);
      ans += extend(s, i, i + 1);
    }
    return ans;
  }
};
```

### 516. 最长回文子序列

[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/)

```python

```

```cpp
// 动态规划，很好的初始化
class Solution {
public:
  int longestPalindromeSubseq(string s) {
    // dp[i][j]代表从 i 到 j 范围内最长的回文子序列长度
    vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
    // 通过更好的初始化进行统一操作
    for (int i = 0; i < s.size(); i++)
      dp[i][i] = 1;
    for (int i = s.size(); i >= 0; i--)
      for (int j = i + 1; j < s.size(); j++)
        dp[i][j] = s[i] == s[j] ? dp[i + 1][j - 1] + 2
                                : max(dp[i + 1][j], dp[i][j - 1]); // 不会越界的
    return dp[0].back();
  }
};

// 动态规划（滚动数组）
class Solution {
public:
  int longestPalindromeSubseq(string s) {
    // dp[i][j]代表从 i 到 j 范围内最长的回文子序列长度
    vector<vector<int>> dp(2, vector<int>(s.size(), 0));
    for (int i = s.size() - 1; i >= 0; --i) {
      dp[1][i] = 1;
      for (int j = i + 1; j < s.size(); ++j)
        dp[1][j] = s[i] == s[j] ? dp[0][j - 1] + 2
                                : max(dp[0][j], dp[1][j - 1]);
      dp[0] = dp[1];
    }
    return dp[1].back();
  }
};
```

---

## 11 单调栈

### 739. 每日温度

[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/description/)

```python

```

```cpp
class Solution {
public:
  vector<int> dailyTemperatures(vector<int> &temperatures) {
    stack<int> st;
    vector<int> res(temperatures.size(), 0);
    for (int i = 0; i < temperatures.size(); ++i) {
      while (!st.empty() && temperatures[st.top()] < temperatures[i]) {
        res[st.top()] = i - st.top();
        st.pop();
      }
      st.push(i);
    }
    return res;
  }
};
```

### 496. 下一个更大元素 I

[496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/description/)

```python

```

```cpp
class Solution {
public:
  vector<int> nextGreaterElement(vector<int> &nums1, vector<int> &nums2) {
    vector<int> res(nums1.size(), -1);
    unordered_map<int, int> umap;
    stack<int> st;

    for (int i = 0; i < nums1.size(); ++i)
      umap[nums1[i]] = i;

    for_each(nums2.begin(), nums2.end(), [&](const int &num){
      while (!st.empty() && st.top() < num) {
        res[umap[st.top()]] = num;
        st.pop();
      }
      if (umap.find(num) != umap.end()) st.push(num);
    });
    return res;
  }
};
```

### 503. 下一个更大元素 II

[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/description/)

```python

```

```cpp
class Solution {
public:
  vector<int> nextGreaterElements(vector<int> &nums) {
    vector<int> res(nums.size(), -1);
    stack<int> st;

    int startIndex =
        (distance(nums.begin(), max_element(nums.begin(), nums.end())) + 1) %
        nums.size();    // 起点：最大值的下一个位置

    int count = 0; // 转一圈
    for (int i = startIndex; count < nums.size();
         count++, i = (i + 1) % nums.size()) {
      while (!st.empty() && nums[i] > nums[st.top()]) {
        res[st.top()] = nums[i];
        st.pop();
      }
      st.push(i);
    }
    return res;
  }
};
```

### 42. 接雨水

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/description/)

```python

```

```cpp
// 暴力解，超时
class Solution {
public:
  int trap(vector<int> &height) {
    int sum = 0;
    for (int i = 1; i < height.size() - 1; ++i) {
      int left = height[i], right = height[i];

      for (int j = i - 1; j >= 0; --j)
        left = max(left, height[j]);

      for (int j = i + 1; j < height.size(); ++j)
        right = max(right, height[j]);
      sum += min(left, right) - height[i];
    }
    return sum;
  }
};

// 动规求出每个位置左侧和右侧的最高高度的较小值
// dp 数组复用
class Solution {
public:
  int trap(vector<int> &height) {
    vector<int> dp(height.size());
    int res = 0;
    dp[0] = height[0];
    dp.back() = height.back();
    for (int i = 1; i < height.size() - 1; ++i) // 找左侧最大
      dp[i] = max(dp[i - 1], height[i]);
    for (int i = height.size() - 2; i > 0; --i) // 1. 找右侧最大 2. 两个最大值中取一个最小值
      dp[i] = min(max(dp[i + 1], height[i]), dp[i]);
    for (int i = 1; i < height.size() - 1; ++i)
      res += dp[i] - height[i];
    return res;
  }
};


// 单调栈
// 利用 次栈顶元素 < 栈顶元素 < 当前元素（将要入栈元素） 的这一性质
class Solution {
public:
  int trap(vector<int> &height) {
    int sum = 0;
    stack<int> st;
    st.push(0);
    for (int i = 1; i < height.size(); ++i) {
      while (!st.empty() && height[i] > height[st.top()]) {
        int cur = st.top();
        st.pop();
        if (!st.empty()) {
          int w = i - st.top() - 1;
          int h = min(height[st.top()], height[i]) - height[cur];
          sum += h * w;
        }
      }
      st.push(i);
    }
    return sum;
  }
};
```

### 84. 柱状图中最大的矩形

[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/)

```python

```

```cpp
// 暴力解法，找出以每个位置为高的矩形面积做比较，超时
class Solution {
public:
  int largestRectangleArea(vector<int> &heights) {
    int res = heights[0];
    for (int i = 0; i < heights.size(); ++i) {
      int left = i, right = i;
      while (left >= 0) {
        if (heights[left] < heights[i]) break;
        --left;
      }
      while (right < heights.size()) {
        if (heights[right] < heights[i]) break;
        ++right;
      }
      res = max((right - left - 1) * heights[i], res);
    }
    return res;
  }
};

// 双指针，很巧妙的动态规划
class Solution {
public:
  int largestRectangleArea(vector<int> &heights) {
    vector<int> minLeftIndex(
        heights.size()); // 记录左边第一个比当前元素小的元素的下标
    vector<int> minRightIndex(
        heights.size()); // 记录右边第一个比当前元素小的元素的下标
    int res = heights[0];
    for (int i = 0; i < heights.size(); ++i) {
      int t = i - 1;
      while (t >= 0 && heights[t] >= heights[i]) t = minLeftIndex[t];
      minLeftIndex[i] = t;

      int j = heights.size() - i - 1; t = j + 1;
      while (t < heights.size() && heights[t] >= heights[j]) t = minRightIndex[t];
      minRightIndex[j] = t;
    }

    for (int i = 0; i < heights.size(); ++i)
      res = max(res, (minRightIndex[i] - minLeftIndex[i] - 1) * heights[i]);
    return res;
  }
};

// 单调栈，前后加 0 技巧
// 前加 0 是为了保证栈不为空，后加 0 是为了保证栈中所有元素都出栈
class Solution {
public:
  int largestRectangleArea(vector<int> &heights) {
    stack<int> st; // 单调栈
    heights.insert(heights.begin(), 0);
    heights.push_back(0);
    int ans = 0;
    st.push(0); // 索引
    for (int i = 1; i < heights.size(); i++) {
      while (!st.empty() && heights[i] < heights[st.top()]) {
        int mid = st.top();
        st.pop();
        // if (!st.empty()) // st 肯定不为空
          ans = max(ans, (i - st.top() - 1) * heights[mid]);
      }
      // if (heights[i] > heights[st.top()])    // 会导致 [0, 1, 0, 1]
      // 这种用例出错
      st.push(i);
    }
    return ans;
  }
};

// 优化后
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> st;
        st.push(-1);
        int ans = heights[0];
        for (int i = 0; i < heights.size(); ++i) {
            while (st.size() != 1 && heights[i] < heights[st.top()]) {
                int cur = st.top();
                st.pop();
                ans = max(ans, (i - st.top() - 1) * heights[cur]);
            }
            st.push(i);
        }
        while (st.size() != 1) {
            int cur = st.top();
            st.pop();
            int temp = (heights.size() - st.top() - 1) * heights[cur];
            ans = max(ans, temp);
        }
        return ans;
    }
};
```

---

## 12 图论

### 98. 所有可达路径

[98. 所有可达路径](https://kamacoder.com/problempage.php?pid=1170)

### 797. 所有可能的路径

[797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/description/)

### 99. 岛屿数量

[99. 岛屿数量](https://kamacoder.com/problempage.php?pid=1171)

### 100. 岛屿的最大面积

[100. 岛屿的最大面积](https://kamacoder.com/problempage.php?pid=1172)

### 101. 孤岛的总面积

[101. 孤岛的总面积](https://kamacoder.com/problempage.php?pid=1173)

### 102. 沉没孤岛

[102. 沉没孤岛](https://kamacoder.com/problempage.php?pid=1174)

### 103. 水流问题

[103. 水流问题](https://kamacoder.com/problempage.php?pid=1175)

### 104.建造最大岛屿

[104.建造最大岛屿](https://kamacoder.com/problempage.php?pid=1176)

### 110. 字符串接龙

[110. 字符串接龙](https://kamacoder.com/problempage.php?pid=1183)

### 105.有向图的完全可达性

[105.有向图的完全可达性](https://kamacoder.com/problempage.php?pid=1177)

### 106. 岛屿的周长

[106. 岛屿的周长](https://kamacoder.com/problempage.php?pid=1178)

### 107. 寻找存在的路径

[107. 寻找存在的路径](https://kamacoder.com/problempage.php?pid=1179)

### 108. 冗余连接

[108. 冗余连接](https://kamacoder.com/problempage.php?pid=1181)

### 109. 冗余连接 II

[109. 冗余连接 II](https://kamacoder.com/problempage.php?pid=1182)

### prim 算法

[53. 寻宝（第七期模拟笔试）](https://kamacoder.com/problempage.php?pid=1053)

### kruskal 算法

[53. 寻宝（第七期模拟笔试）](https://kamacoder.com/problempage.php?pid=1053)

### 拓扑排序

[117. 软件构建](https://kamacoder.com/problempage.php?pid=1191)

### dijkstra

[47. 参加科学大会（第六期模拟笔试）](https://kamacoder.com/problempage.php?pid=1047)

### Bellman_ford 算法

### Bellman_ford 队列优化算法（又名 SPFA）

[94. 城市间货物运输 I](https://kamacoder.com/problempage.php?pid=1152)

### bellman_ford 之判断负权回路

[95. 城市间货物运输 II](https://kamacoder.com/problempage.php?pid=1153)

### bellman_ford 之单源有限最短路

[96. 城市间货物运输 III](https://kamacoder.com/problempage.php?pid=1154)

### Floyd 算法

[97. 小明逛公园](https://kamacoder.com/problempage.php?pid=1155)

### A \* 算法 （A star 算法）

[127. 骑士的攻击](https://kamacoder.com/problempage.php?pid=1203)
